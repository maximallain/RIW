.I 1
.T
Preliminary Report-International Algebraic Language
.I 2
.T
Extraction of Roots by Repeated Subtractions for Digital Computers
.I 3
.T
Techniques Department on Matrix Program Schemes
.I 4
.T
Glossary of Computer Engineering and Programming Terminology
.I 5
.T
Two Square-Root Approximations
.I 6
.T
The Use of Computers in Inspection Procedures
.I 7
.T
Glossary of Computer Engineering and Programming Terminology
.I 8
.T
On The Equivalence and Transformation of Program Schemes
.I 9
.T
Proposal for an UNCOL
.I 10
.T
Glossary of Computer Engineering and Programming Terminology
.I 11
.T
The Problem of Programming Communication with
Changing Machines A Proposed Solution-Part 2
.I 12
.T
Error Estimation in Runge-Kutta Procedures
.I 13
.T
Glossary of Computer Engineering and Programming Terminology
.I 14
.T
The Problem of Programming Communication with
Changing Machines A Proposed Solution (Part 1)
.I 15
.T
Recursive Curve Fitting Technique
.I 16
.T
Secant Modification of Newton's Method
.I 17
.T
On Programming of Arithmetic Operations
.I 18
.T
Simple Automatic Coding Systems
.I 19
.T
Glossary of Computer Engineering and Programming Terminology
.I 20
.T
Accelerating Convergence of Iterative Processes
.W
A technique is discussed which, when applied
to an iterative procedure for the solution of
an equation, accelerates the rate of convergence if
the iteration converges and induces convergence if
the iteration diverges.  An illustrative example is given.
.I 21
.T
Algebraic Formulation of Flow Diagrams
.I 22
.T
Unusual Applications Department--Automatic
Implementation of Computer Logic
.I 23
.T
Binary and Truth-Function Operations on
a Decimal Computer with an Extract Command
.I 24
.T
An Improved Decimal Redundancy Check
.I 25
.T
General Purpose Programming Systems
.I 26
.T
A Subroutine Method for Calculating Logarithms
.I 27
.T
Note On Empirical Bounds For Generating Bessel Functions
.I 28
.T
Request for Methods or Programs
.I 29
.T
Need for an Algorithm
.I 30
.T
Algorithm for Analyzing Logical Statements
to Produce a Truth Function Table
.I 31
.T
IBM 704 Code-Nundrums
.I 32
.T
Variable-Width Tables with Binary-Search Facility
.I 33
.T
A Programmed Binary Counter For The IBM Type 650 Calculator
.I 34
.T
Tables for Automatic Computation
.I 35
.T
A Machine Method for Square-Root Computation
.I 36
.T
A Queue Network Simulator for the IBM 650 and Burroughs 220
.I 37
.T
Impact of Computer Developments
.I 38
.T
A Proposed Interpretation in ALGOL
.I 39
.T
The Secant Method for Simultaneous Nonlinear Equations 
.W
A procedure for the simultaneous solution
of a system of not-necessarily-linear equations, 
a generalization of the secant method for a
single function of one variable, is given.
.I 40
.T
Fingers or Fists? (The Choice of Decimal or Binary Representation)
.W
The binary number system offers many advantages
over a decimal representation for a high-performance, 
general-purpose computer.  The greater simplicity of
a binary arithmetic unit and the greater compactness 
of binary numbers both contribute directly to arithmetic
speed.  Less obvious and perhaps more important 
is the way binary addressing and instruction formats can
increase the overall performance.  Binary addresses 
are also essential to certain powerful operations which
are not practical with decimal instruction formats. 
 On the other hand, decimal numbers are essential for
communicating between man and the computer.  In 
applications requiring the processing of a large volume
of inherently decimal input and output data, 
the time for decimal-binary conversion needed by a purely
binary computer may be significant.  A slower 
decimal adder may take less time than a fast binary adder
doing an addition and two conversions.  A careful 
review of the significance of decimal and binary addressing
and both binary and decimal data arithmetic, 
supplemented by efficient conversion instructions.
.I 41
.T
Some Notes on Computer Research in Eastern Europe
.I 42
.T
A New Method of Computation of Square Roots Without Using Division
.I 43
.T
A Technique for Handling Macro Instructions
.I 44
.T
RUNCIBLE-Algebraic Translation on a Limited Computer
.I 45
.T
Flow Outlining-A Substitute for Flow Charting
.I 46
.T
Multiprogramming STRETCH: Feasibility Considerations
.W
The tendency towards increased parallelism in
computers is noted.  Exploitation of this parallelism 
presents a number of new problems in machine design
and in programming systems.  Minimum requirements 
for successful concurrent execution of several independent
problem programs are discussed.  These requirements 
are met in the STRETCH system by a carefully balanced
combination of built-in and programmed logic.  
Techniques are described which place the burden of the
programmed logic on system programs (supervisory 
program and compiler) rather than on problem programs.
.I 47
.T
Russian Visit to U.S. Computers
.I 48
.T
Shift-Register Code for Indexing Applications
.W
In this communication the use of a shift-register
code with n = 10 is described for calling 
64 wireless telemetering stations in a fixed cyclical order.
 A high degree of redundancy is used, permitting 
a single-error correcting code ("minimum-distance-three"
code) with 64 10-bit code words to be employed 
as the station identification code.  Embedding this in
the shift-register code with period 1023 permits 
the code to be employed without punctuation, each of
the telemetering station receivers simply putting 
received ones and zeros into a shift register.  Each
time the given code combination arises identifying 
the particular station (barring for tuitous error combinations
of very low probability) it has been called. 
 The communication describes the properties and application
of the code in some detail and the finding 
of the particular example to be employed on URAL, the
Soviet-built drum computer donated to the Indian 
Statistical Institute by the United Nations
Technical Aid Administration (UNTAA).
.I 49
.T
Scientific and Business Applications (Oracle Curve Plotter)
.I 50
.T
Statistical Programs for the IBM 650-Part II
.I 51
.T
On the Construction of Micro-Flowcharts
.I 52
.T
An Efficient Method for Generating Uniformly Distributed
Points on the Surface on an n-Dimensional 
Sphere (Corrigendum)
.I 53
.T
Recommendations of the SHARE ALGOL Committee
.I 54
.T
SALE, a Simple Algebraic Language for Engineers
.I 55
.T
An Algebraic Translator
.I 56
.T
Proposed Standard Flow Chart Symbols
.I 57
.T
J.E.I.D.A. and Its Computer Center
.I 58
.T
LEM-1, Small Size General Purpose Digital
Computer Using Magnetic (Ferrite) Elements
.W
The paper examines some of the questions of
development and construction of a general purpose 
digital computer using contactless magnetic (ferrite)
and capacitive "DEZU" (long duration capacitive 
memory) elements, developed at the Laboratory of Electrical
Modeling VINITYI AN SSSR, under the supervision 
of Professor L.I. Gutenmacher.
.I 59
.T
Survey of Progress and Trend of Development
and Use of Automatic Data Processing in Business
and Management control Systems of the Federal
Government, as of December 1957-III
.I 60
.T
The Alpha Vector Transformation of a System of Linear Constraints
.I 61
.T
IBM 709 Tape Matrix Compiler
.I 62
.T
Multi-Dimensional Least-Squares Polynomial Curve Fitting
.I 63
.T
Octal Diagrams of Binary Conception and
Their Applicability to Computer Design Logic
.W
This paper dates back the genesis of binary
conception circa 5000 years ago, and octal diagrams 
about 4800 years ago, as derived by the Chinese ancients.
 It analyzes the applicability of binary trinities 
of the octal diagrams to modern electronic-digital-computer design logic.
.I 64
.T
Remarks on ALGOL and Symbol Manipulation 
.I 65
.T
ALGOL Sub-Committee Report - Extensions
.I 66
.T
A Proposal for a Generalized Card Code for 256 Characters
.I 67
.T
Central-European Computers
.I 68
.T
The Role of the University in Computers,
Data Processing and Related Fields
.W
A study was made of university programs in
the United States in the fields of computers, data 
processing, operations research, and other closely related
fields.  University policies, organization, 
administration, faculties, students, researches, curricula,
equipment, and financing were investigated. 
 An integrated university program is recommended reflecting
the conviction that many present activities 
related to computers will develop into disciplines and
as such are the legitimate province of the university 
scholar.  Details on a recommended Graduate
School of "Computer Sciences" are given.
.I 69
.T
Statistical Programs for the IBM 650-Part I
.W
A collection is given of brief descriptions
of statistical programs now in use in university 
computing centers which have IBM 650's.
.I 70
.T
Construction of a Set of Test Matrices
.W
This paper develops the equations and properties
of a set of test matrices which are useful 
in the determination of the accuracy of routines for
finding the inverse, determinant and/or eigenvalues 
of a matrix.
.I 71
.T
Proposal for a Feasible Programming System
.W
This paper proposes designing a programming
facility (itself involving a digital computer and 
a program) which will assist the preparation of large-scale
real-time programs.  This facility is to 
be capable of preparing programs for any of a variety
of machines having characteristics similar to those 
of the facility's computer.  One of the basic assumptions
is that there will be enough random-access 
storage available to avoid the necessity for segmenting
a constructed program in any fashion other than 
a trivial one.  While this assumption is somewhat unrealistic,
it is intended to provide an opportunity 
to concentrate on the other aspects of program construction.
 The programming system should stress the 
discovery in source program statements of as many errors
as possible, before attempting to construct 
an object program.  Among the computer characteristics
which are advocated are a program interrupt scheme, 
a large set of characters, and indirect addressing.
.I 72
.T
An Educational Program in Computing 
.I 73
.T
A Real Time Data Assimilator
.I 74
.T
A High-Speed Sorting Procedure
.I 75
.T
Parameter Estimation for Simple Nonlinear Models
.I 76
.T
Binary Conversion, With Fixed Decimal Precision, Of a Decimal Fraction
.I 77
.T
On GAT and the Construction of Translators
.I 78
.T
Remarks on the Practical Solution of Characteristic Value Problems
.W
This paper is concerned with the practical
solution of characteristic value problem for an 
ordinary differential equation.  It is at once apparent
that sequential computers, be they digital or 
analog, solve initial value problems, rather than boundary
value problems, and some mathematical process 
must be found to compensate for the machine's inadequacy.
 (Compensating for machine imperfection is, 
of course, the normal activity of the numerical analyst.)
 A number of other papers have applied particular 
devices to particular problems.  The purpose of this
note is to establish a mathematical framework or 
model for these practical procedures and thus assist in
the use and extension of the ideas in other particular 
problems.
.I 79
.T
Programming for a Machine With an Extended
Address Calculational Mechanism
.I 80
.T
A Technique for Computing Critical Rotational
Speeds of Flexible Shafts on an Automatic Computer
.I 81
.T
NORC High-Speed Printer
.I 82
.T
Handling Identifiers as Internal Symbols in Language Processors
.W
Substitution of computer-oriented symbols for
programmer-oriented symbols in language processors 
is examined and a feasible method for doing so is presented.
.I 83
.T
A Visit to Computation Centers in the Soviet Union
.I 84
.T
Survey of Progress and Trend of Development
and Use of Automatic Data Processing in Business
and Management Control Systems of the Federal Government,
as of December 1957-II (Part 2 see CA590406)
.I 85
.T
Error Analysis in Floating Point Arithmetic
.I 86
.T
Survey of Progress and Trend of Development
and Use of Automatic Data Processing in Business 
and Management Control Systems of the Federal Government, as of December 1957
.I 87
.T
A Note on a Method for Generating Points
Uniformly on N-Dimensional Spheres
.I 88
.T
An Efficient Method for Generating Uniformly Distributed
Points on the Surface of an n-Dimensional
Sphere
.I 89
.T
A Routine to Find the Solution of Simultaneous
Linear Equations with Polynomial Coefficients
.I 90
.T
Binary Arithmetic for Discretely Variable
Word Length in a Serial Computer
.I 91
.T
A Mathematical Procedure for Machine Division
.I 92
.T
A Checklist of Intelligence for Programming Systems
.W
A remarkable variation exists in the degree
of sophistication of various programming systems. 
 A particular manifestation is the jungle of assorted
devices for reproducing limited human decision 
procedures.  An attempt is made here to begin a systematic
classification of the various devices for 
educating the computer to take over the decision-making
functions of one or many human operators, both 
those that have been demonstrated feasible to date and
those that are highly desirable for the future.
.I 93
.T
From Formulas to Computer Oriented Language
.W
A technique is shown for enabling a computer
to translate simple algebraic formulas into a 
three address computer code.
.I 94
.T
An Iterative Method for Fitting the Logistic Curve
.W
An iterative method is given for finding a
logistic curve of best least squares fit to a set 
of two-dimensional points.
.I 95
.T
Elimination of Special Functions from Differential Equations
.W
A set of ordinary differential equations which
contains mathematical functions requiring the 
use of subroutines for numerical solution by electronic
computer, tabular data for numerical solution 
by hand calculation or function generators when analog
methods are applied can sometimes be expanded 
to an equivalent set of equations which do not contain
the functions.  This is practical if these functions 
satisfy sufficiently simple differential equations. 
Thus among those functions which can be eliminated 
by this procedure are the trigonometric, inverse trigonometric,
exponential, and many other transcendental 
functions.
.I 96
.T
On Computing Radiation Integrals
.W
The relative merit and cost of four ways of
evaluating typical radiation integrals containing 
spherical Bessel functions are investigated.  These methods
are desk machine evaluation of a finite series, 
integration of the appropriate differential equation
by a Reeves Electronic Analog Computer and by a 
Litton 40 IBM 704 computer.  Results are generally applicable
to equations separated from a Helmholtz 
or wave equation.
.I 97
.T
Signal Corps Research and Development on
Automatic Programming of Digital Computers
.I 98
.T
The Arithmetic Translator-Compiler of
the IBM FORTRAN Automatic Coding System
.I 99
.T
Possible Modifications to the International Algebraic Language
.I 100
.T
Recursive Subscripting Compilers and List-Types Memories
.I 101
.T
Nuclear Reactor Codes
.I 102
.T
A Comparison of 650 Programming Methods
.I 103
.T
COPE (Console Operator Proficiency Examination)*
.W
Each year electronic computers become more
sophisticated, and the programs they must process 
become more complex.  Because of this,dependence of
those in computing on the skill and experience of 
operators is increasing.  At the same time, selection
and training of qualified operators grows more 
difficult.  To meet the need for a quick, accurate, uniform
operator test and training aid, the authors 
have developed COPE (Console Operator Proficiency Examination),
outlined below.  While this examination 
is programmed specifically for the IBM 705 Model II with
two Tape Record Coordinators, similar programs 
could be developed for other computers.
.I 104
.T
Digital Simulation of Discrete Flow Systems*
.W
The discrete flow systems discussed are characterized
by the movement of randomly arriving 
items along interacting channels.  Programing a digital
computer to simulate such systems utilizes some 
techniques not common in other approaches to physical
problems.  The principal portion of the paper is 
a discussion of two simulation studies that illustrate
some of the programming problems involved. One 
is of an extensive package-handling plant, with the
objective being optimization of parameters such as 
storage capacities and processing rates.  In the other,
air traffic flow and control procedures are simulated 
to compare the effects of alternative control decisions.
.I 105
.T
Two Methods for Word Inversion on the IBM 709
.I 106
.T
A Method for Overlapping and Erasure of Lists
.W
An important property of the Newell-Shaw-Simon
scheme for computer storage of lists is that 
data having multiple occurrences need not be stored
at more than one place in the computer.  That is, 
lists may be "overlapped."  Unfortunately, overlapping
poses a problem for subsequent erasure.  Given 
a list that is no longer needed, it is desired to erase
just those parts that do not overlap other lists. 
 In LISP, McCarthy employs an elegant but inefficient solution
to the problem.  The present paper describes 
a general method which enables efficient erasure.  The
method employs interspersed reference counts to 
describe the extent of the overlapping.
.I 107
.T
Multiple Precision Arithmetic
.I 108
.T
Programmed Error Correction in Project Mercury
.I 109
.T
A Note on Approximating e^x
.I 110
.T
Fibonaccian Searching
.I 111
.T
On Programming the Numerical Solution of Polynomial Equations
.W
Numerical techniques are presented for computing
the roots of polynomial equations.  By applying 
the recommended scaling and inversion rules, the basic
Bairstow and Newton-Raphson iterative techniques 
can be applied with great reliability.  Both a high degree
of accuracy and rapid convergence are realized. 
 Numerical examples are shown to illustrate the pitfalls
and to show how these are circumvented by application 
of the recommended procedures.
.I 112
.T
Numerical Solution of the Polynomial Equation (Algorithm 30)
.I 113
.T
Survey of Coded Character Representation
.I 114
.T
Survey of Punched Card Codes
.I 115
.T
Optimizers: Their Structure
.I 116
.T
The Sumador Chino
.W
On a recent motor trip through Mexico, the writer
came across on adding device which was referred 
to as a sumador chino (Chinese adder).  A survey of the more
available literature on the history of mathematics 
and on instruments of calculation has uncovered no reference
to such a device.  The purpose of this communication 
is to enlist the help of other members in bringing to
light whatever may be known concerning the evolution 
and present status of the sumador chino.
.I 117
.T
An Estimation of the Relative Efficiency of Two Internal Sorting Methods
.I 118
.T
Character Scanning on the IBM 7070
.I 119
.T
Note on Eigenvalue Computation
.I 120
.T
A Simple Technique for Coding Differential Equations
.I 121
.T
Over-all Computation Control and Labelling
.I 122
.T
Least Squares Fitting of a Great Circle Through Points on a Sphere
.I 123
.T
Compilation for Two Computers with NELIAC
.W
NELIAC, a compiler based on ALGOL, was developed
at the U.S. Navy Electronics Laboratory, San 
Diego,California, as a"boot-strap" compiler for the Remington
Rand Univac COUNTESS computer. This compiler 
was used to generate a version of itself which, running
as a COUNTESS program, generated machine code 
for the Control Data Corporation CDC-1604.  All three
versions of NELIAC accepted essentially identical 
input language.
.I 124
.T
An Algorithm for the Assignment Problem
.W
The assignment problem is formulated and briefly
discussed.  An efficient algorithm for its 
solution is presented in ALGOL code.  An empirical relation
between solution time and the size of the 
problem is given, based on extensive experiments
carried out on a digital computer.
.I 125
.T
Polynomial Transformer (Algorithm 29)
.I 126
.T
Least Squares Fit By Orthogonal polynomials (Algorithm 28)
.I 127
.T
ASSIGNMENT (Algorithm 27)
.I 128
.T
ROOTFINDER III (Algorithm 26)
.I 129
.T
ROOTFINDER II (Algorithm 15)
.I 130
.T
Real Zeros of an Arbitrary Function (Algorithm 25)
.I 131
.T
Solution of Tri-Diagonal Linear Equations (Algorithm 24)
.I 132
.T
Math Sort (Algorithm 23)
.I 133
.T
Riccati-Bessel Functions of First And Second Kind (Algorithm 22)
.I 134
.T
Bessel Function for a Set of Integer Orders(Algorithm 21)
.I 135
.T
Digital Computers in Universities-IV
.I 136
.T
A Note on the Calculation of Interest
.I 137
.T
Evaluating Numbers Expressed as Strings of English Words
.I 138
.T
Some Thoughts on Reconciling Various
Character Set Proposals (Corrigenda)
.I 139
.T
Binomial Coefficients (Algorithm 19)
.I 140
.T
Crout with Pivoting (Algorithm 16)
.I 141
.T
Some Thoughts on Parallel Processing
.I 142
.T
Comments on a Technique for Counting Ones 
.I 143
.T
A List of Computer Systems Programs for
the IBM 650, DATATRON 205, and UNIVAC SS-80
.I 144
.T
Do It by the Numbers-Digital Shorthand
.W
Present communications systems transmit single
characters in groups of coded pulses between 
simple terminal equipments.  Since English words form only
a sparse set of all possible alphabetic combinations, 
present methods are inefficient when computer systems
are substituted for these terminals.  Using numeric 
representations of entire words or common phrases (rather
than character-by-character representations) 
requires approximately one-third of present transmission
time.  This saving is reflected in overall costs. 
 Other benefits accrue in code and language translation
schemes. Provision is made for transmission of 
purely numeric and/or binary streams, and for single
character-transmission of non-dictionary words such 
as the names of people or places.
.I 145
.T
Automatic Graders for Programming Classes
.I 146
.T
The Use of Computers in Engineering Classroom Instruction 
.W
On April 29-30, the Computer Committee of the
College of Engineering, University of Michigan, 
which acts as a steering committee for The Ford Foundation
Project on the Use of Computers in Engineering 
Education, held a special conference to discuss certain
timely topics pertinent to the Ford Project. 
 This report contains a condensed transcription of
the key ideas offered by the conference attendees 
on selected topics. 
.I 147
.T
Report on a Conference of University Computing Center Directors
.I 148
.T
Digital Computers in Universities-III
.I 149
.T
A Decision Rule for Improved Efficiency in Solving
Linear Programming Problems with the Simplex 
Algorithm
.I 150
.T
Rational Interpolation by Continued Fractions (Algorithm 18)
.I 151
.T
TRDIAG (Algorithm 17)
.I 152
.T
CROUT With Pivoting (Algorithm 16)
.I 153
.T
Comments from a FORTRAN User
.I 154
.T
Rapidly Convergent Expressions for Evaluating e^x
.I 155
.T
Trie Memory
.I 156
.T
An Introductory Problem in Symbol Manipulation for the Student
.I 157
.T
Digital Computers in Universities -II
.I 158
.T
ROOTFINDER II (Algorithm 15)
.I 159
.T
ROOTFINDER (Algorithm 2)
.I 160
.T
ROOTFINDER II (Algorithm 15)
.I 161
.T
Abbreviating Words Systematically (Corrigendum)
.I 162
.T
A Variant Technique for Counting Ones
.I 163
.T
Counting Ones on the IBM 7090 
.I 164
.T
A Short Study of Notation Efficiency
.I 165
.T
NELIAC-A Dialect of ALGOL
.I 166
.T
Programming Compatibility in a Family
of Closely Related Digital Computers
.I 167
.T
Combining ALGOL Statement Analysis with Validity Checking
.I 168
.T
Multiprogram Scheduling Parts 3 and 4 Scheduling
Algorithm and External Constraints
.I 169
.T
The Multilingual Terminology Project
.I 170
.T
Some Thoughts on Reconciling Various Character Set Proposals
.I 171
.T
Digital Computers in Universities (Part I) 
.I 172
.T
Complex Exponential Integral (Algorithm 13)
.I 173
.T
ATLAS a new concept in large computer design
.I 174
.T
Interval Estimation of the Time in One State
to Total Time Ratio in a DoubleExponential Process
.I 175
.T
The Solution of Simultaneous Ordinary Differential
Equations Using a General Purpose Digital 
Computer
.I 176
.T
Symbol Manipulation by Threaded Lists (Corrigendum)
.I 177
.T
Solution of Polynomial Equation by Bairstow
Hitchcock Method, A. A. Grau Communications ACM, 
February, 1960 (Algorithm)
.I 178
.T
ROOTFINDER (Algorithm)
.I 179
.T
Evaluation of the Legendre Polynomial Pn(X) by Recursion (Algorithm)
.I 180
.T
Evaluation of the Laguerre Polynomial Ln(X) by Recursion (Algorithm)
.I 181
.T
Evaluation of the Hermite Polynomial Hn(X) by Recursion (Algorithm)
.I 182
.T
Evaluation of the Chebyshev Polynomial Tn(X) by Recursion (Algorithm) 
.I 183
.T
Conversion Between Floating Point Representations
.I 184
.T
A Short Method for Measuring Error in a Least-Squares Power Series
.I 185
.T
Multiprogram Scheduling Parts 1 and 2.  Introduction and Theory*
.W
In order to exploit fully a fast computer which
possesses simultaneous processing abilities, 
it should to a large extent schedule its own workload.
 The scheduling routine must be capable of extremely 
rapid execution if it is not to prove self-defeating.
 The construction of a schedule entails determining 
which programs are to be run concurrently and which sequentially
with respect to each other.  A concise 
scheduling algorithm is described which tends to minimize
the time for executing the entire pending workload 
(or any subset of it), subject to external constraints
such as precedence, urgency, etc.  The algorithm 
is applicable to a wide class of machines.
.I 186
.T
An Algorithm Defining ALGOL Assignment Statements (Addendum)
.I 187
.T
Compiling Connectives
.I 188
.T
The Department of Computer Mathematics at Moscow State University
.I 189
.T
The Future of Automatic Digital Computers
.I 190
.T
Bendix G-20 System
.I 191
.T
Abbreviating Words Systematically
.I 192
.T
A Technique for Counting Ones in a Binary Computer
.I 193
.T
A Start at Automatic Storage Assignment
.I 194
.T
Divisionless Computation of Square Roots Through Continued Squaring
.I 195
.T
What is a Code?
.I 196
.T
Report on the Algorithmic Language ALGOL 60
.I 197
.T
An Imaginary Number System
.I 198
.T
A High-Speed Multiplication Process for Digital Computers
.I 199
.T
Euclidian Algorithm (Algorithm 7)
.I 200
.T
Bessel Function I, Asymptotic Expansion (Algorithm 6)
.I 201
.T
Bessel Funtion I, Series Expansion (Algorithm 5)
.I 202
.T
A Control System For Logical Block Diagnosis With Data Loading
.W
This paper describes a section of an integrated
diagnostic monitor system which facilitates 
the checking of sections of instructions or subroutines
anywhere in the object program.  A new method 
of specifying all diagnostic operations in a format similar
to a computer program makes the system convenient 
to use and relatively simple to understand.  The paper
also describes a number of other novel diagnostic 
features which can be included in the system.
.I 203
.T
Decoding Combinations of the First n Integers Taken k at a Time
.I 204
.T
Proving Theorems by Pattern Recognition I
.I 205
.T
Macro Instruction Extensions of Compiler Languages
.W
Macroinstruction compilers constructed from
a small set of functions can be made extremely 
powerful.  In particular, conditional assembly, nested
definitions, and parenthetical notation serve 
to make a compiler capable of accepting very
general extensions to its ground language.
.I 206
.T
Symbol Manipulation in XTRAN
.I 207
.T
Syntactic and Semantic Augments to ALGOL
.I 208
.T
An Introduction to Information Processing Language V
.I 209
.T
Symbol Manipulation by Threaded Lists
.I 210
.T
Recursive Functions of Symbolic Expressions
and Their Computation by Machine, Part I
.I 211
.T
Share Standard Flow Chart Symbols
.I 212
.T
Bisection Routine (Algorithm 4)
.I 213
.T
Numerical Inversion of Laplace Transforms
.I 214
.T
An Algorithm Defining ALGOL Assignment Statements
.I 215
.T
The Execute Operations-A Fourth Mode of Instruction Sequencing
.I 216
.T
A Note on the Use of the Abacus in Number Conversion
.I 217
.T
Soviet Computer Technology-1959
.I 218
.T
Computer Preparation of a Poetry Concordance
.I 219
.T
Marriage-with Problems
.I 220
.T
A New Method of Computation of Square Roots Without Using Division
.I 221
.T
The Basic Side of Tape Labeling
.I 222
.T
Coding Isomorphisms
.W
The coding of external symbols into symbols
internal to a compute can sometimes be carried 
out in such a way that relevant informational properties
are preserved, but in a form much more easily 
dealt with.  A case in point is presented.
.I 223
.T
Selfcipher: Programming
.I 224
.T
Sequential Formula Translation
.W
The syntax of an algorithmic language such
as ALGOL is conveniently described as a sequence 
of states indicated by an element called cellar.  Transitions
are controlled by admissible state-symbol 
pairs which may be represented by a transition matrix.
This description of syntax furnishes at the same 
time an extremely simple rule for translating into machine
programs statements in the algorithmic language. 
 Sequential treatment, however, is not feasible in the case
of certain optimizing processes such as recursive 
address calculation.
.I 225
.T
A Techniquefor Handling Macro Instructions (Corrigendum)
.I 226
.T
Solution of Polynomial Equation by
Bairstow-Hitchcock Method (Algorithm 3)
.I 227
.T
ROOTFINDER (Algorithm 2)
.I 228
.T
QUADI (Algorithm 1)
.I 229
.T
A Terminology Proposal
.I 230
.T
A Proposal for Character Code Compatibility
.I 231
.T
A Proposal for a Set of Publication Standards for Use by the ACM
.I 232
.T
A High-Speed Sorting Procedure
.I 233
.T
Abstracts-Additional Nuclear Reactor Codes
.I 234
.T
A SAP-Like Assembly Program for the IBM 650
.I 235
.T
Two Think Pieces
.I 236
.T
Soviet Cybernetics and Computer
.W
This article records observations on Soviet
research and technology in cybernetics and computer 
science, made by the author during a visit to the Soviet
Union as a delegate to the IFAC Congress on 
Automatic Control held in Moscow in the summer of 1960.
.I 237
.T
Computer Production of Peek-A-Boo Sheets
.I 238
.T
Simulation and Analysis of Biochemical Systems
.I 239
.T
Inefficiency of the Use of Boolean Functions
for Information Retrieval Systems
.I 240
.T
Processing Magnetic Tape Files with Variable Blocks
.I 241
.T
Machine Calculation of Moments of a Probability Distribution
.W
A method is presented for the calculation on a
machine of the moments of a probability distribution, 
necessitating little more than n additions and n references
to memory for each moment, instead of the 
minimum of n multiplication, 2n additions, and 2n references
to memory required by the most straightforward 
method (where n is the number of entries in the probability
distribution).  The method is directly applicable 
when a tabulated distribution exists, as when it has
been computed by repeated convolution; but in this 
case it conserves both time and accuracy.
.I 242
.T
Notes on Geometric Weighted Check Digit Verification
.W
This note describes a method for utilizing
geometric weight modulus 11 checking digits on a 
computer which does not have either multiplication or
division.  In addition some attempt has been made 
to show some limitations of this system.
.I 243
.T
N-Dimensional Codes for Detecting and Correcting Multiple Errors
.W
The paper introduces a new family of codes
for detecting and correcting multiple errors in 
a binary-coded message.  The message itself is arranged
(conceptually) into a multidimensional rectangular 
array.  The processes of encoding and error detection
are based upon parity evaluations along prescribed 
dimensions of the array.  Effectiveness of the codes
is increased by introducing a "system check bit", 
which is essentially a parity check on the other parity
bits.  Only three-dimensional codes are discussed 
in this paper with parity evaluations along the horizontal,
the vertical, and one main diagonal.  However, 
the family of codes is not restricted to three dimensions,
as evidenced by the discussion by Minnick 
and Ashenhurst on a similar multidimensional single-bit
selection plan used for another purpose [6]. 
 A four-dimensional code, correcting three and detecting
four errors, has been developed; the extension 
to higher-dimensional codes with greater correction power is straightforward.
.I 244
.T
Incomplete Elliptic Integrals (Algorithm 73)
.I 245
.T
A Set of Associate Legendre Polynomials of the Second Kind (Algorithm 62)
.I 246
.T
Least-Squares Fit by Orthogonal Polynomials (Algorithm 28)
.I 247
.T
Incomplete Elliptic Integrals (Algorithm 73)
.I 248
.T
What is Proprietary In Mathematical Programming?-Impressions
of a Panel Discussion
.W
A panel discussion on "What is Proprietary
in Mathematical Programming?" was sponsored by the 
Special Interest Committee on Mathematical Programming
of the ACM during a Hall of Discussion/on September 
7th at the 16th National ACM meeting in Los Angeles.  This
note consists solely of the impressions garnered 
by the moderator of the panel and does not necessarily
represent the position of any of the panelists 
or other participants in the discussion.
.I 249
.T
Specification Languages for Mechanical Languages
and Their Processors*-A Baker's Dozen
.I 250
.T
An Engineering Application of Logic-Structure Tables
.I 251
.T
Ballistic Cam Design 
.W
This paper presents a digital computer program
for the rapid calculation of manufacturing data 
essential to the design of preproduction cams which
are utilized in ballistic computers of tank fire 
control systems.  The cam profile generated introduces
the superelevation angle required by tank main 
armament for a particular type ammunition.
.I 252
.T
Programming a Duplex Computer System
.W
This paper describes a method of duplex-computer
programming that has been used with two computers 
in a military defense system.  The method combines special
programs with a basic data processing program 
package.  The duplex operation gives the system greater
reliability.  After achieving the required level 
of integration, both computers do similar processing
on the same inputs and continually cross-check the 
intermediate and final results.
.I 253
.T
On a Program for Ray-Chaudhuri's Algorithm
for a Minimum Cover of an Abstract Complex
.I 254
.T
SMALGOL-61
.W
Prior to and during the 1961 Western Joint
Computer Conference, several people in the Joint 
Users Groups had expressed interest in defining a "smalgol"
language.  This is to be an ALGOL language 
for use with compilers on relatively small size computers.
 A preliminary report resulted.  At the ACM 
National Conference four months later, after considering
several counter proposals, a final version was 
agreed upon by a subcommittee.  The recommendations
of the Subcommittee for a standard subset of ALGOL 
60 for use on small computers is presented here.
.I 255
.T
Augmentation (Algorithm 68)
.I 256
.T
A Set of Test Matrices (Algorithm 52)
.I 257
.T
Invert (Algorithm 42)
.I 258
.T
Composition Generator (Algorithm 72)
.I 259
.T
Permutation (Algorithm 71)
.I 260
.T
Interpolation By Aitken (Algorithm 70)
.I 261
.T
Tape Splitting
.I 262
.T
MAP
.I 263
.T
Library Loading with Alternate Routine Selection
.I 264
.T
A Generalized Polyphase Merge Algorithm 
.I 265
.T
Low Level Language Subroutines for Use Within Fortran
.W
This paper describes some subroutines, coded
in symbolic languages and for use within Fortran 
coded programs, to deal with "special arithmetic" (e.g.
multi-precision arithmetic), symbol manipulation, 
bit manipulation and expanded character set input-output, and visual display.
.I 266
.T
Fitting Spheres by the Method of Least Squares
.I 267
.T
Some Proposals for Improving the Efficiency of ALGOL 60
.I 268
.T
Stochastic Evaluation of a Static Storage Allocation
.I 269
.T
Core Allocation Based on Probability
.I 270
.T
Techniques for Storage Allocation Algorithms 
.I 271
.T
A Semi-Automatic Storage Allocation System at Loading Time
.I 272
.T
A Storage Allocation Scheme for ALGOL 60
.W
A storage allocation scheme for a machine
with a 2048 instruction core store and a magnetic 
drum is described.  The use of the drum for storing
program blocks and/or data must be directed by the 
programmer through auxiliary information in the ALGOL
program.  The administrative routines controlling 
the storage at run time are described in full.  A detailed example is given.
.I 273
.T
Experience in Automatic Storage Allocation 
.I 274
.T
Dynamic Storage Allocation in the Atlas Computer,
Including an Automatic Use of a Backing Store
.I 275
.T
Dynamic Storage Allocation for an Information Retrieval System
.I 276
.T
Program Organization and Record Keeping for Dynamic Storage Allocation
.W
The material presented in this paper is part
of the design plan of the core allocation portion 
of the ASCII-MATIC Programming System.  Project ASCII-MATIC
is concerned with the application of computer 
techniques to the activities of certain headquarters
military intelligence operations of the U.S. Army.
.I 277
.T
Problems of Storage Allocation in
a Multiprocessor Multiprogrammed System
.I 278
.T
A General Formulation of storage Allocation
.W
Formalization of a general computer storage
allocation process is attempted.  With a given 
computer M is associated a fictitious computer M' essentially
identical to M except in respect to possession 
of unbounded primary storage.  Mappings of the total
storage set (internal and external) of M into the 
direct address set of M' are introduced.  A program
sequence P for M' is termed M-admissible (relative 
to a specific execution time period) if there is a mapping
underwhich P and its effective data referents 
are all located in the direct address set of M.  Storage
allocation is considered as a process of establishing 
for an arbitrary M' program  a sequence of mappings, a decoupling
of the program into M-admissible subprograms 
and a linking set of interludes.  An existence proof
in terms of a completely interpretive M program 
as indicated.  Some special cases are discussed.  Various
restrictions on generality of M' programs are 
considered under which more practical realization
of allocation processes becomes tractable.
.I 279
.T
The Case for Dynamic storage Allocation 
.I 280
.T
A Preplanned Approach to a Storage Allocating Compiler
.I 281
.T
Putting a Hex on e^x
.W
Recent notes on approximate natural antilogy
have not considered indirect formulations for 
describing e^x.  In this note we produce a particular
family of very fast, high precision and eminently 
practical exponential evaluation formulas derived from one such formulation.
.I 282
.T
Optimum Tape-Writing Procedures
.W
Consider a magnetic tape system with a read
check after writing.  Where an error occurs in 
writing a record, a programmed error routine may either
bypass some or all of the area on tape or try 
to rewrite the record on the same area.  This paper evaluates
these two procedures on the basis of expected 
loss of computer time and develops a decision rule for
selecting the optimum procedure.  The rule depends 
critically on the number of times the tape being written
will be used in the future.  In the case where 
the optimum procedure is to bypass an area, a second
decision-the size of the area to be bypassed-is 
necessary.  A formula is developed to determine the
optimum area to be bypassed for each procedure.
.I 283
.T
Inversion of a Complex Matrix
.I 284
.T
Manipulation of Algebraic Expressions
.W
An algorithm for algebraically manipulating
expressions of the form SUM{CiPi, i=1,...,n}; has 
been developed in conjunction with the development of programs
for systems analysis problems.  This algorithm 
enablesus to derive over-all system transfer functions
from algebraically described block diagrams of 
any linear continuous multi-loop feedback system.  The
machine representation of the derived expression, 
is, by virtue of the algorithm, in a form which simplifies
the task of compiling.  The algorithm was 
developed for a particular purpose in connection with
system analysis studies.  However, its application 
as a mathematical device extends far beyond
the confines of the original problem.
.I 285
.T
Solution of Tridiagonal Matrices
.I 286
.T
An Iterative Method for Inversion of Power Series
.I 287
.T
The Generalized Important Event Technique
.I 288
.T
A Syntactical Chart of ALGOL 60
.I 289
.T
Critical Path Scheduling (Algorithm 40)
.I 290
.T
Chain Tracing (Algorithm 69)
.I 291
.T
Use of MOBOL in PreparingRetrieval Programs
.I 292
.T
An Information Retrieval Language for Legal Studies
.I 293
.T
The Applied Mathematics Laboratory of the David W. Taylor Model Basin
.I 294
.T
An Imaginary Number System
.I 295
.T
Rational Approximations for the Error Function and for Similar Functions
.I 296
.T
A Note on Multiple Precision Arithmetic
.I 297
.T
A Note on Fitting Great Circles by Least Squares
.I 298
.T
A 48-Bit Pseudo-Random Number Generator
.W
A new 48-bit pseudo-random number generator, suitable
for several computers, was tested statistically 
for randomness to determine its adequacy for use in Monte
Carlo programs.  Frequency tests, distributions 
of certain low-order moments, runs up and down, and runs
above and below the mean were applied to one-half 
million generated numbers lying within the interval
(0,1) and to three sets of integers obtained from 
specified bits within the generated numbers.  These
tests substantiated the randomness of all numbers 
except for the set of integers coming from the least significant bits.
.I 299
.T
A Generalized Polyphase Merge Algorithm
.I 300
.T
COBOL: A Sample Problem
.W
A simplified Merchandise Control problem has
been chosen for presenting COBOL to users and 
potential users of computing systems.  A mythical department
store, "E. Language Bros., Inc.", is programming 
in the COBOL language one of the many runs on its computer.
.I 301
.T
A Set of Test Matrices (Algorithm 52)
.I 302
.T
Augmentation (Algorithm 68)
.I 303
.T
Some Basic Terminology Connected With
Mechanical Languages and Their Processors
.W
The suggestions in this paper are part of the
terminology used in work for the University of 
Pennsylvania's Office of computer Research and Education.
 The work is jointly supported by the National 
Science Foundation and the Air Force Office of Scientific Research.
.I 304
.T
Nth Roots of a Complex Number (Algorithm 53)
.I 305
.T
CRAM (Algorithm 67)
.I 306
.T
INVRS (Algorithm 66)
.I 307
.T
FIND (Algorithm 65)
.I 308
.T
QUICKSORT (Algorithm 64)
.I 309
.T
PARTITION (Algorithm 63)
.I 310
.T
A Set of Associate Legendre Polynomials
of the Second Kind (Algorithm 62)
.I 311
.T
Procedures for Range Arithmetic (Algorithm 61)
.I 312
.T
A Further Note on Approximating e^x
.I 313
.T
An Iterative Method for Inversion of Power Series
.I 314
.T
A Divisionless Method of Integer Conversion
.I 315
.T
Solution of Tridiagonal Matrices
.I 316
.T
An Algorithm for Equivalence Declarations
.I 317
.T
On The Approximation of Curves by Line Segments Using Dynamic Programming
.I 318
.T
Combat Vehicle Firing Stability (Active Suspension)
.I 319
.T
On a Class of Iteration Formulas and Some Historical Notes
.W
The class of iteration formulas obtainable
by rational approximations of "Euler's formula" 
is derived with the corresponding error estimates. 
Some historical notes on iterative procedures are 
followed by a derivation of Euler's formula with the
associated error estimate in a new notation which 
simplifies the error estimate and suggests generalizations.
 The final section considers the Pade approximants 
to the "Euler polynomial" and shows how a number of known
formulas may be derived from this unified approach. 
 There is a short discussion of the "best" formula.
.I 320
.T
Logic-Structure Tables
.W
Logic tables are an excellent way of developing
and expressing the logic required in procedures, 
operations, systems and circuits.  A set of rules for
writing and using logic tables is explained by 
means of some simple examples.  Then the logic structure
of a vending machine is given in which two logic 
tables are used.  Logic tables are two-dimensional in
nature, enabling us to fully express and consider 
both the sequential and parallel aspects of logic.  They
can be compiled directly into a computer program 
and so eliminate the need for flow charting and hand coding.
.I 321
.T
ALGOL 60 Confidential
.W
The ALGOL 60 Report,* when first encountered,
seems to describe a very complex language which 
will be difficult to learn.  The "metalinguistic formulae"
admirably serve the purpose of precisely specifying 
a language, but they are certainly not very readable
for a beginner.  However, experience has shown that 
once the report is explained it is in fact easy to learn
ALGOL and to write algorithms in it.  The language 
is so general and powerful it can handle an enormous
class of problems.  It is not hard to learn those 
parts of ALGOL present in other compiler languages: how
to write assignment and go to and for statements, 
etc.  Indeed, a lot of the unnecessary restrictions
imposed by other compiling languages have finally 
been lifted.  But ALGOL also allows many unobvious things
to be written, as we will see later, and herein 
lies a problem: ALGOL seems to have become too general.
 So many restrictions have been lifted that a 
lot of technical details crop up which are hard to learn
and to use correctly.  In this paper some of 
the more obscure features of the language are considered
and their usefulness is discussed.  Remarks 
are based on the authors' interpretations of the ALGOL 60 Report.
.I 322
.T
Operational Compatibility of Systems-CONVENTIONS
.W
The General Standards Committee of the SHARE
organization has devoted considerable effort to 
the problem of operating a computer efficiently in
view of the growing number of programming systems 
available.  Each of these programming systems has been
coded to utilize a fixed set of hardware components 
without recognizing the fact that others may be occupying
a storage medium required by the first.  These 
incompatibilities are currently resolved by manually setting
up the computer for each system as required. 
 The following set of conventions is being considered
to minimize computer set-up time.  They are of 
sufficiently broad interest that we feel other computer
users should be aware of them. -George F. Ryckman, 
Chairman
.I 323
.T
The State of Digital Computer Technology in Europe
.I 324
.T
Romberg Integration (Algorithm 60)
.I 325
.T
Numerical Solution of the Polynomial Equation (Algorithm 30)
.I 326
.T
MATHSORT (Algorithm 23)
.I 327
.T
Zeros of a Real Polynomial by Resultant Procedure (Algorithm 59)
.I 328
.T
Matrix Inversion (ALgorithm 58)
.I 329
.T
Automatic Abstracting and Indexing Survey and Recommendations
.W
In preparation for the widespread use of automatic
scanners which will read documents and transmit 
their contents to other machines for analysis, this report
presents a new concept in automatic analysis: 
the relative-frequency approach to measuring  the significance
of words, word groups, and sentences. 
 The relative-frequency approach is discussed in detail,
as is its application to problems of automatic 
indexing and automatic abstracting.  Included in the
report is a summary of automatic analysis studies 
published as of the date of writing.  Conclusions are
that point toward more sophisticated mathematical 
and linguistic techniques for the solution of problems of automatic analysis.
.I 330
.T
A Method for Evaluating the Area of the Normal Function
.I 331
.T
Successive Approximations and Computer Storage
Problems in Ordinary Differential Equations
.I 332
.T
An Indirect Chaining Method for Addressing on Secondary Keys
.W
Methods for entering random access files on
the basis of one key are briefly surveyed.  The 
widely used chaining method, based on a pseudo-random
key transformation, is reviewed in more detail. 
 An efficient generalization of the chaining method
which permits recovery on additional keys is then 
presented.
.I 333
.T
Design of an Improved* Transmission/Data Processing Code
.I 334
.T
Division and Square Root in the Quater-Imaginary Number System
.I 335
.T
Some Numerical Experiments Using Newton's Method
for Nonlinear Parabolic and EllipticBoundary-Value 
Problems
.W
Using a generalization of Newton's method, a nonlinear
parabolic equation of the form U(t)-U(xx)=g(U) 
and a nonlinear elliptic equation U(xx)+U(yy)=exp(U)
are solved numerically Comparison of these results 
with results obtained using the Picard iteration procedure
show that in many cases the quisi linearization 
method offers substantial advantages in both time and accuracy.
.I 336
.T
A Practical Technique for the Determination of
the Optimum Relaxation Factor of the Successive 
Over-Relaxation Method
.I 337
.T
Further Survey of Punched Card Codes
.I 338
.T
GROUT II (Algorithm 43)
.I 339
.T
Real Exponential Integral (Algorithm 20)
.I 340
.T
Legendre Polynomial (Algorithm 13)
.I 341
.T
Chebyschev Polynomial (Algorithm 10)
.I 342
.T
Solution of Polynomial Equation by Barstow-Hitchcock (Algorithm 3)
.I 343
.T
On Frequently Occurring Errors in ALGOL 60 Programs (Algorithm 25)
.I 344
.T
Ber or Bei Function (Algorithm 57)
.I 345
.T
Complete Elliptic Integral of the Second Kind (Algorithm 56)
.I 346
.T
Complete Elliptic Integral of the First Kind (Algorithm 55)
.I 347
.T
Gamma Function for Range 1 to 2 (Algorithm 54)
.I 348
.T
Nth Roots of a Complex Number (Algorithm 53)
.I 349
.T
A Set of Test Matrices
.I 350
.T
Adjust Inverse of a Matrix When an Element is Perturbed (Algorithm 51)
.I 351
.T
Inverse of a Finite Segment of the Hilbert Matrix (Algorithm 50)
.I 352
.T
Spherical Neumant Function (Algorithm 49)
.I 353
.T
Logarithm of A Complex Number (Algorithm 48)
.I 354
.T
Associated Legendre Functions of the First Kind
for Real or Imaginary Arguments (Algorithm 47)
.I 355
.T
Exponential of a Complex Number (Algorithm 46)
.I 356
.T
INTEREST (Algorithm 45)
.I 357
.T
Bessel Functions Computed Recursively (Algorithm 44)
.I 358
.T
Crout with Pivoting II (Algorithm 43)
.I 359
.T
INVERT (Algorithm 42)
.I 360
.T
Evaluation of Determinant (Algorithm 41)
.I 361
.T
Programmed Error Correction on a Decimal Computer
.I 362
.T
Table Look-At Techniques
.I 363
.T
On Approximating Transcendental Numbers by Continued Fractions
.I 364
.T
On the Compilation of Subscripted Variables 
.I 365
.T
Bessel Functions of Integral Order and Complex Argument
.I 366
.T
Eigenvalues of a Symmetric 3 x 3 Matrix
.I 367
.T
Topological Ordering of a List of
Randomly-Numbered Elements of a Network
.W
A network of directed line segments free of circular
elements is assumed.  The lines are identified 
by their terminal nodes and the nodes are assumed to
be numbered by a non-topological system.  Given 
a list of these lines in numeric order, a simple technique
can be used to create at high speed a list 
in topological order.
.I 368
.T
Real Zeros of an Arbitrary Function (Algorithm 25)
.I 369
.T
Crout with Pivoting (Algorithm 16)
.I 370
.T
Bisection Routine (Algorithm 4)
.I 371
.T
Remarks on Algorithms 2 and 3, Algorithm 15 and Algorithms 25 and 26
.I 372
.T
Critical Path Scheduling (Algorithm 40)
.I 373
.T
Correlation Coefficients with Matrix Multiplication (Algorithm 39)
.I 374
.T
Telescope2 (Algorithm 38)
.I 375
.T
Telescope1 (Algorithm 37)
.I 376
.T
Tchebycheff (Algorithm 36)
.I 377
.T
SIEVE (Algorithm 35)
.I 378
.T
A Generalized Technique for Symbol
Manipulation and Numerical Calculation 
.I 379
.T
Bitwise Operations
.I 380
.T
Comparison of Iterative Methods for the Calculation of nth Roots
.W
Three iterative methods for calculation of
nth roots (including one proposed by the author) 
are compared in two ways: (1) Theoretical convergence
estimates are given.  (2) A new macrocompiler which 
estimates machine running time is used to compare the
running time of the three methods for a variety 
of input data.
.I 381
.T
An Alternate Form of the "UNCOL Diagram"
.I 382
.T
Statistical Programs at the University of North Carolina
.I 383
.T
On Finding Minimum Routes in a Network With Turn Penalties
.I 384
.T
Gamma Function (Algorithm 34)
.I 385
.T
FACTORIAL (Algorithm 33)
.I 386
.T
MULTINT (Algorithm 32)
.I 387
.T
Gamma Function (Algorithm 31)
.I 388
.T
Solution of Polynomial Equations by
Bairstow Hitchcock Method (Algorithm 3)
.I 389
.T
Real Exponential Integral (Algorithm 20)
.I 390
.T
Complex Exponential Integral (Algorithm 13)
.I 391
.T
The BKS System for the Philco-2000 
.I 392
.T
Comment on A Paper on Parallel Processing
.I 393
.T
Two Subroutines for Symbol Manipulation with an Algebraic Compiler
.I 394
.T
Multiple Programming Data Processing
.I 395
.T
Multiple-Precision Division 
.I 396
.T
   Automation of Program  Debugging
.W
   Automatic Debugging can substantially reduce lead-time between the coding
and the effective use of a complex program. It also enforces analysis of
debugging criteria, resulting in verifiably accurate programs. The programmer
specifies the program to be debugged, memory areas, set of input data, maximum
repetition of loops, and checkpoint information for each set of data. The
executive debugging program the runs the program to be debugged, performing
checking functions and creating a trace record of its own later analysis and
location of errors. Applications are quite flexible, and the system can be used
alone or in conjunction with other debugging techniques.
.I 397
.T
A Card Format for Reference Files in Information Processing
.W
This paper proposes a card format suitable for
a variety of reference files in information 
processing.  An 80-column IBM card is divided into two
fields-reference material field (columns 1-67) 
and identification field (columns 68-80).  The format
for the reference material is flexible, while the 
format for the identification is rigid.  The reference
material includes basically an index, title, source, 
class, summary and cross reference for each entry. 
The identification includes basically codes for a 
matrix of descriptors, an entry number, and the kind,
major interest, and source of the reference.  The 
identification also provides a choice to identify material
for personal as well as general files.  Since 
this card format is sufficient to identify the material
normally associated with reference files for 
books, articles, programming terms, hardware terms, equipment,
machine systems, abbreviations, etc., it 
is suitable as a standard for card reference files in information processing.
.I 398
.T
The SLANG System
.I 399
.T
Compiling Techniques for Boolean Expressions
and Conditional Statements in ALGOL 60
.I 400
.T
Comments on the Implementation of Recursive
Procedures and Blocks in ALGOL 60
.I 401
.T
Allocation of Storage for Arrays in ALGOL 60
.I 402
.T
Dynamic Declarations
.I 403
.T
Thunks -- A Way of Compiling Procedure Statements
with Some Comments on Procedure Declarations
.I 404
.T
A Syntax Directed Compiler for ALGOL 60
.I 405
.T
An Algorithm for Coding Efficient Arithmetic Operations
.W
Most existing formula translation schemes
yield inefficient coding.  A method is described 
which reduces the number of store and fetch operations,
evaluates constant subexpressions during compilation, 
and recognizes many equivalent subexpressions.
.I 406
.T
The Use of Threaded Lists in Constructing a Combined
ALGOL and Machine-Like Assembly Processor
.I 407
.T
MADCAP: A Scientific Compiler for a Displayed Formula Textbook Language
.I 408
.T
The Internal Organization of the MAD Translator
.I 409
.T
CL-1, An Environment for a Compiler
.W
A flexible, large-scale programming system to
facilitate the solution of information processing 
problems and to provide intercommunication between programs
and/or programmers has been developed and 
realized on the IBM 709/7090 computer.  The system is
based on a master file concept and has provisions 
for accepting, storing, and retrieving both descriptions
and instances of large and complex data sets, 
as well as algorithms defined on these data sets.  Both
data and algorithms may be expressed in a family 
of command and descriptive languages.  The concept
of distinct data descriptions and the content and 
use of such descriptions are discussed in some detail.
.I 410
.T
The CLIP Translator
.I 411
.T
Use of Magnetic Tape for Data Storage in the ORACLE-ALGOL Translator
.I 412
.T
Recursive Processes and ALGOL Translation
.I 413
.T
A Basic Compiler for Arithmetic Expressions
.I 414
.T
IBM 1440 Data Processing System Features Five New Units
.W
The IBM 1440 data processing system, announced
recently by the International Business Machines 
Corporation, not only features the 1311 disk storage
drive with interchangeable disk packs but four other 
newly developed units.
.I 415
.T
The Use of Digital Computers in Western Germany
.I 416
.T
Multiple Shooting Method for Two-Point Boundary Value Problems
.I 417
.T
Legal Implications of Computer Use
.W
This paper points out a variety of ways computer
systems used in business and industry can 
be involved in legal entanglements and suggests that
computer specialists have a responsibility to call 
for assistance in forestalling or minimizing those entanglements
during the planning stage.  Techniques 
are suggested for making legal clearance effective with
the least burden on the new technology and for 
achieving a favorable legal climate for it generally.
 Computer specialists also are alerted to potential 
opportunities to interpret to lawyers the technical aspects
of computer systems involved in legal situations.
.I 418
.T
RANDOM (Algorithm 133)
.I 419
.T
Magic Square (Algorithm 118)
.I 420
.T
PERM (Algorithm 115)
.I 421
.T
Position of Point Relative to Polygon (Algorithm 112)
.I 422
.T
COMBINATION (Algorithm 94)
.I 423
.T
Matrix Inversion (Algorithm 58)
.I 424
.T
Gamma Function (Algorithm 31)
.I 425
.T
Complete Elliptic Integral (Algorithm 149)
.I 426
.T
Term of Magic Square (Algorithm 148)
.I 427
.T
PSIF (Algorithm 147)
.I 428
.T
Multiple Integration (Algorithm 146)
.I 429
.T
Adaptive Nimerical Integration by Simpson's Rule (Algorithm 145)
.I 430
.T
TREESORT2 (Algorithm 144)
.I 431
.T
TREESORT1 (Algorithm 143)
.I 432
.T
Triangular Regression (Algorithm 142)
.I 433
.T
Fixed-World-Length Arrays in Variable-Word-Length Computers
.I 434
.T
Character Manipulation in 1620 Fortran II
.I 435
.T
A Decision Matrix as the Basis for a Simple Data Input Routine
.W
Currently a great deal of time and effort is
being spent on the development of bigger and better 
compiler languages, multiprogram executive systems,
etc.  Since the implementation of  of new methods 
and procedures is not instantaneous, but rather occurs
by an evolutionary process, we should be concerned 
also with the problem of maintaining, improving and
incorporating new ideas into existing systems.  It 
is with this somewhat neglected area that the author is
interested.  A method employing a decision matrix 
is presented for the handling of a standard systems
programming problem,that of providing a data input 
routine.
.I 436
.T
Evaluation of Polynomials by Computer
.I 437
.T
Compiling Matrix Operations
.I 438
.T
Mechanical Pragmatics: A Time-Motion Study
of a Miniature Mechanical Linguistic System
.I 439
.T
On-Line Digital Computer for Measurement of a Neurological Control System
.I 440
.T
Record Linkage
.W
Special difficulties are encountered in devising
reliable systems for searching and updating 
any large files of documents that must be identified
primarily on the basis of names and other personal 
particulars.  The underlying problem is that of making nearly
maximum use of items of identifying information 
that are individually unreliable but that may collectively
be of considerable discriminating power.  
Rules that can be applied generally to name retrieval
systems have been developed in a methodological 
study of the linkage of vital and health records into
family groupings for demographic research purposes. 
 These rules are described, and the ways in which information
utilization for matching may be optimized 
are discussed.
.I 441
.T
Topological Sorting of Large Networks
.W
Topological Sorting is a procedure required
for many problems involving analysis of networks. 
 An example of one such problem is PERT.  The present
paper presents a very general method for obtaining 
topological order.  It permits treatment of larger networks
than can be handled on present procedures 
and achieves this with greater efficiency.  Although
the procedure can be adapted to any machine, it 
is discussed in terms of the 7090.  A PERT network of
30,000 activities can be ordered in less than one 
hour of machine time.  The method was developed as
a byproduct of procedures needed by Westinghouse, 
Baltimore.  It has not been programmed and at present
there are no plans to implement it.  In regard 
to the techniques described, Westinghouse's present
and anticipated needs are completely served by the 
Lockheed program, which is in current use.
.I 442
.T
Crout with Equilibration and Iteration (Algorithm 135)
.I 443
.T
Complex Number to a Real Power (Algorithm 106)
.I 444
.T
Evaluation of Jacobi Symbol (Algorithm 99)
.I 445
.T
COMBINATION (Algorithm 94)
.I 446
.T
Simpson's Integration (Algorithm 84)
.I 447
.T
Certification of the Calculation of Easter
.I 448
.T
Path Matrix (Algorithm 141)
.I 449
.T
Matrix Inversion(Algorithm 140)
.I 450
.T
Solution of the Diophantine Equation (Algorithm 139)
.I 451
.T
Nesting of for Statement II (Algorithm 138)
.I 452
.T
Nesting of for Statement I (Algorithm 137)
.I 453
.T
Enlargement of a Group (Algorithm 136)
.I 454
.T
Crout with Equilibration and Iteration (Algorithm 135)
.I 455
.T
Exponentiation of Series (Algorithm 134)
.I 456
.T
RANDOM (Algorithm 133)
.I 457
.T
Quantum Mechanical Integrals Over all Slater-Type Integrals
.I 458
.T
Coefficient Determination (Algorithm 131)
.I 459
.T
PERMUTE (Algorithm 130)
.I 460
.T
MINIFUN (Algorithm 129)
.I 461
.T
Coding of Medical Case History Data for Computer Analysis
.I 462
.T
Computer Pattern Recognition Techniques: Electrocardiographic Diagnosis
.W
The use of programmed digital computers as general
pattern classification and recognition devices 
is one phase of the current lively interest in artificial
intelligence.  It is important to choose a 
class of signals which is, at present, undergoing a
good deal of visual inspection by trained people 
for the purpose of pattern recognition.  In this way
comparisons between machine and human performance 
may be obtained.  A practical result also serves as additional
motivation.  Clinical electrocardiograms 
make up such a class of signals.  The approach to the
problem presented here centers upon the use of 
multiple adaptive matched filters that classify normalized
signals.  The present report fives some of 
the background for the application of this method.
.I 463
.T
On Ambiguity in Phrase Structure Languages
.I 464
.T
Syntactic Analysis by Digital Computer
.W
This paper provides an account of the Shadow
language that is used to describe syntax and of 
a corresponding subroutine that enables a computer
to perform syntactic analysis.  The input to this 
subroutine consists of a string to be analyzed and a
description of the syntax that is to be used.  The 
syntax is expressed in the Shadow language.  The output
consists of a trace table that expresses the 
results of the syntactic analysis in a tabular form.  Several
versions of the subroutine and some associated 
programs have been in use now for over three years.  The
present account of the language and the subroutine 
contains a summary of material that has been described
previously in unpublished reports and also some 
additional discussion of the work in relation to the more
general questions of problem-oriented languages 
and string transformations.
.I 465
.T
PERM (Algorithm 115)
.I 466
.T
General Order Arithmetic (Algorithm 93)
.I 467
.T
Permutation Generator (Algorithm 87)
.I 468
.T
Incomplete Elliptic Integrals (Algorithm 73)
.I 469
.T
Critical Path Scheduling (Algorithm 40)
.I 470
.T
Summation of Fourier Series (Algorithm 128)
.I 471
.T
ORTHO (Algorithm 127)
.I 472
.T
Gauss' Method (Algorithm 126)
.I 473
.T
WEIGHTCOEFF (Algorithm 125)
.I 474
.T
Input Data Organization in Fortran
.I 475
.T
A Test Matrix for Inversion Procedures
.I 476
.T
Further Remarks on Sampling a Tape File-II
.I 477
.T
Further Remarks on Sampling a Tape File-I
.I 478
.T
Implementing a Stack
.I 479
.T
A Dispersion Pass Algorithm for the Polyphase Merge
.W
This paper presents a new manner of dispersing
strings for a Polyphase merge.  If the number 
of strings dispersed is between two levels acceptable
by Polyphase merge, a more economical technique 
of reaching the next level for Polyphase merge is shown and proved.
.I 480
.T
Quick Calculation of Jacobian Elliptic Functions (Corrigendum)
.I 481
.T
A One-Day Look At Computing
.I 482
.T
TALL-A List Processor for the Philco 200 Computer
.I 483
.T
On the Nonexistence of a Phrase Structure Grammar for ALGOL 60
.W
ALGOL 60 is defined partly by formal mechanisms
of phrase structure grammar, partly by informally 
stated restrictions.  It is shown that no formal mechanisms
of the type used are sufficient to define 
ALGOL 60.
.I 484
.T
Hankel Function (Algorithm 124)
.I 485
.T
Real Error Function, ERF(x) (Algorithm 123)
.I 486
.T
Tridiagonal Matrix (Algorithm 122)
.I 487
.T
NORMDEV (Algorithm 121)
.I 488
.T
A Heuristic for Page Turning In a Multiprogrammed Computer
.I 489
.T
Current Status of IPL-V for the Philco 2000 Computer (June 1962)
.I 490
.T
Programmed Methods for Printer Graphical Output
.I 491
.T
Use of Multiprogramming in the Design of a Low Cost Digital Computer
.I 492
.T
Analysis of a File Addressing Method
.W
This paper presents a new file addressing method
based on the calculation of an address from 
the identification of a record.  For large recirculating
type files, it seems to be more advantageous 
than customary ones.  The probability distribution of
the displacement of records from their calculated 
address, which is one less than the number of probes
required to address a record, is computed on the 
basis of a Markov chain model.  For the reader not interested
in the mathematics, the introduction and 
the summary should be sufficient.
.I 493
.T
The Property Classification Method of File Design and Processing
.I 494
.T
A Finite Sequentially Compact Process for the Adjoints
of Matrices Over Arbitrary Integral Domains
.I 495
.T
A Procedure for Inverting Large Symmetric Matrices
.W
In the least squares method for simultaneous
adjustment of several parameters, the coefficients 
of the normal equations are the elements of a symmetric
positive-definite matrix.  In order to solve 
the normal equations and evaluate the precision measures
of the resulting parameters, inversion of this 
matrix of coefficients is required.  Many available procedures
for matrix inversion do not take advantage 
of the symmetry.  Thus, when programmed for a high-speed
computer, all n^2 elements must be stored and 
manipulated, whereas only (n + 1)/2 of them are independent.
 In order to allow a computer of given memory 
capacity to handle a larger matrix, the following procedure
for inverting a symmetric matrix has been 
devised.
.I 496
.T
A Set of Matrices for Testing Computer Programs
.I 497
.T
Further Remarks on Line Segment Curve-Fitting Using Dynamic Programming
.W
In a recent paper, Bellman showed how dynamic
programming could be used to determine the solution 
to a problem previously considered by Stone.  The problem
comprises the determination, given N, of the 
N points of subdivision of a given interval (a,B) and
the corresponding line segments, that give the 
best least squares fit to a function g(x) in the interval.
 Bellman confined himself primarily to the 
analytical derivation, suggesting briefly, however,
how the solution of the equation derived for each 
particular point of subdivision u(i) could be reduced to
a discrete search.  In this paper, the computational 
procedure is considered more fully, and the similarities
to some of Stone's equations are indicated. 
 It is further shown that an equation for u(i) involving
no minimization may be found.  In addition, 
it is shown how Bellman's method may be applied to the
curve-fitting problem when the additional constraints 
are added that the ends of the line segments must be on the curve.
.I 498
.T
Magic Square (Algorithm 117 & 118)
.I 499
.T
Permutation Generator (Algorithm 87)
.I 500
.T
PERMUTE (Algorithm 86)
.I 501
.T
JACOBI (Algorithm 85)
.I 502
.T
Simpson's Integration (Algorithm 84)
.I 503
.T
Rational Roots of Polynomials with Integer Coefficients (Algorithm 78)
.I 504
.T
FACTORS (Algorithm 75)
.I 505
.T
Composition Generator (Algorithm 72)
.I 506
.T
PERMUTATION (Algorithm 71)
.I 507
.T
Partition, Quicksort, Find (Algorithm 63, 64, 65)
.I 508
.T
Matrix Inversion (Algorithm 58)
.I 509
.T
Matrix Inversion (Algorithm 58)
.I 510
.T
Ber or Bei Function (Algorithm 57)
.I 511
.T
A Set of Test Matrices (Algorithm 52)
.I 512
.T
Telescope 1 (Algorithm 37)
.I 513
.T
SIEVE (Algorithm 35)
.I 514
.T
Binomial Coefficients (Algorithm 19)
.I 515
.T
Rational Interpolation by Continued Fractions (Algorithm 18)
.I 516
.T
Matrix Inversion II (Algorithm 120)
.I 517
.T
Evaluation of Pert Network (Algorithm 119)
.I 518
.T
Magic Square (Odd Order) (Algorithm 118)
.I 519
.T
Magic Square (Even Order) (Algorithm 117)
.I 520
.T
Complex Division (Algorithm 116)
.I 521
.T
PERM (Algorithm 115)
.I 522
.T
Generation of Partitions with Constraints (Algorithm 114)
.I 523
.T
TREESORT (Algorithm 113)
.I 524
.T
Position of Point Relative to Polygon (Algorithm 112)
.I 525
.T
A Computer Technique for Handling Analysis of Variance
.I 526
.T
Character Manipulation in Fortran
.I 527
.T
The Description List of Concepts
.W
A concept is defined as a class of objects
whose members can be distinguished by processing 
its properties.  Property is defined to mean a partition
of the set of all objects into disjoint classes. 
 The formal definition of a concept is recursive in nature.
 A concept is described by a list structure. 
 A one-to-one correspondence is established between the
recursive definition of a concept and its description 
list structure.  Like the definition, the description
list structure of a concept is also built up from 
elementary list structures by a recursive process. 
The list structures obtained this way are compared 
with the description list structure discussed
by the author in a previous publication.
.I 528
.T
FORTRAN for Business Data Processing
.I 529
.T
Regression and Coded Patterns in Data Editing
.I 530
.T
A Computer Method for Radiation Treatment Planning
.I 531
.T
Person-Matching by Electronic Methods
.W
Record linkage in the updating of files is
accomplished in many establishments through the 
use of a preassigned number, such as payroll number,
customer number, or social security number.  In 
vital and health records, however, a unique number
is generally not preassigned to an individual for 
purposes of reporting services received to the health
department.  In order to determine whether different 
physician reports refer to the same individual, name
and other identification must be compared.  This 
is a laborious operation which is subject to various
errors because of name misspellings, changes of 
name upon marriage, and other problems.  We are interested
in the maintenance of a psychiatric case register 
in Maryland, where many of the reports from over a hundred
psychiatric agencies refer to the same patient. 
 These records must be linked in order to provide unduplicated
counts of individuals under care and longitudinal 
records of psychiatric history.  An earlier paper [1] describes
our general procedures for register maintenance 
by use of a digital computer (Honeywell 800).  Here
we present in more detail our initial procedures 
for the person-matching process in order to elicit comments
and suggestions from persons who have had 
experience in matching.
.I 532
.T
On the Computation of Rational Approximations to Continuous Functions
.I 533
.T
Digital Synthesis of Correlated Stationary Noise
.W
In this note we propose a method of generating
stationary noise with a prescribed auto-covariance 
function by digital methods.  The need for such a technique
often arises in testing the performance of 
data processing and engineering systems, where inputs
corrupted with correlated noise (of a known form) 
are required.  The technique is quite simple and produces
strict-sense stationary noise which agrees 
approximately with R(t), the prescribed auto-covariance
function (acf), over an interval [-T(0), T(0)]. 
 The method consists of approximating the spectral density
by a periodic process with spectral lines, 
and then synthesizing the periodic noise with random
phases and appropriate amplitudes.  In order to 
simplify discussion of the statistical properties of the
noise generated, the technique is first presented 
in terms of exact harmonic analysis.  In practice, discrete
harmonic analysis as presented in the third 
section is used.
.I 534
.T
Quick Calculation of Jacobian Elliptic Functions
.I 535
.T
Triangular Walk Pattern for the Down-hill
Method of Solving a Transcendental Equation
.I 536
.T
Nonlinear Regression and the Solution of Simultaneous Equations
.W
If one has a set of observables (Z1,...,Zm) which
are bound in a relation with certain parameters 
(A1,...,An) by an equation S(Z1,...;A1,...)=0, one frequently
has the problem of determining a set of 
values of the Ai which minimizes the sum of squares of
differences between observed and calculated values 
of a distinguished observable, say Zm.  If the solution
of the above equation for Zm,  Zm=N(Z1,...;A1,...) 
gives rise to a function N which is nonlinear in the Ai,
then one may rely on a version of Gaussian regression 
[1,2] for an iteration scheme that converges to a minimizing
set of values.  It is shown here that this 
same minimization technique may be used for the solution
of simultaneous (not necessarily linear) equations.
.I 537
.T
A Machine Program for Theorem-Proving
.W
The program of a proof procedure is discussed in
connection with trial runs and possible improvements.
.I 538
.T
Quantum Mechanical Integrals of Slater-Type Orbitals (Algorithm 110)
.I 539
.T
Definite Exponential Integrals B (Algorithm 109)
.I 540
.T
Definite Exponential Integrals A (Algorithm 108)
.I 541
.T
Simpson's Integration (Algorithm 84)
.I 542
.T
FACTORS (Algorithm 75)
.I 543
.T
Interpolation by Aitken (Algorithm 70)
.I 544
.T
 Ber or Bei Function (Algorithm 57)
.I 545
.T
Adjust Inverse of a Matrix when an Element is Perturbed (Algorithm 51)
.I 546
.T
Logarithm of a Complex Number (Algorithm 48)
.I 547
.T
Gamma Function (Algorithm 34)
.I 548
.T
Molecular-Orbital Calculation of Molecular Interactions
.I 549
.T
Quantum Mechanical Integrals of Slater-Type Orbitals
.I 550
.T
Definite Exponential Integrals B (Algorithm 109)
.I 551
.T
Definite Exponential Integrals A (Algorithm 108)
.I 552
.T
Gauss's Method (Algorithm 107)
.I 553
.T
Complex Number to a Real Power (Algorithm 106)
.I 554
.T
Newton Maehly, (Algorithm 105)
.I 555
.T
Reduction to Jacobi (Algorithm 104)
.I 556
.T
On Translation of Boolean Expressions
.I 557
.T
Simulation of Computer Timing Device
.I 558
.T
A Modified Inversion Procedure for Product
Form of the Inverse Linear Programming Codes
.W
This paper describes a new algorithm for the
selection of the pivot row in matrix inversion 
when using the product form of the inverse.  This algorithm
has been developed for linear programming 
codes; however, it would be valuable for the inversion
of any non-dense matrix.  The procedures described 
in this paper have been thoroughly tested and have been
in operation on the Esso Research and Engineering 
IBM 7090 computer for nine months.  Substantial computer
cost savings have been realized because of this 
procedure.
.I 559
.T
Solution of Eigenvalue Problems With Approximately Known Eigenvectors
.I 560
.T
Communication Between Independently Translated Blocks
.I 561
.T
Analytic Differentiation By Computer
.I 562
.T
AVINT (Algorithm 77)
.I 563
.T
Sorting Procedures (Algorithm 76)
.I 564
.T
CRAM (Algorithm 67)
.I 565
.T
INVRS (Algorithm 66)
.I 566
.T
Matrix Inversion (Algorithm 58)
.I 567
.T
Logarithm of a Complex Number (Algorithm 48)
.I 568
.T
Exponential of a Complex Number (Algorithm 46)
.I 569
.T
Binomial Coefficients (Algorithm 19)
.I 570
.T
Simpson's Rule Integrator (Algorithm 103)
.I 571
.T
Permutation in Lexicographical Order (Algorithm 102)
.I 572
.T
Add Item to Chain-Linked List (Algorithm 100)
.I 573
.T
Remove Item From Chain-Linked List (Algorithm 101)
.I 574
.T
Evaluation of Jacobi Symbol (Algorithm 99)
.I 575
.T
Evaluation of Definite Complex Line Integrals (Algorithm 98)
.I 576
.T
Shortest Path (Algorithm 97)
.I 577
.T
ANCESTOR (Algorithm 96)
.I 578
.T
Generation of Partitions in Part-Count Form (Algorithm 95)
.I 579
.T
COMBINATION (Algorithm 94)
.I 580
.T
General Order Arithmetic (Algorithm 93)
.I 581
.T
A Note on Sampling a Tape-File
.I 582
.T
One Lost Bit
.I 583
.T
A Redundancy Check for ALGOL Programs
.I 584
.T
Report on the Algorithmic Language FORTRAN II
.I 585
.T
Initial Experience With an Operating Multiprogramming System
.W
The Lewis Research Center has been using various
forms and degrees of program simultaneity 
in the operation of its modified Sperry-Rand Univac Scientific
Model 1103 computer during the last five 
years.  This simultaneity has evolved from an initial
achievement of self-searching input and output 
to the automatic time sharing of independently coded
problems.  Several important machine and program 
system modifications were necessary to accomplish this
evolution.  Several additional modifications, 
although not required, were added to facilitate ease
of coding and operation.  All modifications had 
to proceed at a relatively temperate pace to insure that
the basic data-reduction work load of the computing 
center was completed on schedule.  Some educationally
valuable mistakes were made, and their suggested 
cures often pointed the way to useful future improvements
or emphasized some of the basic principles 
of a multiprogramming system.  The material that follows
is a description of the evolution of the programming 
and hardware system which has developed into the present
multiprogramming system at Lewis research Center.
.I 586
.T
Simultaneous System of Equations and
Matrix Inversion Routine (Algorithm 92)
.I 587
.T
Romberg Integration (Algorithm 60)
.I 588
.T
Chebyshev Curve-Fit (Algorithm 91)
.I 589
.T
Evaluation of the Fresnel Cosine Integral (Algorithm 90)
.I 590
.T
Evaluation of the Fresnel Sine Integral (Algorithm 89)
.I 591
.T
Evaluation of Asymptotic Expression for the
Fresnel Sine and Cosine Integrals (Algorithm 88)
.I 592
.T
COBOL Batching Problems
.I 593
.T
An Introduction to a Machine-Independent Data Division
.I 594
.T
An Advanced Input-Output System for a COBOL Compiler
.I 595
.T
Guides to Teaching COBOL
.W
The teaching of COBOL can be divided into
three main subject areas.  They are the syntax of 
COBOL, the use of such syntax in solving any given problem,
and programming concepts.  It is generally 
accepted that some knowledge of the hardware and computer
logic must be possessed by the programmer. 
 The teaching problem arises in determining how thoroughly
a student must know the hardware and logic 
for that computer for which he will write COBOL programs.
 Unfortunately, historical data concerning 
students' programming proficiency is almost non-existent
and, at best, difficult to measure.  How then 
might we approach solving this problem?
.I 596
.T
Floating-Point Arithmetic in COBOL
.W
In this paper the basic operations of floating-point
arithmetic are examined and COBOL procedures 
for carrying these out are given, along with specification
of working storage.  The paper concludes with 
an example in which these procedures are used.
.I 597
.T
Modular Data Processing Systems Written in COBOL
.I 598
.T
The COBOL Librarian - A Key to Object Program Efficiency
.W
Many answers to the question "How may a COBOL
Compiler be forced into the generation of an 
efficient object program?"  The purpose of this article
is to present one possible answer: the creation 
and full utilization of a well-constructed COBOL Library.
.I 599
.T
A Report Writer For COBOL
.I 600
.T
Syntactical Charts of COBOL 61
.I 601
.T
Interim Report on Bureau of Ships COBOL Evaluation Program
.I 602
.T
COBOL and Compatibility
.I 603
.T
Basic Elements of COBOL 61
.I 604
.T
Why COBOL?
.I 605
.T
Computer Simulation Of City Traffic
.W
In simulating traffic flow on city streets,
the National Bureau of Standards has used data 
processing techniques to tabulate and make motion pictures
of vehicle movements in the model.  Each vehicle 
is assigned a digital identification giving points of
entry and exit, type of vehicle, desired speed, 
and actual speed, in proportions simulating field data.
 Changes in the model can be made to observe 
their consequences and to determine the ability of a
real street to carry loads expected in the future.
.I 606
.T
A Method for Eliminating Ambiguity Due
to Signal Coincidence in Digital Design
.I 607
.T
The Calculation of Easter...
.I 608
.T
Permutation (Algorithm 71)
.I 609
.T
Permutation (Algorithm 71)
.I 610
.T
SIEVE (Algorithm 35)
.I 611
.T
Permutation Generator (Algorithm 87)
.I 612
.T
Permute (Algorithm 86)
.I 613
.T
JACOBI (Algorithm 85)
.I 614
.T
Simpson's Integration (Algorithm 84)
.I 615
.T
Addressing Multidimensional Arrays
.W
A useful method of representing a function of
n variables is to consider the function to assume 
its values at selected points in n-dimensional space.
 Although this picture is of value to the analyst, 
the elements of an n-dimensional array must exist in
conventional storage as a linear array or vector. 
 The means of performing the transformation of a set
of indices locating on array element in n-space 
to the location (address) of the element in its storage
vector is the subject of this paper.  It is noted 
that the index address transformation is computationally
identical to the conversion of a number from 
a fixed to a mixed radix number system.  Several ways
of implementing the transformation are described.
.I 616
.T
An Information Algebra - Phase I Report-Language
Structure Group of the CODASYL Development Committee
.W
This report represents the results of the
first phase of the work of the Language Structure 
Group.  The goal of this work is to arrive at a proper
structure for a machine-independent problem-defining 
language, at the systems level of data processing.  The
report is based, for the most part, on a mathematical 
model called "An Information Algebra" developed primarily
by R. Bosak.  It is hoped that this report 
will be read (a) with avid interest by programming language
designers and implementors, and all those 
interested in developing a theoretical approach to data
processing; (b) with interest and understanding 
by professional programmers and systems analysts; and (c)
with appreciation by the businessman-analyst-manager. 
 The authors have not attempted an exhaustive discourse
in this report.  Rather, they have tried to present 
a philosophy to the professional people who are vitally
concerned with providing a working language for 
the systems analyst's use.  They trust that the ideas
in this report will stimulate others to think along 
similar lines.  Questions and comments will be welcomed,
and can be addressed to any of the members of 
the Language Structure Group:  Robert Bosak, System
Development Corporation;  Richard F. Clippinger, 
Honeywell EDP Division;  Carey Dobbs, Remington Rand
Univac Division;  Roy Goldfinger (Chairman), IBM 
Corporation;  Renee B. Jasper, Navy Management Office;
 William Keating, National Cash Register;  George 
Kendrick, General Electric Company;  Jean E. Sammet, IBM Corporation.
.I 617
.T
POSEIDON
.W
Any computer that forms part of a control system-whether
completely automatic or partly human-must 
work at the same speed as the control system.  It must
perform its calculations or data processing fast 
enough for the results to be available at the required
instants in the action of the control system. 
 This known as working in "real time."
.I 618
.T
Computers- The Key to Total Systems Control: An Industrial Viewpoint
.W
Man-Man-machine processes are characterized in five
main types, and the markets for each type are 
shown for 1950 and 1960 and estimated for 1970.
.I 619
.T
Retrieval of Misspelled Names in an Airlines Passenger Record System
.W
This paper discusses the limited problem of
recognition and retrieval of a given misspelled 
name from among a roster of several hundred names, such
as the reservation inventory for a given flight 
of a large jet airliner.  A program has been developed
and operated on the Telefile (a stored-program 
core and drum memory solid-state computer) which will
retrieve passengers' records successfully, despite 
significant misspellings either at original entry time
or at retrieval time.  The procedure involves 
an automatic scoring technique which matches the names
in a condensed form. Only those few names most 
closely resembling the requested name, with their phone
numbers annexed, are presented for the agents 
final manual selecton.  The program has successfully
isolated and retrieved names which were subjected 
to a number of unusual (as well as usual) misspellings.
.I 620
.T
RATFACT (Algorithm 78)
.I 621
.T
Romberg Integration (Algorithm 60)
.I 622
.T
Optimal Classification of Objects (Algorithm 83)
.I 623
.T
Economising a Sequence 2 (Algorithm 82)
.I 624
.T
Economising a Sequence 1 (Algorithm 81)
.I 625
.T
Reciprocal Gamma Function of Real Argument (Algorithm 80)
.I 626
.T
A Method of Representation, Storage and Retrieval
of 13 Random Codes in a 4-Digit Number or 16 
Random Codes in a 5-Digit Number
.I 627
.T
Knotted List Structures
.I 628
.T
On a Floating-Point Number Representation
For Use with Algorithmic Languages
.I 629
.T
On a Wired-In Binary-to-Decimal Conversion Scheme
.I 630
.T
An Evaluation of Autocode Readability
.W
Of the many requirements of an autocode, the
pair of requirements "easy to read" and "easy 
to write" are not often compatible.  This paper argues
that readability can be added automatically in 
the translation process so that the programmer can
enjoy the utmost economy of expression, while for 
management a full and valid COBOL version is printed to give
all the advantages of readability and compatibility.
.I 631
.T
Automatic-Programming-Language Translation Through Syntactical Analysis*
.I 632
.T
Vectorcardiographic Diagnosis With The Aid of ALGOL
.I 633
.T
Simulation and Analysis of Biochemical Systems
(III. Analysis and Pattern Recognition)
.I 634
.T
Manipulation of Trees in Information Retrieval*
.I 635
.T
A Note on Multiplying Boolean Matrices
.I 636
.T
Tape Splitting in an Iterative Program
.I 637
.T
A NELIAC-Generated 7090-1401 Compiler
.W
NELIAC systems for several different machines
have been generated using the original NELIAC 
system developed at the Naval Electronics Laboratory,
San Diego, in 1958.  A basic "bootstrap" process 
was used to generate all but the first, i.e. the systems
were described in the NELIAC language and generated 
by an existing NELIAC compiler.  This experience has
shown there is no inherent difficulty in "building 
compilers with compilers"; indeed, it pointed out many advantages
in using a POL for constructing programming 
systems.  This report presents the results of a project
completed in May, 1961 in which the NELIAC system 
was used to generate a compiler for the IBM 1401.  The
1401 compiler, which runs on the 7090 and produces 
1401 programs, was described in the NELIAC language and
generated with 7090 NELIAC system.  The reduction 
in programming time and the improvement in documentation
of the system were very significant.
.I 638
.T
SURGE: A Recoding of the COBOL Merchandise Control Algorithm
.I 639
.T
Difference Expression Coefficients (Algorithm 79)
.I 640
.T
Rational Roots of Polynomials with Integer Coefficients (Algorithm 78)
.I 641
.T
Interpolation, Differentiation, and Integration (Algorithm 77)
.I 642
.T
An Introduction to ALGOL 
.I 643
.T
Simulation and Analysis of Biochemcial Systems
(II. Solution of Differential Equations)
.I 644
.T
A String Language for Symbol Manipulation Based on ALGOL 60
.W
An artificial computer programming language
is proposed for describing the manipulation of 
strings of characters and symbols.  The concept of strings,
introduced in the ALGOL 60 report, is extended 
by adding: (1) the declaration of strings, substrings,
and string arrays with explicit lengths; (2) the 
ability to concatenate and shift strings; and (3) the
ranking of symbols for comparing stings in Boolean 
relations.  A primer or informal description of the
language is followed by examples, a description of 
experiments with the language on an IBM 704 computer,
and a formal description which, taken with the 
ALGOL 60 Report, defines the proposed string language.
.I 645
.T
INVRS (Algorithm 66)
.I 646
.T
Inverse of a Finite Segment of the Hilbert Matrix (Algorithm 50)
.I 647
.T
Numerical Solution of the Polynomial Equation (Algorithm 30)
.I 648
.T
Sorting Procedures (Algorithm 76)
.I 649
.T
FACTORS (Algorithm 75)
.I 650
.T
Curve Fitting with Constraints (Algorithm 74)
.I 651
.T
A Survey of Languages and Systems for Information Retrieval
.I 652
.T
Use of Semantic Structure in Information Systems
.I 653
.T
Translation of Retrieval Requests Couched
in a "Semiformal" English-Like Language*
.I 654
.T
Language Problems Posed by Heavily Structured Data
.I 655
.T
COMIT as an IR Language
.W
Many of the features that make COMIT a good
all around symbol manipulation language also render 
it well suited to various types of information retrieval
programs.  Presented here is a general discussion 
of this unique and different programming language
and an examination of some of its applications.
.I 656
.T
An Information System With The Ability To Extract Intelligence From Data
.I 657
.T
Information Structures for Processing and Retrieving
.I 658
.T
Discussion-The Pros and Cons of a Special IR Language
.I 659
.T
Reversion of Series (Algorithm 193)
.I 660
.T
More Test Matrices for Determinants and Inverses (Pracnique)
.I 661
.T
Indexing and the Lambda-Notation
.W
Some methods of indexing sequentially stored
elements of sparse multi-dimensional arrays are 
described in the scheme A notation.
.I 662
.T
Shuttle Sort (Algorithm 175)
.I 663
.T
Determinant (Algorithm 159)
.I 664
.T
Assignment (Algorithm 27)
.I 665
.T
Gauss-Seidel (Algorithm 220)
.I 666
.T
Topological Ordering for Pert Networks (Algorithm 219)
.I 667
.T
Kutta Merson (Algorithm 218)
.I 668
.T
Minimum Excess Cost Curve (Algorithm 217)
.I 669
.T
A Specification of JOVIAL
.I 670
.T
Some Legal Implications of the Use of Computers in the Banking Business
.W
The introduction of computers in to the banking
business has a wide variety of legal implications 
that merit careful attention at this very early stage.
 The industry is highly regulated by government 
and, hence, is subject to many statutes and regulations.
 It also is affected by important common law 
rules established by courts.  The legal ramifications
involve not only the mechanization itself, but 
also the very significant, economically attractive phenomenon
of off premises processing.  It is essential 
to identify and provide for many legal aspects right
now, before systems and practices crystallize, in 
order to avoid the later impact of unanticipated physical
complications and expense.  The legal aspects 
of computerization in the banking business are especially
diverse.  In some states, there might be the 
basic question whether banks are authorized by law to
invest in the new facilities, either directly or 
through cooperatives.  More challenging are questions
relating to off-premises processors, particularly 
with respect to the obligation not to disclose information
concerning a bank's customers, the adequacy 
of fidelity bond coverage, the extent of liability for
improper refusal to pay a check, and susceptibility 
to regulation by government agencies.  Also pertinent
is the propriety of data processing by banks for 
nonbank entities and particularly of the rendering of
that service without charge for bank depositors.
.I 671
.T
TELEFILE-A Case Study of an On-Line Savings Bank Application
.W
The development of an on-line computer system
for a savings bank institution is traced from 
the early conceptual needs of the bank to the consummation
of design by The Teleregister Corporation. 
 Both bank and equipment criteria are specified which
led to the development of the Telefile System of 
The Teleregister Corporation.  Operation of the on-line
and off-line programs are described and statistics 
are cited for reliability and performance of the system.
 Benefits to the bank are discussed from the 
banker's point of view; an indication of future trends
in the on-line savings bank field is also discussed.
.I 672
.T
Recent Developments Affecting ADP in Tax Administration
.I 673
.T
Account Classification at Automating Banks
.I 674
.T
Application of IBM 1620 EDP Methods to the Calculation
of the Formation Constants of Complex 
Irons
.I 675
.T
Coding Clinical Laboratory Data For Automatic Storage and Retrieval
.W
A series of clinical laboratory codes have been
developed to accept and store urin analysis, blood 
chemistry, and hematology test results for automatic
data processing.  The codes, although constructed 
as part of a computerized hospital simulation, have been
able to handle the results of every laboratory 
test that they have encountered.  The unique feature of
these codes is that they can accept conventionally 
recorded qualitative as well as quantitative test results.
 Consequently, clinical test results need 
not be arbitrarily stratified, standardized, or altered
in any way to be coded.  This paper describes 
how the codes were developed and presents a listing of the
urin analysis codes.  Five criteria used in developing 
the codes are outlined and the problem of multiple-synonymous
terminology is discussed.  A solution to 
the problem is described.  Flexible, computer-produced,
composite laboratory reports are also discussed, 
along with reproduction of such a report. The paper concludes
that even though many problems remain unsolved, 
the next ten years could witness the emergence of a practical
automated information system in the laboratory.
.I 676
.T
On the Computation of a Certain Type of IncompleteBeta Functions
.I 677
.T
Length of Strings for a Merge Sort
.W
Detailed statistics are given on the length
of maximal sorted strings which result form the 
first (internal sort) phase of a merge sort onto tapes.
 It is shown that the strings produced by an 
alternating method (i.e. one which produces ascending
and descending strings alternately) tend to be 
only three-fourths as long as those in a method which produces
only ascending strings, contrary to statements 
which have appeared previously in the literature.  A
slight modification of the read-backward polyphase 
merge algorithm is therefore suggested.
.I 678
.T
Optimizing Bit-time Computer Simulation
.W
A major component of a bit-time computer simulation
program is the Boolean compiler.  The compiler 
accepts the Boolean functions representing the simulated computer's
digital circuits, and generates corresponding 
sets of machine instructions which are subsequently
executed on the "host" computer.  Techniques are 
discussed for increasing the sophistication of the Boolean
compiler so as to optimize bit-time computer 
simulation.  The techniques are applicable to any general-purpose computer.
.I 679
.T
Recent Improvements in MADCAP
.W
MADCAP is a programming language admitting subscripts,
superscripts and certain forms of displayed 
formulas.  The basic implementation of this language was
described in a previous paper [MADCAP: A scientific 
compiler for a displayed formula textbook language, Comm.
ACM 4 (Jan. 61), 31-36].  This paper discusses 
recent improvements in the language in three areas: complex
display, logical control, and subprogramming. 
 In the area of complex display, the most prominent improvements
are a notation for integration and for 
the binomial coefficients.  In the area of logical control
the chief new feature is a notation for variably 
nested looping.  The discussion of subprogramming is focused
on MADCAP's notation for and use of "procedures."
.I 680
.T
An Error-Correcting Parse Algorithm
.I 681
.T
Flexible Abbreviation of Words in a Computer Language
.I 682
.T
Recursive programming in FORTRAN II
.I 683
.T
A Serial Technique to Determine Minimum Paths
.I 684
.T
Interpolation, Differentiation, and Integration (Algorithm 77)
.I 685
.T
Euler Summation (Algorithm 8)
.I 686
.T
Smooth (Algorithm 216)
.I 687
.T
Shanks (Algorithm 215)
.I 688
.T
q-Bessel Functions In(t)(Algorithm 214)
.I 689
.T
Report of a Visit to Discuss Common Programming
Languages in Czechoslovakia and Poland, 1963
.I 690
.T
USA Participation in an International
Standard glossary on Information Processing
.I 691
.T
A Description of the APT Language
.W
The APT (Automatically Programmed Tools) language
for numerical control programming is described 
using the metalinguistic notation introduced in the ALGOL
60 report.  Examples of APT usage are included. 
 Presented also are an historical summary of the development
of APT and a statement concerning its present 
status.  
.I 692
.T
On the Inverse of a Test Matrix
.I 693
.T
An Extension of Fibonaccian Search To Several Variables
.W
A technique which uses Fibonaccian search
concepts has been developed to solve optimization 
problems involving unimodal functions of several variables.
 The technique has not been proven to be 
optimal in the sense that the one-dimensional Fibonaccian
search is.  However, it is valuable for certain 
kinds of calculations.
.I 694
.T
A Comparison of Disks and Tapes
.W
The principal characteristics of current magnetic
disks and tape units are summarized and compared. 
 Some of the characteristics of disk files are illustrated
in a sorting example and compared to a tapesort. 
 The conclusion is presented that disk files are competitive
to tapes in some important applications.
.I 695
.T
Use of the Disk File on Stretch
.W
The paper begins by briefly describing the
Stretch (IBM 7030) computer with special emphasis 
given to the organization and operation of its input-output
equipment.  Physical characteristics of the 
two-disk system (4,194,304 72-bit words, 8 usec-per-word
transmission rate, etc.) are noted.  Timing 
limitations due to arm motion and disk rotation are discussed.
 Applications of disk usage are discussed 
separately for problem programs and for systems programs
such as compilers and the supervisory program. 
Approximately 260,000 words of disk storage are reserved
for the storage of systems programs and the 
subroutine library.  Problem programs, however, are not
currently filed on the disk.  Certain programming 
techniques are discussed for transmitting words between
disk and core storage with minimum delaying and 
interruption of the arithmetic unit.  Dumps on disk are
considered for both recovery from computer malfunction 
and for mathematical or physical developments during
the calculation.  Some comments are made regarding 
the reliability, economics, utility and weaknesses or
limitations of the disk system.  Several possible 
future applications are noted which appear to have disk connotations.
.I 696
.T
An Automatic Data Acquisition and Inquiry System Using Disk Files
.W
Lockheed Missiles and Space Company has installed
a large-scale Automatic Data Acquisition 
(ADA) system which ties together the Company's manufacturing
facilities located in Van Nuys and Sunnyvale, 
California.  The system includes over 200 remote Input
Stations which collect and transmit Company operating 
data to a central Data Processing Center.  Two RCA 301
EDP Systems are used to record and control the 
flow of data transmitted to the Data Processing Center.
 A large capacity RCA 366 Data Disc File is used 
to store information required to provide up-to-date
information in response to inquiries received from 
remotely located Inquiry Stations.  In addition to storage
of data on the disk files, the system automatically 
records all incoming and outgoing data on magnetic tape
to be used as input to the Company's conventional 
off-line business data processing applications.
.I 697
.T
A Numerical Method for the Determination of Moving
Field Isodose Curves for Treatment Planning 
in Radiotherapy
.I 698
.T
DATA-DIAL: Two-Way Communication with
Computers From Ordinary dial Telephones
.W
An operating system is described which allows
users to call up a remotely located computer 
from ordinary dial telephones.  No special hardware or
connections are required at the users' telephones. 
 Input to the computer is through the telephone dial;output
from the computer is in spoken form.  Results 
of a test with telephones in the Boston area are reported.
.I 699
.T
A Contour-Map Program for X-Ray Crystallography
.W
A FORTRAN program is described for use with
the IBM 7090 system and an X, Y-plotter to produce 
a contour map.  A matrix of points evenly spaced in
each dimension is contoured.  Scale factors along 
the axes may be different and the axes need not be perpendicular.
.I 700
.T
Hermite Interpolation (Algorithm 210)
.I 701
.T
Shuttle Sort (Algorithm 175)
.I 702
.T
Assign (Algorithm 173)
.I 703
.T
Assign (Algorithm 173)
.I 704
.T
Combinatorial of M Things Taken One At A Time
Two At A Time, Up To N At A Time (Algorithm 161)
.I 705
.T
Combinatorial Of M Things Taken N At A Time (Algorithm 160)
.I 706
.T
Fourier Series Approximation (Algorithm 157)
.I 707
.T
Erf(x) (Algorithm 123)
.I 708
.T
Evaluation of the Fresnel Integrals (Algorithm 88, 89, 90)
.I 709
.T
Assignment (Algorithm 27)
.I 710
.T
Fresnel Integrals (Algorithm 213)
.I 711
.T
Frequency Distribution (Algorithm 212)
.I 712
.T
Hermite Interpolation (Algorithm 211)
.I 713
.T
Lagrangian Interpolation (Algorithm 210)
.I 714
.T
Gauss (Algorithm 209)
.I 715
.T
Discrete Convolution (Algorithm 208)
.I 716
.T
Stringsort (Algorithm 207)
.I 717
.T
Partitioning Algorithms for Finite Sets
.W
The partitions of a set with n elements are represented
by certain n-tuples of positive integers. 
 Algorithm are described which generate without repetitions
the n-tuples corresponding to: (1) all partitions 
of the given set, (2) all partitions of the given set
into m or fewer sets (1 <= m <= n), and (3) all 
partitions of the given set into exactly m sets (1 <= m <= n).
.I 718
.T
An Experiment in Automatic Verification of Programs 
.W
How effective is a compiler at replacing explicit
verification, and what is the cost of this 
technique?
.I 719
.T
Variable Width Stacks
.W
Character addressable, variable field computers
permit ready establishment and manipulation 
of variable width stacks.  Single machine commands may
push variable field items down into such stacks 
or pop them up.  The availability of a variety of field
delimiters allows the machine to push down or 
pop up more than one variable width item with one command.
 Since these stacking operations can be made 
the basis of compiler decoding algorithms the proper
use of machines of this class for compilation has 
advantages over machines with fixed-length words.
.I 720
.T
Format-Free Input in FORTRAN
.I 721
.T
Report on Proposed American Standard Flowchart
Symbols for Information Processing
.W
This paper presents the essential contents of
the Proposed American Standard Flowchart Symbols 
for Information Processing.  This is the first proposed
standard prepared by Subcommittee X3.6 on Problem 
Description and Analysis of the American Standards Association (ASA).
.I 722
.T
ALCOR Group Representation of ALGOL Symbols
.I 723
.T
ECMA Subset of ALGOL 60
.I 724
.T
A Profile of the Programmer
.W
Synopsis: 549 members of the ACM participated
in a study concerned primarily with the attitudes 
of programmers toward their careers and jobs.  A very
high percentage of programmers have apparently 
entered their careers by accident; it has proven a happy
choice for most and they expect to remain in 
the field during the next five years.  Their principal
job satisfactions relate to the nature of their 
work, and mostfind their jobs offer high level of professional
interest and good working conditions. 
 Salary and advancement prospects, however,are not as
satisfactory.  More than half report a positive 
attitude toward programmers and programming on the part
of their organizations.  Turnover among themselves 
is attributed primarily to poor management-salary is
seen as the principal motivating factor in turnover 
among other programmers.  Nature of the work offered
and salary are principal determinants in accepting 
a new job.  Programmers are less mobile than expected.
 Programmers tend to see their colleagues in a 
favorable light, on the whole.  Personalities seem to
vary with function, systems programmers differing 
from applications programmers.  Four principal problems
for programming in the immediate future are listed 
by participants: languages, personnel, various specific
applications and techniques, and building programming 
as a profession.
.I 725
.T
Group Participation Computer Demonstration
.I 726
.T
A General Program for the Analysis of
Square and Rectangular Lattice Designs
.W
This paper describes a general-purpose program
that will handle those incomplete block designs 
known as square and rectangular lattices.  Flow diagrams
are given so that the method of calculation 
may be programmed for any digital computer.
.I 727
.T
On the Approximate Solution of Delta(u)=F(u)
.W
Three-dimensional Dirichlet problems for Delta(u)=F(u),
Fu >= 0, are treated numerically by 
an exceptionally fast, exceptionally accurate numerical
method.  Programming details, numerous examples 
and mathematical theory are supplied.Extension of the
method in a natural way to n-dimensional problems 
is indicated by means of a 4-dimensional example.
.I 728
.T
Computer-Drawn Flowcharts*
.W
To meet the need for improved documentation
of written computer programs, a simple system for 
effective communication is presented, which has shown
great promise.  The programmer describes his program 
in a simple format, and the computer prepares flow charts
and other cross-referenced listings from this 
input.  The description can be kept up-to-date easily,
and the final output clearly explains the original 
program.  The system has also proved to be a valuable debugging and coding aid.
.I 729
.T
A Generalization of ALGOL
.I 730
.T
MIRFAG: A Compiler Based on Standard
Mathematical Notation And Plain English
.W
A pilot version of the compiler MIRFAG, now
in operation, is described.  The chief features 
of the system, which is intended for the solution of scientific
problems, are the presentation of mathematical 
formulas entirely in standard textbook notation.  The use
of plain English for organizational instructions, 
automatic error diagnosis indicating the actual location
of the error in the uncompiled program, and 
an attempt to minimize that fragmentation of the original
problem statement which is a normal feature 
of programming systems.
.I 731
.T
Symmetric List Processor 
.W
A list processing system in which each list
cell contains both a forward and a backward link 
as well as a datum is described.  This system is intended
for imbeding in higher level languages capable 
of calling functions and subroutines coded in machine language.
 The presentation is in the form of FORTRAN 
programs depending on only a limited set of FORTRAN programs
depending on only a limited set of "primitive" 
machine language subroutines which are also defined.
 Finally, a set of field, particularly character, 
manipulation primitives are given to round out the system.
.I 732
.T
Monte Carlo Inverse (Algorithm 166)
.I 733
.T
Newton Interpolation with Forward Divided Differences (Algorithm 169)
.I 734
.T
Newton Interpolation with Backward Divided Differences (Algorithm 168)
.I 735
.T
Calculation of Confluent Divided Differences (Algorithm 167)
.I 736
.T
Modified Hankel Functions (Algorithm 163)
.I 737
.T
Exponentiation of Series (Algorithm 158)
.I 738
.T
Fourier Series Approximation (Algorithm 157)
.I 739
.T
MINIFUN (Algorithm 129)
.I 740
.T
INTEREST (Algorithm 45)
.I 741
.T
Evaluation of Determinant (Algorithm 41)
.I 742
.T
Evaluation of Determinant (Algorithm 41)
.I 743
.T
ARCCOSIN (Algorithm 206)
.I 744
.T
ATIVE (Algorithm 205)
.I 745
.T
STEEP2 (Algorithm 204)
.I 746
.T
STEEP1 (Algorithm 203)
.I 747
.T
Generation of Permutations in Lexicographical Order (Algorithm 202)
.I 748
.T
A Semi-Iterative Process for Evaluating Arctangents
.I 749
.T
Note onStochastic Matrices
.I 750
.T
PEI Matrix Eigenvectors
.I 751
.T
A Note on a Set of Test Matrices for Inversion
.I 752
.T
Closing Out a Print Tape
.I 753
.T
A Procedure for Converting Logic Table Conditions
into an Efficient Sequence of Test Instructions
.I 754
.T
Ye Indiscreet Monitor
.I 755
.T
An Exponential Method of Numerical Integration
of Ordinary Differential Equations
.W
A formula for numerical integration is prepared,
which involves an exponential term.  This 
formula is compared to two standard integration methods,
and it is shown that for a large class of differential 
equations, the exponential formula has superior stability
properties for large step sizes.  Thus this 
formula may be used with a large step size to decrease the
total computing time for a solution significantly, 
particularly in those engineering problems where high accuracy is not needed.
.I 756
.T
A Computer Program for Editing the News
.I 757
.T
Simulation of a Traffic Network
.I 758
.T
Skeletal Structure of PERT and CPA Computer Programs
.W
An introduction to the inner mechanics of
PERT and CPA computer programs is provided.  The 
major components of these programs as well as their
purposes and interrelationships are outlined.
.I 759
.T
Continued Operation Notation for Symbol
Manipulation and Array Processing
.W
A brief account is given of a notational device
that is very useful in the formal representation 
of syntaxes, string relationships and string transformation
procedures and also of computing procedures 
that deal with arrays of functions of many variables. 
The device consists of the use of certain "continued 
operation" or "collective" symbols that are analogous to the summation
symbol (Sigma) and continued multiplication 
symbol (Pi) of conventional mathematics.
.I 760
.T
Dialects of FORTRAN
.I 761
.T
A Note on the Dangling Else in ALGOL 60
.W
Some revisions of ALGOL 60 are proposed, which
not only eliminate certain ambiguous statements 
but also add some convenience to the language.  A discussion
of the background of the problem and a sketch 
of a proof that the ambiguities have been removed is included.
.I 762
.T
Some Remarks on the Syntax of Symbolic Programming Languages
.I 763
.T
A Syntax Controlled Generator of Formal Language Processors
.I 764
.T
Reduction of a Matrix Containing Polynomial Elements (Algorithm 170)
.I 765
.T
Orthogonal Polynomial Least Squares Surface Fit (Algorithm 164)
.I 766
.T
XY-move Plotting (Algorithm 162)
.I 767
.T
Certification of Algorithm 161
Combinatorial of M Things Taken One at a Time,
Two at a Time, Up to N at a Time
[M. L. Wolfson and H. V. Wright,
Comm. ACM, Apr. 1963]
.I 768
.T
Certification of Algorithm 160
Combinatorial of M Things Taken N at a Time [M. L. Wolfson and H. V. Wright,
Comm. ACM, Apr. 1963]
.I 769
.T
Algebra of Sets (Algorithm 156)
.I 770
.T
Combination in Any Order (Algorithm 155)
.I 771
.T
Combination in Lexicographical Order (Algorithm 154)
.I 772
.T
GOMORY (Algorithm 153)
.I 773
.T
Matrix Inversion (Algorithm 140)
.I 774
.T
Jacobi (Algorithm 85)
.I 775
.T
Interpolation, Differentiation, and Integration (Algorithm 77)
.I 776
.T
Partition, Quicksort, and Find (Algorithm 62, 64, & 65)
.I 777
.T
A Set of Test Matrices (Algorithm 52)
.I 778
.T
Associated Legendre Functions of the First Kind
for Real or Imaginary Arguments (Algorithm 47)
.I 779
.T
CROUT II (Algorithm 43)
.I 780
.T
Algorithm 42 INVERT, Alg.107 Gauss's
Method, Alg.120 Inversion II, and gjr
.I 781
.T
Telescope 2 (Algorithm 38)
.I 782
.T
Telescope 1 (Algorithm 37)
.I 783
.T
Shellsort (Algorithm 201)
.I 784
.T
Normal Random (Algorithm 200)
.I 785
.T
Conversions Between Calendar Date And Julian day Number (Algorithm 199)
.I 786
.T
Adaptive Integration and Multiple Integration (Algorithm 198)
.I 787
.T
Matrix Division (Algorithm 197)
.I 788
.T
Muller's Method for Finding Roots of
an Arbitrary Function (Algorithm 196)
.I 789
.T
Bandsolve (Algorithm 195)
.I 790
.T
Zersol (Algorithm 194)
.I 791
.T
Character Manipulation in 7090 Fortran
.I 792
.T
Multiple-Precision Binary-To-Decimal Integer
Conversion Using Only Addition And Subtraction
.I 793
.T
Mapped List Structures
.I 794
.T
A List-Type Storage Technique for Alphameric Information
.W
A method which is economic in terms of space and
time is proposed for the storage and manipulation 
of character strings of arbitrary length in a fixed
word-length computer.  The method is illustrated 
in an application to Algol-type identifiers in an Algol-like block structure.
.I 795
.T
Debugging Systems at the Source Language Level
.I 796
.T
SABRAG, A Time-Sharing Low-Cost Computer
.W
The serial SABRAC computer designed and built
in the Scientific Department of the Israel defense 
Ministry has a 5000-location magnetic drum, main store.
 To avoid a need to resort to optimum programming 
techniques and to increase its overall efficiency the
computer has also been given a 224-word ferrite 
core store from which the program is obeyed.  Transfers
between the core and drum stores and to and from 
the twin paper-tape input and output channels are all
available autonomously (concurrently, time-shared). 
 Multiplication and division orders are also autonomous,
so that the machine may be executing up to three 
orders simultaneously.  All functions naturally are interlocked.
 A number of other advanced orders and 
facilities are also incorporated.In particular, an
"Execute" order permits a temporary jump for up 
to four orders and a second modifier register permits double
modification in general and relative addressing 
of subroutines in particular.  Thus the overall effective
speed of the machine is muchhigher than its 
basic specification would lead one to expect and its
design indicates one way in which the concepts of 
time sharing may be incorporated in "low-cost" computers.
.I 797
.T
American Standard Code for Information Interchange
.I 798
.T
A Catalogue Entry Retrieval System
.I 799
.T
Design of a Separable Transition-Diagram Compiler*
.W
A COBOL compiler design is presented which is
compact enough to permit rapid, one-pass compilation 
of a large subset of COBOL on a moderately large computer.
 Versions of the same compiler for smaller 
machines require only two working tapes plus a compiler
tape.  The methods given are largely applicable 
to the construction of ALGOL compilers.
.I 800
.T
The Linking Segment Subprogram Language and Linking Loader
.I 801
.T
Least Squares Solution with Constraints (Algorithm 177)
.I 802
.T
SYMINV2 (Algorithm 150)
.I 803
.T
Syminv2 (Algorithm 150)
.I 804
.T
Exponentiation of Series (Algorithms 134)
.I 805
.T
Newton Maehly (Algorithm 105)
.I 806
.T
Remark on Certification of Matrix Inversion Procedures
.I 807
.T
Reversion of Series (Algorithm 193)
.I 808
.T
Confluent Hypergeometric (Algorithm 192)
.I 809
.T
Hypergeometric (Algorithm 191)
.I 810
.T
Complex Power (Algorithm 190)
.I 811
.T
Smoothing 2 (Algorithm 189)
.I 812
.T
Smoothing 1 (Algorithm 188) 
.I 813
.T
Differences and Derivatives (Algorithm 187)
.I 814
.T
Complex Arithmetic (Algorithm 186)
.I 815
.T
Normal Probability for Curve Fitting (Algorithm 185)
.I 816
.T
Erlang Probability for Curve Fitting (Algorithm 184)
.I 817
.T
Nexcom (Algorithm 152)
.I 818
.T
Realizing Boolean Connectives on The IBM 1620
.I 819
.T
Polynomial Evaluation Revised
.I 820
.T
Checking for Loops in Networks
.I 821
.T
Further Remarks on Sampling a Tape File-III
.I 822
.T
Real-Time Programming Specifications
.W
Problems in the implementation of large real-time
applications are treated, and suggested guidelines 
for both program and file specifications are developed.
 The problems delineated also occur in systems 
programming.
.I 823
.T
A Syntactic Description of BC NELLIAC
.I 824
.T
DESCRIPTRAN-Automated Descriptive Geometry*
.W
Descriptive geometry consists of procedures originally
designed to solve 3-space geometry problems 
by graphical constructions and measurement instead of
by computation.  However, in addition to this it 
unifies and simplifies the approach to many such problems.
 When one can call subroutines that compute 
new coordinates that correspond to those obtainable from
the graphical constructions, there is the three-way 
advantage of the approach of descriptive geometry, the
accuracy of computation and the speed of the digital 
computer.  DESCRIPTRAN makes it possible to program
many problems in 3-space with a few statements; it 
consists of 15 subroutines analogous to the procedures of descriptive geometry.
.I 825
.T
PIP: A Photo-Interpretive Program
for the Analysis of Spark-Chamber Data*
.W
An operating computer program that processes
photographically recorded data is described.  
The input to the program consists of spark-chamber photographs
on which tracks of high-energy particles 
are recorded.  The program automatically scans, measures
and performs the preliminary interpretation 
of these photographs.  In continuous operation a processing
rate of 5,000 photographic frames per hour 
is achieved.
.I 826
.T
Remarks on Fortran Subroutines for Time Series Analysis
.I 827
.T
Disk File Sorting
.W
Sorting techniques using an IBM 1401 with
a random access storage device are evaluated.
.I 828
.T
Incompressible flow Network Calculations
.W
A general method for the calculation of flows
and pressures in fluid flow networks is presented. 
 The method is applicable to computer use.
.I 829
.T
The External Language KLIPA For the URAL-2 Digital computer
.I 830
.T
CORC-The Cornell Computing Language
.I 831
.T
Real Error Function, ERF (Algorithm 123)
.I 832
.T
Curve Fitting with Constraints (Algorithm 74)
.I 833
.T
Reduction of a Symmetric Bandmatrix to Triple Diagonal Form
.I 834
.T
Nonrecursive Adaptive Integration (Algorithm 182)
.I 835
.T
Complementary Error Function-Large X (Algorithm 181)
.I 836
.T
Error Function-Large X (Algorithm 180)
.I 837
.T
Incomplete Beta Ratio (Algorithm 179)
.I 838
.T
Direct Search (Algorithm 178)
.I 839
.T
Least Squares Solution with Constraints (Algorithm 177)
.I 840
.T
Least Squares Surface Fit (Algorithm 176)
.I 841
.T
Shuttle Sort (Algorithm 175)
.I 842
.T
A Posteriori Bounds on a Zero of a Polynomial (Algorithm 174)
.I 843
.T
Assign (Algorithm 173)
.I 844
.T
1410 Fortran Edit Feature
.I 845
.T
Another Test Matrix for Determinants and Inverses
.I 846
.T
Self-Inverse Conversion Table
.I 847
.T
A Penny-Matching Program
.W
The logic of a penny-matching program
written for the CSX-1 is described.
.I 848
.T
A Note on Range Transformations for Square Root and Logarithm
.W
There was the germ of an idea in two previous
papers [1,2] which no one seems to have picked 
up in almost five years.  For certain functions it seems
desirable to transform the argument to a short 
range symmetric about 10.1 will give examples of this
usage for the square root and logarithm function 
for both binary and decimal machines.
.I 849
.T
Use of Tree Structures for Processing Files
.W
In data processing problems, files are frequently
used which must both be searched and altered. 
 Binary search techniques are efficient for searching
large files, but the associated file organization 
is not readily adapted to the file alterations.  Conversely,
a chained file allocation permits efficient 
alteration but cannot be searched efficiently. A file
organized into a tree-like structure is discussed, 
and it is shown that such a file may both be searched
and altered with times proportional to slog(s)N, 
where N is the number of file items and s is a parameter
of the tree.  It is also shown that optimizing 
the value of s leads to a search time which is only 25
per cent slower than the binary search.  The tree 
organization employs two data chains and may be considered
to be a compromise between the organizations 
for the binary search and the chained file.  The relation
of the tree organization to multidimensional 
indexing and to the trie structure is also discussed.
.I 850
.T
Conversion, Reconversion and Comparison
Techniques In Variable-Length Sorting
.W
The logic is described for converting highly
variable input records into a format that can 
be easily and efficiently processed by a sorting program.
 The internal record formats are discussed 
in relation to (1) their conversion from input formats,
(2) their reconversion to output formats, and 
(3) comparison techniques between internal formats.
.I 851
.T
Design and Characteristics of a Variable-Length
Record Sort Using New Fixed-Length Record Sorting 
Techniques
.W
This paper describes the application of several
new techniques for sorting fixed-length records 
to the problems of variable-length record sorting. 
The techniques have been implemented on a Sylvania 
9400 computer system with 32,000 fixed-length words
of memory.  Specifically, the techniques sequence 
variable-length records of unrestricted size, produce
long initial strings of data, merge strings of 
data at the power of T-1, where T is the number of work
tapes in a system, and do not restrict the volume 
of input data.
.I 852
.T
A Method of Comparing the Time Requirements of Sorting Methods
.I 853
.T
The COBOL Sort Verb
.I 854
.T
Some Characteristics of Sorting in Computing
Systems Using Random Access Storage Devices 
.W
The substantial differences in characteristics
of random access storage and tape devices dictate 
that concepts and objectives of computer program design
be considered from the viewpoint of the external 
file medium used.  This is particularly true in the
case of sorting.  In a tape-oriented system, the 
major sorting problem is that of minimizing merge time
despite the limited orders of merge possible. 
 In contrast, sorting in a random access-oriented system
encourages the selection of the optimum order 
of merge from many possible orders.  The latter problem
is discussed in this paper, along with criteria 
developed for determining the optimum order of merge according
to the various properties of random access 
storage devices.  Attention is also given to the problem
of key sorting versus record sorting and the 
possibly serious disadvantage of key sorting on a random access system.
.I 855
.T
Organization and Structure of Dataon Disk File
Memory Systems for Efficient Sorting and Other 
Data Processing Programs
.W
An approach to the organization and structure
of data on Bryant Disc File Memory Systems for 
sorting and performing other data processing functions
is presented.  The following areas are covered: 
characteristics of Bryant Disc File Systems on the Bendix
G-20 and RCA 301; two proposed "chaining" structures 
for data; and functions of a Disk File Executive Routine.
 The concepts for sorting and performing file 
maintenance processing using the proposed structure and
executive routine are discussed.  Additionally, 
it is shown that sorting can be accomplished
without the use of disk storage work areas.
.I 856
.T
Sorting with Large Volume, Random Access, Drum Storage
.W
An approach to sorting records is described
using random access drum memory.  The Sort program 
described is designed to be a generalized, self-generating
sort, applicable to a variety of record statements. 
 This description is divided into three parts.  The
first part presents the operating environment; the 
second defines the general solution; the third part
describes the internal sort-merge technique.
.I 857
.T
Sorting Nonredundant Files-Techniques Used in the FACT Compiler
.W
Some typical file structures, including some
called "non-redundant," are examined,and the 
methods used in FACT to sort such files are discussed.
.I 858
.T
A Tape File Merge Pattern Generator
.W
A routine is presented which specifies the
sequence of merge cycles to effect the merging of 
sorted tape files.  The routine is designed to minimize
elapsed computer time by varying the power of 
the merge cycles, so as to use all the available tape
drives, with its characteristic of assigning one 
drive to a single-reel file and two drives to each multiple-reel file.
.I 859
.T
Computer Planned Collates
.I 860
.T
A Comparison Between the Polyphase and Oscillating Sort Techniques
.W
A comparison between the Oscillating and Polyphase
Sort techniques is developed for computer 
systems having from four to ten tape drives.  The basis
for the comparison is the total reading and writing 
required for various number of input strings
and tape drives for the two techniques.
.I 861
.T
Read-Backward Polyphase Sorting
.W
Read-backward Polyphase sorting provides more
efficient use of the tapes available to a sort 
than most other sorting techniques.  Backward Polyphase
produces a continuous merging process from n-1 
tapes where n is the total number of tapes being used in
the sorting process.  Any of the available presorting 
techniques may be used in conjunction with the Polyphase
merge sort provided that the presort has the 
capability of producing both ascending and descending
strings and distributing the strings on the various 
tapes as required by the Polyphase Merge.
.I 862
.T
String Distribution for the Polyphase Sort
.I 863
.T
Multiphase Sorting
.I 864
.T
An Empirical Study of Minimal Storage Sorting
.I 865
.T
Internal and Tape Sorting Using the Replacement-Selection Technique
.W
A general technique for sequencing unsorted
records is presented.  The technique is shown to 
be applicable for the first stage of a generalized sort
program (the formation of initial strings) as 
well as for sorting records within a memory storage (an
internal sort).  It is shown that given N records 
in memory storage, records are sequenced using 1+log2
N tests per record, that initial string lengths 
will average 2N for random input records, and that reading,
writing and processing can be accomplished 
simultaneously if the computer permits such overlap.
.I 866
.T
Sorting on Computers
.I 867
.T
Least Squares Fitting of Planes to Surfaces Using Dynamic Programming
.W
Dynamic programming has recently been used
by Stone, by Bellman and by Gluss to determine the 
closet fit of broken line segments to a curve in an
interval under the constraint that the number of 
segments is fixed.  In the present paper successive
models are developed to extend the method to the 
fitting of broken plane segments to surfaces z=g(x,y) defined
over certain types of subareas of the (x,y)-space. 
 The first model considers a rectangular area, with
the constraint that the plane segments are defined 
over a grid in the (x,y)-space.  It is then shown how
this model may be incorporated into an algorithm 
that provides successive approximations to optimal fits
for any type of closed area.  Finally, applications 
are briefly described.
.I 868
.T
A Suggested Method of Making Fuller Use of Strings in ALGOL 60
.I 869
.T
Term of Magic Square (Algorithm 148)
.I 870
.T
Term of Magic Square (Algorithm 148)
.I 871
.T
PSIF (Algorithm 147)
.I 872
.T
Adaptive Numerical Integration by Simpson's Rule (Algorithm 145)
.I 873
.T
Random (Algorithm 133)
.I 874
.T
Chebyshev Curvefit (Algorithm 91)
.I 875
.T
Incomplete Elliptic Integrals (Algorithm 73)
.I 876
.T
Complete Elliptic Integral (Algorithm 149)
.I 877
.T
Complete Elliptic Integral of the First Kind (Algorithm 55)
.I 878
.T
Reduction of a Matrix Containing Polynomial Elements (Algorithm 170)
.I 879
.T
Newton Interpolation with Forward Divided Differences (Algorithm 169)
.I 880
.T
Newton Interpolation with Backward Divided Differences
.I 881
.T
Calculation of Confluent Divided Differences (Algorithm 167)
.I 882
.T
Monte Carlo (Algorithm 166)
.I 883
.T
Complete Elliptic Integrals (Algorithm 165)
.I 884
.T
Orthogonal Polynomial Least Squares Surface Fit (Algorithm 164)
.I 885
.T
Modified Hankel Function (Algorithm 163)
.I 886
.T
XY-move Plotting (Algorithm 162)
.I 887
.T
Combinatorial of M Things Taken One at a Time,
Two at a Time, Up to N at a Time (Algorithm 161)
.I 888
.T
Algorithm 160 Combinatorial of M Things Taken N at A Time
.I 889
.T
Official Actions and Responses to ALGOL As a Programming Language
.I 890
.T
Selected Definitions 
.W
A selection of the definitions prepared by the
ACM Standards Committee's Subcommittee on Programming 
Terminology is presented for review by the ACM membership.
.I 891
.T
Everyman's Information Retrieval System
.W
The information retrieval problem whose solution
is presented here was posed by a technical 
library with limited bubget and personnel.  The solution,
however, is quite general and is applicable 
to many different types of retrieval problems.  Further,the
method of solution makes it possible for 
many groups who have previously dismissed an information
retrieval program as expensive and difficult 
(from a programming stand-point) to reconsider their position,
for the present solution makes it possible 
to install an information retrieval program in less than
three months, and with relatively little equipment.
.I 892
.T
RECOL-A Retrieval Command Language
.W
An interrogation scheme is described for the
retrieval and manipulation of data file records. 
 The language of the interrogation scheme allows for selecting
file records with the are of logical condition 
statements, defining record classes, associating file
records, editing printed output, and summarizing 
the results of the above operations.  Some examples of
a typical file application and the more significant 
features of a particular machine implementation are given.
.I 893
.T
Significance Arithmetic on a Digital Computer
.W
The 7090 at NYU has been modified to include
a "Significance Mode" of operation which is intended 
to facilitate the identification of significant bits in
the results of floating-point arithmetic operations. 
 The manner in which floating-point arithmetic is handled
in this mode is discussed.  Several numerical 
experiments using this mode are described and comparisons
are made with the ordinary "normalized mode." 
 Examples include power series evaluation, linear equations
solution, determinant evaluation and matrix 
inversion.
.I 894
.T
An Iterative Factorization Technique for Polynomials
.W
An iterative technique is displayed whereby factors
of arbitrary degree can be found for polynomials 
in one variable.  Convergence is shown to occur always
if a certain Jacobian does not vanish and if the 
initial approximation to a factor is near enough to an
actual factor.  The process is simply programmed, 
and preliminary results indicate it to be well adapted
to use with digital computers.  For factors of 
degree two, the technique is similar to that of Bairstow,
the present method being somewhat simpler.
.I 895
.T
A Computational Extension of the Variate Difference Method
.W
Presented here is a computational extension
of the variate difference method as developed by 
G. Tintner [1].
.I 896
.T
Characteristic Values and Vectors of Defective Matrices
.I 897
.T
Note on the Proof of the Non-existence
of a Phrase Structure Grammar for ALGOL 60
.I 898
.T
Random (Algorithm 133)
.I 899
.T
Magic Square (Algorithm 117 & 118)
.I 900
.T
Ancestor (Algorithm 79)
.I 901
.T
Difference Expression Coefficients (Algorithm 79)
.I 902
.T
Determinant (Algorithm 159)
.I 903
.T
Exponentiation of Series (Algorithm 134 )
.I 904
.T
Fourier Series Approximation (Algorithm 157)
.I 905
.T
Algebra of Sets (Algorithm 156)
.I 906
.T
Combination in any Order (Algorithm 155)
.I 907
.T
Combination in Lexicographical Order (Algorithm 154)
.I 908
.T
Test Matrix for Inversion 
.I 909
.T
Arithmetizing Declarations (Corrigendum)
.I 910
.T
Selective Instruction Trap for the 7090
.I 911
.T
A Variant Method of File Searching
.I 912
.T
Addressing an Array Yi in k-Dimensions
by Fortran for Analysis of Variance
.I 913
.T
Neliac
.I 914
.T
Jovial and Its Documentation
.I 915
.T
Documentation of IPL-V
.I 916
.T
FORTRAN
.I 917
.T
COMIT
.I 918
.T
COBOL
.I 919
.T
Documentation Problems: ALGOL 60
.I 920
.T
Toward Better Documentation of Programming Languages
.I 921
.T
Incomplete Elliptic Integrals (Algorithm 73)
.I 922
.T
Multint (Algorithm 32)
.I 923
.T
Gomory (Algorithm 153)
.I 924
.T
Nexcom (Algorithm 152)
.I 925
.T
Location of a Vector in a Lexicographically Ordered ListAlgorithm 151)
.I 926
.T
Syminv2 (Algorithm 150)
.I 927
.T
Linear Programming Applied to Ultraviolet Absorption Spectroscopy
.I 928
.T
Character Manipulation in FORTRAN
.I 929
.T
Glossary Construction
.I 930
.T
Decimal-to-Binary Conversion of Short Fields
.I 931
.T
Systematic Mistake Analysis of Digital Computer Programs
.I 932
.T
Matrix Inversion by Gauss-Jordan Inversion II (Algorithm 120)
.I 933
.T
Magic Squares (Algorithm 117 & 118)
.I 934
.T
Gauss's Method (Algorithm 107)
.I 935
.T
Calculating Primes by Means of GPS (Algorithm)
.I 936
.T
A Set of Test Matrices (Algorithm 52)
.I 937
.T
Inverse of a Finite Segment of the Hilbert Matrix (Algorithm 50)
.I 938
.T
Invert (Algorithm 42)
.I 939
.T
Gamma Function (Algorithm 31)
.I 940
.T
Generating Discrete Random Variables in a Computer
.W
This note is concerned with details of how to
instruct a computer to choose one from many things 
with assigned probabilities.  The method uses a uniform
variable to direct the computer to a memory location; 
if this is done by a sequence of appropriately chosen
conditional probabilities, efficient use of memory 
space and quite fast programs will result.
.I 941
.T
A Recursive Program for the General n-Dimensional Integral
.W
A general program is outlined for n-dimensional
integration with variable limits.  The program 
is of a recursive nature and uses Simpson's rule combined
with repeated bisection to attain the required 
accuracy.  It was developed in the Ferranti Mercury Autocode Scheme.
.I 942
.T
FORTRAN Subroutines for Time Series Analysis
.W
The authors have recently been concerned in a
time-series study that constituted a fairly typical 
piece of applied statistical research, involving extensive
computations on a moderately large quantity 
of data.  Wehave found that the many different numerical
processes that were required could be built 
up almost completely from a small number of basic operations,
and a set of FORTRAN subroutines has been 
written to perform these.  The main purpose of this
note is to describe these subroutines, but since 
the question of general statistical programs is
topical [1], we include some general remarks.
.I 943
.T
Terms Frequently Combined in Problem Description
.I 944
.T
Storage and Search Properties of a Tree-Organized Memory System
.W
A memory with list properties [1] may be used
to construct numeric, alphabetic or alphanumeric 
trees.  Such trees have information storage and retrieval
properties applicable to problems involving 
large quantities of data or to problems where the quantity,
word length and distribution of stored information 
is not known a priori, or changes rapidly during the processing.
 The purpose of this paper is to examine 
the storage and search properties of a tree-organized
storage system assuming that a memory possessing 
certain list properties is available.  Of prime interest
is the application where a symbol table, dictionary 
or similar file is to be stored and searched.
.I 945
.T
Arithmetizing Declarations: An Application to COBOL
.I 946
.T
Suggestions on ALGOL 60 (ROME) Issues - A Report by the American
Standards Association Subcommittee X3.4.2
.I 947
.T
Supplement to the ALGOL 60 Report
.I 948
.T
Note on the Use of Procedures 
.I 949
.T
Integer and Signed Constants in ALGOL
.W
A few remarks are given on the relations between
syntax and semantics in the programming languages. 
 The aim is to point out that, if it is true that the grammar
of a context-free language should be conceived 
not only as a strings-generating device but also as a
method for expressing a meaning, then the grammar 
of ALGOL is open to some criticism.
.I 950
.T
Parallel Methods for Integrating Ordinary Differential Equations
.W
This paper is dedicated to the proposition that,
in order to take full advantage for real-time 
computations of highly parallel computers as can be
expected to be available in the near future, much 
of numerical analysis will have to be recast in a more
"parallel" form.  By this is meant that serial 
algorithms ought to be replaced by algorithm which
consist of several subtasks which can be computed 
without knowledge of the results of the other subtasks. 
As an example, a method is proposed for "parallelizing" 
the numerical integration of an ordinary differential
equation, which process, by all standard methods, 
is entirely serial.
.I 951
.T
Rational Chebyshev Approximations
to the Bessel Function Integrals Kis(x)
.W
The second Remes algorithm is used to approximate
the integrals Kis by rational functions.
 The related coefficients for the approximations of
Ki1, Ki2, Ki3 are given for different precisions.
.I 952
.T
Another use of FORTRAN II Chaining
.I 953
.T
Scanning Text with a 1401
.I 954
.T
A Note on the Calculation of Probabilities in an F-Distribution
.I 955
.T
A Class of Matrices to Test Inversion Procedures
.I 956
.T
A Family of Test Matrices
.I 957
.T
Method for Partial Rewriting of Magnetic Tape
.I 958
.T
A Case of too Much Precision
.I 959
.T
Mark Sense and Port-A-Punch Programming Inputs
.I 960
.T
Curve Fitting with Format Fortran
.I 961
.T
Limited Bit Manipulation Using FORTRAN II
.W
Techniques are developed for manipulating bits
using only FORTRAN II.  These techniques allow 
individual bits to be tested, certain fields to be
shifted, and numbers coded in BCD to be converted 
to Binary.
.I 962
.T
Double-Precision Squares Root for The CDC-3600
.W
In January of 1960, the late Hans J. Maehly completed
a summary of approximations to the elementary 
functions for the CDC-1604 computer.  The approximations
and techniques suggested by Maehly are equally 
applicable to the second large computer in the CDC line,
the 3600.  Unlike the 1604, however, the 3600 
has built-in double-precision floating-point arithmetic.
 The present work, largely inspired by the successes 
of Maehly and his associates, concerns the extension of one
of Maehly's ideas to a double-precision subroutine 
for the 3600.
.I 963
.T
Relative Effects of Central Processor and Input-Output
Speeds Upon Throughput on the Large Computer
.W
Presented in this paper is a technique for
determining the relative effects of the internal 
speed of the computer and the speed of the input-output
units upon the overall speed of the system. Equations 
are derived which permit the determination of these
effects from hardware usage measurements.
.I 964
.T
Mechanization of Tedious Algebra-the
e Coefficients of Theoretical Chemistry
.W
A table of formulas for certain integrals
involving Legendre functions has been constructed 
mechanically by a program which performed algebraic operations.
 The formulas are all rational algebraic 
expressions in a single variable and were constructed
by a recurrence procedure.  They are of interest 
in molecular quantum chemistry.  Trivial coding techniques
were used to write the relevant programs in 
FORTRAN.  The results were photo composed on a Photon
S-560 system, that was controlled by tapes which 
were punched directly from the computer output, so
avoiding manual keyboarding, transcription errors 
and keyboarded correction.
.I 965
.T
Greatest Common Divisor (Algorithm 237 [A1])
.I 966
.T
Evaluation of Determinant (Algorithm 224 [F3])
.I 967
.T
Complementary Error Function (Algorithm 181 [S15])
.I 968
.T
Radical-Inverse Quasi-Random Point Sequence (Algorithm 247 [G5])
.I 969
.T
Graycode (Algorithm 246 [Z])
.I 970
.T
Treesort 3 (Algorithm [M1])
.I 971
.T
Time Sharing in a Traffic Control Program
.W
The Toronto traffic signal control system consists
of a variety of logically distinct computer 
programs, all competing for machine time.  To satisfy
these demands, a time-sharing program has been 
written whose purpose is to execute, in the order of a
predefined priority, the various subprograms within 
the real-time system.  In this paper the more interesting
aspects of the time-sharing program are outlined.
.I 972
.T
An Executive System Implemented as a Finite-State Automaton
.W
The 473L command and control system used by
the Air Force permits many operators to access 
large data files through the use of a computer.  The man-machine
interface is satisfied by several communication 
consoles from which operators may enter queries and
view replies.  A data link permits remote stations 
to send messages, status reports and inventories directly
to the computer.  The information received 
over the on-line data link is used to update the data files
which are stored on disk.  The 473L programming 
system is divided into an Executive Control Program and
five components with different processing priorities. 
 These priorities permit the system to be most sensitive
to the console inputs and permit the operators 
at all the consoles to time share the central processor.
 The Executive Control Program provides for 
the orderly transitions of control among the programming
system components. The major emphasis of the 
paper is on the technique of using the definition of a
finite-state automaton for organizing the Executive 
Control Program.
.I 973
.T
Estimation of Heart Parameters Using Skin Potential Measurements
.W
A fundamental problem of vector cardiography
is the estimation of the state of the heart on 
the basis of skin potential measurements.  A mathematical
model relating ventricular dipoles to surface 
potentials is sketched.  Then it is shown that the inverse
problem-that of determining electrical heart 
parameters on the basis of skin potential measurements-may
be viewed as a nonlinear multipoint boundary 
value problem.  A feasible solution, employing quasilinearization
and high-speed digital computers, is 
given.
.I 974
.T
A Technique for Reading Gapless Tapes Makes Electrocardiograph
Analysis Feasible on the IBM 7090 
.W
To study arrhythmias and higher frequency
components of the electrocardiogram, long series 
of patient heart cycles must be examined before valid
comparison of different heart beats can be made. 
A technique is presented for the automatic analysis
of long series heart cycles via a digital computer.
.I 975
.T
The New Program of Work for the International
Standard Vocabulary in Computers and Information
Processing
.I 976
.T
Fresnel Integrals (Algorithm 213 [S20])
.I 977
.T
Conversions Between Calendar Date and
Julian Day Number (Algorithm 199 [Z])
.I 978
.T
Fresnel Integrals (Algorithm 244 [S20])
.I 979
.T
Logarithm of a Complex Number (Algorithm 243 [B3])
.I 980
.T
Multiple-Precision Arithmetic and the Exact
Calculation of the 3-j, 6-j and 9-j Symbols
.W
Described in this paper is a system of general-purpose
multiple-precision fixed-point routines 
and their use in subroutines which calculate exactly
the quantum-mechanical 3-j, 6-j and 9-j symbols 
of large arguments.
.I 981
.T
Rounding Problems in Commercial Data Processing
.W
A common requirement in commercial data processing
is that the sum of a set of numbers, rounded 
in a generally understood manner, be equal to the sum
of the numbers rounded individually.  Four rounding 
procedures are described to accomplish this.  The particular
procedure that is appropriate depends upon 
whether the numbers being accumulated can vary in sign,
whether their sum can vary in sign, and whether 
the last number being summed can be recognized as such prior to its rounding.
.I 982
.T
An Inductive Approach to Language Translation
.W
The possibility of natural language translation
by means of fixed operations on example translations 
is considered.  The conception of sentence translation
which motivates the work is informally presented, 
and the measurement of physical similarity in pairs of
strings is discussed, a notion which plays a central 
role in the proposed type of translator.  Experimental
evidence is presented in support of the premise 
upon which this conception is based.
.I 983
.T
Take-up reels for One-Inch Perforated Tape for
Information Interchange (Proposed American Standard)
.I 984
.T
Report on Input-Output Procedures for ALGOL 60 (IFIP)
.I 985
.T
Report on SUBSET ALGOL 60 (IFIP)
.I 986
.T
Proposed Amendment to Proposed American Standard
on Specification for General-Purpose Paper Cards 
for Information Processing
.I 987
.T
FORTRAN vs. Basic FORTRAN (A Programming Language
for Information Processing on Automatic Data 
Processing Systems)
.I 988
.T
History and Summary of FORTRAN Standardization Development for the ASA
.I 989
.T
A Method of Syntax Specification
.I 990
.T
Constraint-Type Statements in Programming Languages
.W
A proposal is made for including in a programming
language statements which imply relations 
between variables but which are not explicit assignment
statements.  The compiler sets up a Newtonian 
iteration making use for the purpose of a routine for formal differentiation.
.I 991
.T
Gamma Function with Controller Accuracy (Algorithm 225 [S14])
.I 992
.T
Gamma Function (Algorithm 221 [S14])
.I 993
.T
Kutta Merson (Algorithm 218 [D2])
.I 994
.T
Stringsort (Algorithm 207 [M1])
.I 995
.T
Steep1 (Algorithm 203 [E4])
.I 996
.T
Permutations of a Set with Repetitions (Algorithm 242 [G6])
.I 997
.T
Patent Protection of Computer Programs
.I 998
.T
Computer Programs are Patentable
.I 999
.T
Joint Inventorship of Computers
.I 1000
.T
Computer Patent Disclosures
.I 1001
.T
Copyright Aspects of Computer Usage
.W
This paper is concerned with the question of
what constitutes infringement of a copyright on 
a book or other nondramatic literary work when the work
is fed into a computer and is indexed, analyzed, 
partially reprinted, or otherwise utilized by the computer
to produce eye-readable output.  The question 
of copyrightability of programs and infringement of copyrights
on programs is also discussed.  The paper 
is directed primarily to a discussion of the present
law.  Some aspects of the proposed new copyright 
law are also included.  General recommendations are
made with respect to the proposed revision of the 
copyright law.
.I 1002
.T
A Rapid Method for Digital Filtering
.W
Since much of the computer time spent in time-series
analysis is used for multiplications, 
a minimum multiplication method was devised for digital
filtering, with the expectation that it would 
be useful in the on line, real-time analysis of biological
data.  The filters are constructed from a succession 
of readily analyzable components in a manner that facilitates
cascading.  The repertoire of frequency 
response curves includes relatively good low-pass and
band-pass designs.  Programs are available for 
implementing both the synthesis of these filters, and
their application on computers whose assemblers 
allow the definition of recursive macros.
.I 1003
.T
A Computer Analysis Method For Thermal Diffusion in Biochemical Systems
.W
In the thermal detection of rapid biochemical
reactions it is necessary to correct the temperature 
data for transient heat conduction losses in a cylindrical
calorimeter.  To handle the complexities arising 
from varying thermal-relaxation times of concentric insulating
layers, a computer program was developed 
which gives the temperature distribution of the system
as a function of radius and time.  This distribution 
is corrected at each step by a subroutine which calculates
the instantaneous chemical state of there 
action, as well as the heat produced by this reaction.
 The program is based on a direct statement of 
Fourier's law of heat conduction and the chemical rate
equation to provide a "bookkeeping law" to follow 
the reactants and the flow of heat packets, in such a
way that the computer continually stores the heat 
distribution.  A computer analysis method is here regarded
as one in which the physical laws of a process 
are used explicitly in the program. Usually this results
in by passing much of the mathematical procedures 
conventionally used.  The program was tested against
some known exact solutions of the heat equation 
and gave identical results, and compared well with experimental
data of a known biochemical reaction. 
 The construction of computer programs based on the direct
statement of the physical laws is a principle 
of general applicability which has been applied
to several other physical phenomena.
.I 1004
.T
Arctangent (Algorithm [B1])
.I 1005
.T
Coordinates on an Ellipsoid (Algorithm 240 [Z])
.I 1006
.T
A Storage Allocation and Reference Structure
.W
A method is proposed and discussed which allows
a subscripted-variable capability (in the FORTRAN 
sense) to be added to AUTOCODER-Type assembly systems.
.I 1007
.T
Extension of Existing Compilers By Sophisticated Use of Macros
.W
A description is presented of an application
in which macros and string concatenation were 
employed to add a new facility to BELFAP.
.I 1008
.T
Scheduling Meetings with a Computer
.W
Computer scheduling of papers as it was developed
for the 1960 meeting of the Federation of 
American Societies for Experimental Biology (FASEB) is described.
 The FASEB meeting is the largest scientific 
meeting held in the United States each year.  The technique
developed for FASEB can be applied to schedule 
any meeting with parallel sessions.
.I 1009
.T
Solution of Combinatorial Problems Using Generating
Functions on a Variable-Field Computer
.W
The utility of generating functions in solving
combinatorial problems is discussed.  Particular 
implementation results are presented and evaluated.
.I 1010
.T
A Multiuser Computation Facility for Education and Research
.W
Present-day computing facilities are limited
in their value for scientific research by inability 
to interact strongly with users.  The full power of a
research computing instrument should be available 
at many terminals that give each user the ability to generate,
correct and operate any procedure he wishes, 
either simple or complex.  Implementation is described
for a small-scale multiuser computer system that 
permits several users to work independently with the
machine, and to obtain satisfactory response using 
typewriter communication.
.I 1011
.T
Logarithm of a Complex Number (Algorithm 48 [B3])
.I 1012
.T
Formal Parsing Systems
.W
Automatic syntactic analysis has recently become
important for both natural language data processing 
and syntax-directed compilers.  A formal parsing system
G = (V,u,T,R) consists of two finite disjoint 
vocabularies, V and T, a many-many map, u, from V onto
T, and a recursive set R of strings in T called 
syntactic sentence classes.  Every program for automatic
syntactic analysis determines a formal parsing 
system.  A directed production analyzer (I,T,X,p) is a
nondeterministic pushdown-store machine with internal 
vocabulary I, input vocabulary T, and all productions
of p in the form:  (Z,a) -> aY1 ... Ym where  Z, 
Yi are elements of the set I and a is an element of the
set T.  Every context-free language can be analyzed 
by a directed production analyzer.  The Kuno-Oettinger
multiple-path syntactic analyzer for English is 
a concrete example of a directed production analyzer
and of a working parsing algorithm.  The connection 
between structures assigned by the analyzer and those of
a conventional phrase structure grammar is examined 
in this paper.
.I 1013
.T
Final Examination Scheduling
.W
A method for scheduling final examinations
to yield a minimal number of student conflicts is 
described.  The "minimization" is achieved by repetitively
evaluating a nonlinear set of equations.  
Imbeded in the process is a random or Monte Carlo selection
of assignments.  As in such heuristic techniques, 
the solution may not be optimum and many solutions
may be found which yield locally minimal results. 
 Computer programs are described and empirical results given.
.I 1014
.T
Machine Controls for Analysis of Variance
.W
A major problem in using the analysis of variance,
as the number of factors increases, is the 
exponential rise in the number of interactions.  Even
though the experimenter may not be interested in 
these interactions it is impossible to ignore them in
most experimental designs because of the problem 
of getting error terms.  It is natural therefore to look
to the computer to handle the bulk of work involved 
in computing the interactions.  A program device
to get the computer to do this is described.
.I 1015
.T
Near-Minimax Polynomial Approximations and Partitioning of Intervals
.W
A method of near-minimax polynomial approximation
is described.  As a by-product, this method 
provides a formula for an estimate of the maximum error
associated with a given degree of approximation. 
 Using this formula, a partitioning algorithm is obtained
for dividing a basic interval into subintervals 
for which approximations of equal degree give equal maximum error.
.I 1016
.T
Interchangcable Perforated Tape Variable Block
Formats for Positioning and Straight Cut (RS-273) 
and Contouring and Contouring/Positioning (RS-274) Numerically
Controlled Machine Tools (Proposed American 
Standards)
.I 1017
.T
Comments on Bit-Sequencing of the ASCII
in Serial-by-Bit Data Transmission
.I 1018
.T
Gauss (Algorithm 209 [S15])
.I 1019
.T
XY move Plotting (Algorithm 162 [J6])
.I 1020
.T
Free Field Read (Algorithm 239 [I5])
.I 1021
.T
Conjugate Gradient Method (Algorithm 238 [F4])
.I 1022
.T
Greatest Common Divisor (Algorithm 237 [A1])
.I 1023
.T
Bessel Functions of the First Kind (Algorithm 236 [S17])
.I 1024
.T
A Note on the Formation of Free List
.I 1025
.T
A Method of Syntax-Checking ALGOL 60
.W
A syntax checker was designed based on the syntax
of ALGOL as described in the ALGOL 60 Report 
[Communications of the ACM, May, 1960].  Since the definition
of the elements of the language is recursive 
it seemed most desirable to design the syntax checker
as a set of mutually recursive processors tied 
together by subroutines which perform certain bookkeeping
functions.  Because of the recursive nature 
of the language and of the syntax checker the problem
of recovery after an error required much attention. 
 A method was devised which permits most programs
to be checked completely despite errors.
.I 1026
.T
Divide-and-Correct Methods for Multiple Precision Division
.W
A division problem is defined and notation
to relate it to the problem of multiple precision 
operation in a digital computer is introduced.  A basic
divide-and-correct method for multiple precision 
division is formulated and its known properties briefly
reviewed.  Of particular interest is the fact 
that the method produces at each step a set of precisely
three estimates for the desired result, one 
of which is exact.
.I 1027
.T
An Alternate Checksum Method
.I 1028
.T
Investigation of a New Analytical Method
for Numerical Derivative Evaluation
.W
A recently proposed analytical approach to
numerical derivative evaluation is discussed.  The 
technique is shown to be both accurate and easy to
apply, though certain indicated modifications are 
required.  Its use should greatly facilitate the writing
and debugging of programs requiring derivatives 
of highly complex functions.
.I 1029
.T
A Simple Automatic Derivative Evaluation Program
.W
A procedure for automatic evaluation of total/partial
derivatives of arbitrary algebraic functions 
is presented.  The technique permits computation of
numerical values of derivatives without developing 
analytical expressions for the derivatives.  The key
to the method is the decomposition of the given 
function, by introduction of intermediate variables,
into a series of elementary functional steps.  A 
library of elementary function subroutines is provided
for the automatic evaluation and differentiation 
of these new variables.  The final step in this process
produces the desired function's derivative.  
The main feature of this approach is its simplicity.
 It can be used as a quick-reaction tool where the 
derivation of analytical derivatives is laborious and
also as a debugging tool for programs which contain 
derivatives.
.I 1030
.T
Techniques for the Simulation of Computer Logic
.W
The simulation of a digital computer is an
integral part of most computer design automation 
systems.  The evaluation of the Boolean functions which
characterize the computer being simulated constitutes 
one major portion of a simulation system.  Four general
procedural classes for evaluating these functions 
are defined.  Toward greatly increased efficiency of a simulation
system, methods are presented for simultaneously 
evaluating many functions for one set of values of the
variables,and for evaluating simultaneously one 
function for many sets of values for the variables.
.I 1031
.T
A Note on Starting the Newton-Raphson Method
.W
Determination of a suitable initial estimate
for a root of an equation f(x) = 0 by means of 
computing the roots of a sequence of related equations is described.
.I 1032
.T
Theoretical Considerations in Information Retrieval Systems
.W
Information storage and retrieval systems are composed
of three major components: (a) identification 
of information and tagging it for effective retrieval,
(b) searching strategy, how to enter the file 
to circumvent the scanning of nonrelevant material, and
(c) file organization to make access to information 
efficient.  For identification of information the paper
suggests that a metalanguage (recently discussed 
in a paper by Goffman, Verhoeff and Belzer) associated
with an object language be used.  For searching 
strategy, a linear model for an evaluation function
of relevancy is developed which rewards the system 
for retrieving relevant documents and not retrieving
the nonrelevant, and penalizes the system for the 
escaped relevant documents and false drops.  The inadequacies
of a linear model are indicated.  Two approaches 
to file organization are discussed.  One is self-organization
of the file based on its history and past 
performance, and the second is a self-generating subset
of the file with a high probability of being 
relevant.
.I 1033
.T
Experimental Personalized Array Translator System
.W
A system designed for intimate man-machine
interaction in a general-purpose problem-solving 
environment is experimentally operational.  The system
utilizers an array-oriented symbolic source language 
containing powerful statement types.  These include numeric,
Boolean, relational and selection operators 
on operands which can be entire arrays.  The system also
permits simple specification of test and argument 
arrays in single statements.  The completely symbolic
operating system includes display and entry of 
program and data.  Sequence control is aided by an interrupt
switch which allows the user to interact 
with the program during execution. In addition to normal
stored program sequencing, the system provides 
trace options and the ability to enter any statement
for immediate execution.  Present implementation 
of the system is with an interpretive translator on an IBM 1620 computer.
.I 1034
.T
Autosate
.W
An automated data system analysis technique is
described. The technique is designed to alleviate 
some of the principal problems that beset current analysis-large
data workloads, long span of time between 
project inception and system operational date, the lack
of explicit directions for conducting data system 
analysis and using the results, and the lack of a technique
to control data system changes throughout 
its lifetime. The analysis is geared to determining workload,
relationships and storage characteristics 
of documents in the information network automatically.
.I 1035
.T
Characteristics of the FORTRAN CEP Language
.W
The FORTRAN CEP languages differs from FORTRAN
II mainly because: (1) it extends the variety 
of the modes for real quantities; (2) it allows suitable
mixtures, in an input/output list or in an expression, 
of quantities that occur under different modes; (3)
it makes it possible to address a greater number 
of input/output equipment; and (4) it removes the restrictions
on the complexity of the list of quantities 
to be transmitted between the magnetic core memory
and the drum or the magnetic tape units.
.I 1036
.T
Remark on Further Generalization of ALGOL
.I 1037
.T
Reduction of a Matrix Containing Polynomial
Elements (Algorithm 170 [F3])
.I 1038
.T
Crout with Equilibration and Iteration (Algorithm 135 [F4])
.I 1039
.T
Summation of Fourier Series (Algorithm 128 [C6])
.I 1040
.T
Romberg Integration(Algorithm 60 [D1])
.I 1041
.T
Random Permutation (Algorithm 235 [G6])
.I 1042
.T
Poisson-Charlier Polynomials (Algorithm 234 [S23])
.I 1043
.T
Talk-A High-Level Source Language Debugging
Technique With Real-Time Data Extraction
.W
TALK, meaning Take A Look, is a debugging technique
which aids substantially in debugging complex 
real-time programming systems by interrupting the users
program at desired points to extract previously 
specified data.  The extracted data is later edited,
listing the associated data with its high-level 
source language identification.
.I 1044
.T
An Automatic Loader for Subroutine Nests
.W
A method for automatic loading of library subroutines,
which can be adapted to operate in conjunction 
with any conventional two-pass assembler is described.
 The method is specifically designed to cope with 
a nested library structure.
.I 1045
.T
Programming Analysis of Variance by Sequences
of Operators and Isomorphic Mappings
.W
A special operator calculus developed by Hartley
in 1956 together with a new mapping scheme 
has been found to be efficient in programming analysis
of variance for multifactor experiments. The operator 
calculus and the mapping scheme are described in detail.
.I 1046
.T
A Compiler-Building System Developed by Brooker and Morris
.W
In a number of articles published during the
past two years, R. A. Brooker and D. Morris (joined 
by J.S. Rohl in their most recent paper have presented
a very interesting programming system that they 
have developed for the Ferranti Atlas computer.  The
present paper describes some of the major features 
of their system. it expands on some points that the original
authors cover briefly, and treats only very 
lightly some topics to which they devote considerable space.
 The purpose of this paper is purely expository. 
 Except in some very small details, and in some comments,
it does not intentionally depart from or add 
to the material published in the listed references.
.I 1047
.T
Generation of Test Matrices by Similarity Transformations
.W
A method for obtaining test matrices with
a prescribed distribution of characteristic roots 
is given.  The process consists of using particularly
simple similarity transformations to generate full 
matrices from canonical forms.  The matrices generated
also have known characteristic vectors, inverses 
and determinants.
.I 1048
.T
Approximate Solution of Axially Symmetric Problems
.W
A variety of physical problems in such diverse
fields as electrostatic  field theory, heat 
and ideal fluid flow, and stress concentration theory
reduce, under the assumption of axial symmetry, 
to the study of an elliptic partial differential equation.
 Dirichlet-type problems associated with this 
equation are studied on regions whose boundaries include
a nondegenerate portion of the x-axis and exceedingly 
accurate numerical methods are given for approximating solutions.
.I 1049
.T
Numerical Solution of Nonlinear Two-Point
Boundary Problems by Finite Difference Methods
.W
Solution of nonlinear two-point boundary-value
problems is often an extremely difficult task. 
 Quite apart from questions of reality and uniqueness,
there is no established numerical technique for 
this problem.  At present, shooting techniques are the
easiest method of attacking these problems.  When 
these fail, the more difficult method of finite differences
can often be used to obtain a solution.  
This paper gives examples and discusses the finite difference
method for non-linear two-point boundary-value 
problems.
.I 1050
.T
A Parts Breakdown Technique Using List Structures
.W
List structured parts breakdown is proposed
and discussed.  Implementation facts are presented 
on operating program using these techniques.
.I 1051
.T
Multiword List Items
.W
The list concept as originally proposed by
Newell, Simon and Shaw specified single computer 
words as elements of a list.  This report describes the
use of two or more consecutive words as one element. 
 Such use results in a considerable saving in both the
space required to hold a given amount of data, 
and in the execution time required to perform a given
process on the data.  Following a brief description 
of standard list structures with single-word items, the
multiword items are introduced.  Then variable-length 
items are described, along with the corresponding space-utilization
problems.  Finally, several examples 
are given to illustrate the use of multiword lists. This
paper attempts to draw together various recent 
papers which have applied some of these concepts in different
ways, and indicate how they relate to the 
more general problems.
.I 1052
.T
Reducing Truncation Errors by Programming
.W
In accumulating a sum such as in a numerical
integration with a large number of intervals, 
the sum itself becomes much larger than the individual
addends.  This may produce a less accurate sum 
as the number of intervals is increased.  Separate variables
can be established as accumulators to hold 
partial sums within various distinct intervals.  Thus,
the extensive successive truncations are eliminated.
.I 1053
.T
Design and Implementation of a General-Purpose Input Routine
.W
A general-purpose input routine is discussed
and advocated for FORTRAN.  The philosophy of 
such programs is examined and exemplified.
.I 1054
.T
Gauss-Seidel (Algorithm 220 )
.I 1055
.T
q-Bessel Functions In(t) (Algorithm 214)
.I 1056
.T
Shellsort (Algorithm 201)
.I 1057
.T
Critical Path Scheduling (Algorithm 40)
.I 1058
.T
Simpson's Rule for Multiple Integration (Algorithm 233)
.I 1059
.T
Heapsort (Algorithm 232)
.I 1060
.T
Matrix Inversion (Algorithm 231)
.I 1061
.T
Matrix Permutation (Algorithm 230)
.I 1062
.T
Symbol Manipulation in FORTRAN-SASP I Subroutines
.W
A set of subroutines for use in FORTRAN are
described whose purpose is to synthesize output 
strings from (i) input strings which have been analyzed
by the SHADOW general syntactic analysis subroutine 
reported earlier, and/or (ii) packed BCD strings formed
in any way.  Function-type subroutines are included 
for intermediate manipulations, which are performed
on the strings which are stored in an abbreviated 
internal representation.  The automatic way in which
an internal representation for each newly created 
substring is stored sequentially in a block of common
storage, and the manner in which a storage block 
is dynamically allocated for that purpose, are discussed.
.I 1063
.T
One-Inch Perforated Paper Tape for Information
Interchange (Proposed American Standard)
.I 1064
.T
Perforated Tape Code for Information
Interchange (Proposed American Standard)
.I 1065
.T
Bit Sequencing of the American Standard Code for
Information Interchange (ASCII) in Serial-by-Bit 
Data Transmission (Proposed American Standard)
.I 1066
.T
Growing Applications of Linear Programming
.W
Use of linear programming models has grown so
extensively in recent years that the whole concept 
for organizing a computer code has undergone a radical
change.  It no longer is adequate merely to reduce 
a mathematical algorithm (i.e. the simplex method) to
a computer code.  An advanced code must cope with 
such a variety of situations that the respective computer
subprograms must be organized into an integrated 
system.  Emphasis in this paper is devoted to the underlying
principles upon which future linear programming 
systems must be based.  These viewpoints are influenced
by the new demands that applications within the 
petroleum industry are placing on such systems.  Some
of the components of such a system are: translation 
of problem statement in terms of basic data to linear
programming matrix coefficients, data transmission 
for direct computer entry, data file at the computer center,
data processing and editing prior to solving 
the simplex algorithm, an efficient and reliable code
for solving the above-mentioned algorithm, and 
flexible means for summarizing the results.
.I 1067
.T
Picture Generation With a Standard Line Printer
.W
A method is described for producing gray-toned
pictures on a line printer by utilizing the 
different degrees of blackness of standard print characters.
 Gray scales with 17, 32 and 64 levels have 
been devised.  Scanned images of blood cells are used to display the technique.
.I 1068
.T
A FORTRAN II Load-Time-Saver
.I 1069
.T
A Method for Comparing the Internal Operating Speeds of Computers
.I 1070
.T
Expand, A System for Input Card Replication
.I 1071
.T
Computer-Usage Accounting for Generalized Time-Sharing Systems
.W
The current development of general time-sharing
systems requires a revision of accounting procedures 
for computer usage. Since time-sharing system users
operate concurrently, it is necessary to be more 
precise as to the amount of computer time and storage
space that a user actually utilizes.  The various 
cost factors which should be considered for computer usage
accounting in generalized time-sharing systems 
are discussed.
.I 1072
.T
An Improved Equivalence Algorithm
.W
An algorithm for assigning storage on the basis
of EQUIVALENCE, DIMENSION and COMMON declarations 
is presented.  The algorithm is based on a tree structure,
and has reduced computation time by 40 percent 
over a previously published algorithm by identifying all
equivalence classes with one scan of the EQUIVALENCE 
declarations.  The method is applicable in any problem
in which it is necessary to identify equivalence 
classes, given the element pairs defining the equivalence relation.
.I 1073
.T
A Fast Procedure for Generating Exponential Random Variables
.W
A very fast method for generating exponential
random variables in a digital computer is outlined.
.I 1074
.T
Shanks (Algorithm 215)
.I 1075
.T
Shuttlesort (Algorithm 175)
.I 1076
.T
Multiple Integration (Algorithm 146)
.I 1077
.T
Chebyshev Curve Fit (Algorithm 91)
.I 1078
.T
Elementary Functions by Continued Fractions (Algorithm 229)
.I 1079
.T
Q-Bessel Functions (Algorithm 228)
.I 1080
.T
Chebyshev Polynomial Coefficients (Algorithm 227)
.I 1081
.T
Normal Distribution Function (Algorithm 226)
.I 1082
.T
Gamma Function with Controlled Accuracy (Algorithm 225)
.I 1083
.T
An Experiment in a User-Oriented Computer System
.W
A version of a software-hardware system for
the purpose of facilitating the programming and 
analysis of well-formulated problems is described.  A modified
Flexowriter is used to generate computer-acceptable 
input when equations or computable requests are typed
in much the same manner as they would appear in 
conventional mathematical texts.  The typing and language
rules are quite flexible and unrestrictive. 
 While the compiler part is efficient, the system as
a whole has much broader aspects as a tool for the 
study of problem solving and self-teaching systems.
.I 1084
.T
On Declaring Arbitrarily Coded Alphabets
.W
The inability of existing programming languages
to handle character strings from more than 
one or two alphabets is mentioned and a scheme for declaring
additional alphabets is proposed.  The scheme 
provides for: many-to-one encodings, right or left
justification, collating sequences different from 
numeric sequence, variations in character size (number
of bits.) from alphabet to alphabet, and arbitrary 
source-language character representation.
.I 1085
.T
Specification for General-Purpose Paper Cards for
Information Processing (Proposed American Standard)
.I 1086
.T
A Proposal for Input-Output Conventions in ALGOL
60-A Report of the Subcommittee on ALGOL of 
the ACM Programming Language Committee
.I 1087
.T
Problems in Automatic Abstracting
.W
A variety of problems concerning the design
and operation of an automatic abstracting system 
are discussed.  The purpose is to a general view of
several major problem areas.  No attempt is made 
to discuss details or to indicate preferences among alternative solutions.
.I 1088
.T
Menu Planning by Computer
.W
A computer code has been developed which plans
menus by finding minimum cost combinations of 
menu items such that the daily dietary, gastronomic
and production requirements can be satisfied for 
a sequence of days.  A fast, special integer programming
algorithm is described which approximates the 
theoretical solution to the problem.  If necessary, any
menu can be changed on-line and then post-optimized. 
 Up to 30 percent saving on food cost is possible. 
A FORTRAN program for the IBM 1410 is available on 
request.  A considerable amount of data processing
must precede the implementation of the system.
.I 1089
.T
Designing a Computer Center
.I 1090
.T
Incomplete Beta Function Ratios (Algorithm 222)
.I 1091
.T
Hypergeometric and Confluent Hypergeometric (Algorithm 191 & 192)
.I 1092
.T
Nonrecursive Adaptive Integration (Algorithm 182)
.I 1093
.T
Evaluation of Determinant (Algorithm 224)
.I 1094
.T
Prime Twins (Algorithm 223)
.I 1095
.T
Decimal Tables of Binary Coded Tables
.I 1096
.T
On Avoiding Matrix Reversals Between 7090 FORTRAN II and 7090 FORTRAN IV
.I 1097
.T
An Algorithm for Converting Integers from Base A to Base B
.W
A little known, simple algorithm for integer
conversion between number systems is presented 
and proved.
.I 1098
.T
A Comparison of List-Processing Computer Languages
(Including a Detailed Comparison of COMIT, 
IPL-V, LISP 1.5, and SLIP)
.W
A detailed comparison is presented of COMIT,
IPL-V, LISP 1.5 and SLIP - four well-known computer 
programming languages which, among them, exhibit all the
principal characteristics of existing list-processing 
languages.  Important common features of list-processing
languages are reviewed: forms of data structures 
which are manipulated, necessity for dynamic allocation
of storage, use of pushdown stores, and use of 
recursive operations.  Principal differences between the
four languages under consideration are detailed: 
representations of data, both by the programmer and within
the machine; methods for storage allocation; 
programming formalisms and special processes available,
including arithmetic facilities; and usability 
in terms of availability, documentation, learning aids
and debugging facilities.  A rough comparison 
shows that all the languages discussed have approximately
the same speed.  Finally, the authors give 
some heuristics to aid in the selection of one of these
languages for use in particular problem applications, 
concluding that no one of the languages considered is
distinctly superior in all possible list-processing 
applications.
.I 1099
.T
Professional Computer Work for the Blind
.W
Developments in computer technology have opened
new professional opportunities for the intelligent 
blind.  Since there are few if any occupations in which the
blind can participate without serious disadvantage, 
the opportunities offered them to gain entrance into
various occupations through computer use including 
that of programmer, is important for future rehabilitation
planning. Also of immediate interest is the 
fact that the blind may be especially suited for programming
work.  Because of intense training in and 
constant experience with locating objects in the unseen
environment and also because of superbly trained 
memory, the blind brings to the work of programming skills
which the sighted has had little need to acquire. 
 These qualifications should result in fewer debugging
problems and make the blind a valuable addition 
to any systems group.  Before the blind could become a
serious professional, a number of aids and techniques 
had to be developed that can mediate between machines
and programmer.  This paper describes the techniques 
and aids which were designed by the staff of the Medical
Computing Center of the University of Cincinnati 
College of Medicine.
.I 1100
.T
Status of Computer Sciences Curricula in Colleges and Universities
.I 1101
.T
The Place of Logical Design and Switching
Theory In The Computer Curriculum
.I 1102
.T
Mechanical Languages: A Course Specification
.I 1103
.T
Logic for the Computer Sciences 
.I 1104
.T
An Undergraduate Curriculum in Numerical Analysis
.I 1105
.T
On Introducing Digital Computing
.I 1106
.T
Programming of Digital Computers
.I 1107
.T
Computers and Education
.I 1108
.T
Digital Data Processor for Tracking the Partially Illuminated Moon*
.W
A study of lunar tracking techniques and fabrication
of a breadboard to assess the feasibility 
of the best technique selected was conducted to define
a tracking system for observation of the sight line 
to the center of a partially illuminated moon.  The
data processing portion of the system is presented 
in detail and then described in general are the operation
of the tracker head assembly for data readout, 
the operation of the entire system and the effect data
processing considerations have on the design of 
the tracker system.  The system basically consists of
an optical sensor, digital computer and tracker 
drive mechanism.  The three system units, connected
in cascade, comprise the control loop.  For this 
application, an optical telescope with a radial mechanical
scanning mechanism was used that read out 
lunar sight line measurement information.  This information
is sequentially read into a special purpose 
digital computer that extracts the measurements and
computes the error signals that drive the tracker 
to the appropriate attitude.
.I 1109
.T
Conversion of a Power to a Series of Chebyshev Polynomials*
.W
Even slowly convergent power series can be
rearranged as series in Chebyshev polynomials if 
appropriate sequence transformations are used in evaluating
the coefficients.  The method is illustrated 
by computing the coefficients for the expansion
of the logarithm and dilogarithm.
.I 1110
.T
A Fourier Series Method for the Numerical Solution
of a Class of Parabolic Partial Differential 
Equations*
.W
A Fourier series method is described which, when
applied to a certain class of parabolic partial 
differential equations, reduces the problem to a system
of ordinary differential equations.  An application 
is given for which the method shows a considerable advantage
over conventional finite difference methods.
.I 1111
.T
A Class of Iterative Techniques For the Factorization of Polynomials*
.W
A method of iteration is developed in terms
of a function of somewhat arbitrary character. 
 Sufficient conditions are given for convergence of
the process, yielding factors of arbitrary degree 
for polynomials in one variable.  Both Lin's method
and Newton's method occur as special cases.
.I 1112
.T
A Technique for Computer Detection and Correction of Spelling Errors*
.W
The method described assumes that a word
which cannot be found in a dictionary has at most 
one error, which might be a wrong, missing or extra letter
or a single transposition.  The unidentified 
input word is compared to the dictionary again, testing
each time to see if the words match-assuming 
one of these errors occurred.  During a test run on garbled
text, correct identifications were made for 
over 95 percent of these error types.
.I 1113
.T
Computer-Made Perspective Movies as a Scientific and Communication Tool*
.W
It is easy to program the basic transformation
required for a perspective drawing.  This fact 
plus the advent of high speed microfilm printers such
as the General Dynamics Electronics S-C 4020 makes 
possible perspective movies as the direct output from
a computer.  The programming of such a movie is 
briefly described for studying the angular motions of
a satellite containing an attitude control system. 
 In the movie, a domino-shaped box represents the satellite
and a sphere with circles of latitude and 
longitude represents the earth.  The cost was approximately
three to eight minutes of IBM 7090 time per 
one minute of movie.
.I 1114
.T
Generating a Canonical Prefix Encoding*
.W
Computer programs for generating a minimum-redundancy
exhaustive prefix encoding are described. 
 One program generates a Huffman frequency tree, another
determines the structure functions of an encoding, 
and a third program assigns codes.
.I 1115
.T
Randomized Binary Searching With Tree Structure
.W
A more efficient method of using tree structures
is proposed, which utilizers both plus and 
minus branches in the search path.  Very significant
gains result when the search key includes alphabetic 
characters.
.I 1116
.T
Tests on a Computer Method for Constructing School Timetables*
.W
A previously proposed computer method for constructing
timetables, based on an iteration involving 
Boolean matrices, is described.  In limited tests the
method has successfully produced timetables on 
every trial.  References are given which relate the
timetable problem to theorems on matrices of zeros 
and ones, and to theorems on bipartite graphs.  Some
problems of applying the method to constructing 
timetables in real situations are noted.
.I 1117
.T
Polyphase Sorting With Overlapped Rewind*
.W
A variation of the polyphase merge technique
of sorting is described which permits one tape 
at a time to be rewound while the merge is continued on
the remaining tapes.  The result is the overlapping 
of a major portion of the rewind time.  The technique
should be considered whenever a sort is written 
to operate on five or more tapes that cannot be read backwards.
 The savings of the overlap method appear 
to increase as the number of available tapes is increased.
.I 1118
.T
FORTRAN Subroutines for Time Series Data Reduction*
.I 1119
.T
An Open Letter to X3.4.3 (FORTRAN Standards -- American Association)
.I 1120
.T
"ALCOR Group Representations of ALGOL Symbols,"
Comm. ACM 6 (1963), 597-599. (Corrigenda)
.I 1121
.T
Comments on "A Continued Operation Notation"*
.W
This note is intended to clarify and correct
several points in a recent paper describing some 
notations for symbol manipulation by M.P. Barnett [Comm. ACM 6(August, 1963)].
.I 1122
.T
A Note on Some Compiling Algorithms
.W
Two compiling generators for arithmetic expressions
are discussed: one presently in use in 
an experimental compiler, and an improvement
suggested by K. Speierman of Burroughs.
.I 1123
.T
Gauss (Algorithm 209)
.I 1124
.T
Matrix Division (Algorithm 197)
.I 1125
.T
Syminv2 (Algorithm 150)
.I 1126
.T
ERF (Algorithm 123)
.I 1127
.T
Tridiagonal Matrix (Algorithm 122)
.I 1128
.T
Evaluation of Determinant (Algorithm 41)
.I 1129
.T
Incomplete Beta Function Ratios (Algorithm 222)
.I 1130
.T
Gamma Function (Althm 221)
.I 1131
.T
On Context and Ambiguity in Parsing*
.I 1132
.T
An Extension to ALGOL for Manipulating Formulae*
.I 1133
.T
A Programming Package for Some General Modes of Arithmetic*
.I 1134
.T
Some Effects of the 6600 Computer on Language Structures*
.W
The problem of compiling efficient 6600 codes
prompted the development of an intermediate language 
reflecting the structure of the machine, that is more
easily manipulated in improving object program 
efficiency.  The subject of this paper is the intermediate
language and methods of manipulating it.  
Compilations of a series of arithmetic statements are
discussed.  It is assumed that all functions and 
exponentials have been removed from these statements,
and replaced by simple variables.  For purposes 
of simplicity the treatment of subscripts is ignored. 
A simplified 6600 structure is presented to illustrate
the compiling method.  Several assumptions are made
for purposes of simplification, although there are 
cases in which the assumptions are violated in the actual machine.
.I 1135
.T
A General Business-Oriented Language Based on Decision Expressions*
.W
The structure of a digital compute programming
language which covers a wide class of business 
and file processing applications is presented.  Such
a structure, based on identifying and incorporating 
into a compiler the aspects common to all processes
of such class, permits writing extremely compact 
programs, even for comparatively complex applications,
in terms of tables of control expressions which 
express only information characteristic of the particular
application.  Furthermore,local changes of 
a process (e.g. changes affecting only one of the output
files involved) can be effected by local modifications 
in the program (e.g. modification of only one entry of the
tables).  This structure also allows for inexpensive 
preparation of loading-speed compilers which translate the
source programs into efficient machine codes. 
 The approach adopted here departs from conventional mechanical
language design philosophies.  It stresses 
the structural analysis of the class of processes to be represented
in the languages, as opposed to emphasizing 
formal (i.e., contents-independent) syntactical definitions.
 It relies exclusively on nonprocedural 
representation of process as sets (tables) of relations
between data and results (there are no control 
statements such as GO TO, etc.), instead of using procedure
descriptions (which are one-to-one translations 
of flowcharts).  Here an invariant pattern of procedure
is identified as characteristic of the class 
of all batch file processes.  This new philosophy has
the potential to overcome well-known deficiencies 
of other business-oriented languages and fully meets
the requirements set by CODASYL for such languages, 
including machine-independence.
.I 1136
.T
Beginnings of a Theory of Information Handling*
.I 1137
.T
A Format Language*
.I 1138
.T
Formalism in Programming Languages*
.I 1139
.T
FORTRAN IV as a Syntax Language*
.I 1140
.T
"Structural Connections" in Formal Language*
.I 1141
.T
Bounded Context Syntactic Analysis
.I 1142
.T
An Extension of ALGOL-Like Languages
.I 1143
.T
Analysis of Decay-Type Data*
.W
A comparative study has been made of a variety
of numerical techniques for fitting experimental 
data of the decay type by forms involving the sums of
exponentials.  Statistical errors of the fitted 
parameters are also calculated.  These methods have been
applied to artificially-generated sets of data 
as well as to the results of experiments with radioactive
tracers on both human and animal subjects. 
 Results show that the values of the fitted parameters
are very sensitive to variations in the fitting 
procedure.  Therefore great care very sensitive to variations
in the fitting procedure.  Therefore great 
care must be exercised in identifying such values with
physical constants.  Although the values of functions 
derived from these fitted parameters which can definitely
be associated with physical entities are generally 
more stable under variations in the fitting techniques,
error bounds can be so large that no great confidence 
can be placed even in them.  It would therefore appear
best to select a uniform technique both for running 
the experiments and for analyzing the data, and then
to consider as significant only relative results 
between one subject and the next.
.I 1144
.T
Digital Computer Determination of Alpha Source Activity
.W
A technique is described for determining the
activity and homogeneity of an alpha source.  
It is believed that the technique, using a digital computer,
has many uses and applications in the field 
of nuclear physics. The technique involves computer
manipulation of the digital image of the nuclear 
source.  Experimental details are given.
.I 1145
.T
GIT-A Heuristic Program for Testing Pairs
of Directed Line Graphs for Isomorphism*
.W
Given a pair of directed line graphs, the problem
of ascertaining whether or not they are isomorphic 
is one for which no efficient algorithmic solution is known.
 Since a straightforward enumerative algorithm 
might require 40 years of running time on a very high
speed computer in order to compare two 15-node 
graphs, a more sophisticated approach seems called
for.  The situation is similar to that prevailing 
in areas such as game-playing and theorem-proving, where
practical algorithms are unknown (for the interesting 
cases), but where various practical though only partially
successful techniques are available.  Git-Graph 
Isomorphism Tester-incorporates a variety of processes
that attempt to narrow down the search for an 
isomorphism, or to demonstrate that none exists.  No one
scheme is relied upon exclusively for a solution, 
and the program is designed to avoid excessive computation
along fruitless lines.  GIT has been written 
in the COMIT language and successfully tested on the IBM 7090.
.I 1146
.T
An Efficient Composite Formula for Multidimensional Quadrature
.W
A (2s+1)-point second-degree quadrature formula
for integration over an s-dimensional hyper-rectangle 
is presented.  All but one of the points lie on the
surface with weights of opposite sign attached to 
points on opposite faces.  When a large volume is subdivided
into congruent rectangular subdivisions, 
only one point is required in each interior subdivision
to achieve second-degree accuracy.
.I 1147
.T
On the Numerical Solution of Boundary Value Problems
for Linear Ordinary Differential Equations*
.W
A numerical method is presented for the solution
of boundary value problems involving linear 
ordinary differential equations.  The method described
is noniterative and makes use of any one-step 
numerical integration scheme to reduce the problem from
one of boundary values to one of initial values. 
 Comments are made concerning some numerical results
of applying the method to a specific problem.  In 
addition an extension of the algorithm described
to more general problems is discussed.
.I 1148
.T
An Example in "Significant-Digit" Arithmetic*
.W
Different methods of handling the summing process
for the geometric series are shown to give 
results indicating widely differing significances when carried
out in a machine incorporating "significant-digit" 
arithmetic.
.I 1149
.T
GARGOYLE , A Language for Compiler Writing*
.I 1150
.T
A Fortran Post-Mortem Procedure
.I 1151
.T
A Note on Multiplying Boolean Matrices II
.I 1152
.T
Floating-Point Arithmetic with 84-Bit Numbers
.W
A classic and straightforward technique is
presented which is not limited to the size or type 
of number representation used or multiple precision arithmetic.
.I 1153
.T
A Fast Procedure for Generating Normal Random Variables*
.W
A technique for generating normally distributed
random numbers is described.  It is faster 
than those currently in general use and is readily
applicable to both binary and decimal computers.
.I 1154
.T
Multi-Tape and Infinite-State Automata -- A Survey
.W
A survey of machines which are more powerful
than finite automata and less powerful than general 
Turing machines is presented.  It is felt that the machines
in this category are as closely related to 
digital computers as either the finite automata or the
unrestricted Turing machines.  Intermediate machines 
can be created by adjoining on infinite-state memory
to a finite-state machine and then performing any 
or all of the following: (1) restrict the manner in
which the unbounded portion of the memory can be 
accessed, (2) bound the number of steps allowed for a
computation by some increasing recursive function 
of the length of the input, (3) restrict the total amount
of memory available in the same manner.  Examples 
from all three classes and their properties are discussed.
.I 1155
.T
Experiments with a Deductive Question-Answering Program
.W
As an investigation in artificial intelligence,
computer experiments on deductive question-answering 
were run with a LISP program called DEDUCOM, an acronym
for DEDUctive COMmunicator. When given 68 facts, 
DEDUCOM answered 10 questions answerable from the facts.
 A fact tells DEDUCOM either some specific information 
or a method of answering a general kind of question.
 Some conclusions drawn in the article are: (1) 
DEDUCOM can answer a wide variety of questions.  (2)
A human can increase the deductive power of DEDUCOM 
by telling it more facts.  (3) DEDUCOM can write very
simple programs (it is hoped that this ability 
is the forerunner of an ability to self-program, which
is a way to learn).  (4)DEDUCOM's search procedure 
at present has two bad defects: some questions answerable
from the given facts cannot be answered and 
some other answerable questions can be answered only if
the relevant facts are given in the "right" order. 
 (6) At present, DEDUCOM's method of making logical deductions
in predicate calculus has two bad defects: 
some facts have to be changed to logically equivalent ones
before being given to DEDUCOM, and some redundant 
facts have to be given to DEDUCOM.
.I 1156
.T
Hankel Function (Algorithm 124 [S17])
.I 1157
.T
Procedure for the Normal Distribution Functions (Algorithm 272 [S15])
.I 1158
.T
Program Structures for Parallel Processing
.W
Constructs for organizing and explicating parallel
program segments are discussed as extensions 
to ALGOL 60.  The constructs serve as meta-commands and
are motivated by equipment having multiprocessing 
capability.
.I 1159
.T
Machine Independence: Its Technology and Economics
.W
A survey is offered of techniques for transferring
programs, and especially compilers, from 
one computer to another.  Of the methods examined, the
"bootstrap" technique is singled out for detailed 
discussion, with emphasis on its economics. The considerations
that determine the applicability of bootstrapping 
in any specific case are discussed, and an attempt
is made to assign appropriate qualitative weights 
to them.  Finally, reasons are given for believing that the
machine-independence problem is being substantially 
diminished by current trends in computer design, and
that it is this process of convergence in hardware 
design rather than any foreseeable software developments
that will lead to its satisfactory resolution.
.I 1160
.T
CAT: A 7090-3600 Computer-Aided Translation
.W
A semi-automatic translation system has been implemented
which converts 7090 FAP language programs 
into 3600 assembly language.  The input to the system
is a FAP program deck which has been specially 
prepared for translation by the user.  The output consists
of the translated COMPASS language program 
together with a comprehensive diagnostic listing which the
user must analyze in order to verify any questionable 
areas of the translation.  The translation processor
consists of three distinct phases: an assembly of 
the FAP program, a comprehensive analysis of the assembled
code with particular regard to the actions 
of instructions upon other instructions and upon data,
and finally the output pass which generates the 
COMPASS program in the form of macro instructions.
.I 1161
.T
1401 Compatibility Feature on the IBM System/360 Model 30
.W
The "second generation" of stored-program computers,
of which IBM 1400 series was a part, brought 
EDP into the mass market for the first time on a large
scale.  As this era unfolded, rapid changes in 
technology led to rapid obsolescence of data processing
equipment.  Program written for a particular 
system required tedious conversion as incompatible new
machines came into use.  The IBM System/360 has 
been designed with the conversion problem specifically
in mind.  One of the conversion aids available 
on the Model 30 is the 1401 compatibility feature.  This
feature, in conjunction with other aids, permits 
a smooth and inexpensive transition to optimum use of the new system.
.I 1162
.T
An Assembly Language for Reprogramming
.W
Complete reprogramming of compiler language programs
is seldom necessary.  It is assembly language 
programs which present the greatest difficulty.  Assembly
languages generally provide a one-for-one translation 
from a symbolic to a numeric version of a program, that
is, from assembly language to machine language. 
 The meta-language presented here can be used to specify
the mapping of any language which conforms to 
a canonical list form into an arbitrary stream of bits.
 This bit stream may be treated as a machine 
language program, a character stream, or whatever else
the user might desire.  Thus, this meta-language 
can be used to map from one assembly language into another
or from the assembly language for one machine 
into the machine language of another.
.I 1163
.T
Philco/IBM Translation at Problem-Oriented, Symbolic and Binary Levels
.W
A translation system has been developed to
eliminate most of the effort formerly required to 
reprogram Philco 2000 series codes for IBM 7094 operation.
 Experience with this system is limited but 
highly successful encouraging application of the
techniques to other source and object languages.
.I 1164
.T
Emulation of Large Systems
.W
The conversion problem and a new technique
called emulation are discussed.  The technique of 
emulation is developed and includes sections on both the
Central Processing Unit (CPU) and the Input/Output 
unit (I/O).  This general treatment is followed by three
sections that describe in greater detail the 
implementation of compatibility features using the emulation
techniques for the IBM 7074, 7080 and 7090 
systems on IBM System/360.
.I 1165
.T
The Spectra 70/45 Emulator for the RCA 301
.W
The RCA 301 Emulator System is supplied with
the Spectra 70/45 as a reprogramming aid.  It 
allows an RCA 301 object program to be run on the Spectra
70/45 without necessitating changes in the 
RCA 301 object code.  Execution rates are considerably
better than traditional simulation.  The Emulator 
provides an increase in throughput capacity for the
301 user on the Spectra 70/45.  The Emulator makes 
use of both hardware micro-program routines and
software routines to accomplish its function.
.I 1166
.T
A Use of Macros in Translation of Symbolic
Assembly Language of One Computer to Another
.W
A set of macro-operations has been prepared
to assist in translating IBM 7090 symbolic assembly 
language programs to IBM 7040 machine language programs.
 This set, inserted at the beginning of the 
7090 symbolic deck, treats incompatible instruction mnemonics
as macro-instructions to produce equivalent 
7040 instruction sets.  Incompatible instructions are
categorized into basic operational classes which 
can be expressed by a single basic skeleton.  Several levels
of macro calls are required to supply arguments 
to the basic skeleton for each particular instruction.
 Modification at execution time of the address 
or tag of an incompatible instruction requires incorporation
of an address-tag equivalent.  I/O is handled 
by generating calls to I/O simulation subroutines.
.I 1167
.T
On the Translation of Machine Language Programs
.W
Automatic translation of machine language
programs is becoming a highly desirable goal with 
the advent of new large-scale computers.  The pitfalls that
make it difficult to achieve completely automatic 
translations are analyzed, and it is shown that these are
primarily of a semantic nature.  A semi-automatic 
procedure for resolving semantic problems is suggested.
.I 1168
.T
Across Machine Lines in COBOL
.W
The production of a large, file-maintenance-and-retrieval
program system written in COBOL is 
described.  The COBOL language was used specifically to
enable the system to operate on three IBM computers.
.I 1169
.T
An Algorithm for Minimizing Backboard Wiring Functions
.W
A partially exhaustive algorithm is presented
for solving the following problem arising from 
automatic layout of a computer.  Given an ordered set
E1, E2,..., EN of N computer components, for each 
permutation of the elements E1, E2.., EN, there is attached
a value of an integer function F.  The algorithm 
finds a local minimum of F by evaluating the set {Delta
F} of the increments corresponding to a certain 
set of exchanges of two elements.Then the exchange
corresponding to the least negative increment of 
{Delta F} is performed.  The process is iterated and stopped
when the set of the increments is a positive 
or empty set, which, it is proved, corresponds to a
minimum.  The procedure is similar to the Downhill 
Method for finding the minimum of a real function F(P),
and can be applied to other placement problems. 
 Experimental results are presented with backboards formed
by many elements and different initial placements.
.I 1170
.T
Analyzing English Syntax with a Pattern-Learning Parser
.W
A dependency analysis system based on pattern
recognition and learning logic was developed 
to infer word classes and rules of syntactic combination
from experience with text which had been analyzed. 
 The characteristics used to form word classes are the
depth in the dependency tree of each word, the 
direction of its governor and the same features for
each of its immediate neighbors. Syntactic rules 
of combination show the relation of a word to its governor
in the depth pattern of the sentence.  The 
system was tested on 400 elementary basic English sentences
including 300 used earlier by Knowlton in 
a different learning parser of all 400 sentences.  After
experience with 300 sentences it was able to 
generalize with 77 percent accuracy to the next 100.
 In accumulative learning trials after the first 
200 sentences it averaged a probability of .9 for accurately
parsing each new sentence it encountered. 
 It was concluded that the system is adequate for learning
to parse the bulk of basic English but that 
further development is required before conclusions about
its application to ordinary English can be stored. 
 The system is operational and available on
the ARPA/SDC time-shared computing system.
.I 1171
.T
A Comparison of the Primal-Simplex and Primal-Dual
Algorithms for Linear Programming
.W
A statistical comparison of the primal-dual
and the more commonly used primal-simplex algorithm 
for solving linear programming problems has been made under
the assumption of starting with a full artificial 
basis.  Under these conditions the primal-dual method
shows a statistically significant superiority on 
randomly generated problems.  It has also been found, via
a regression analysis, that the relevant parameters 
in determining the difference in the number of iterations
between the algorithms is not only the number 
of constraints and the number of variables but
also the ratio of the latter to the former.
.I 1172
.T
Conversion of Limited-Entry Decision Tables to Computer Programs
.W
Decision tables are useful for describing a
set of complex decision rules based on given sets 
of conditions.  Algorithms that can efficiently convert
the tables into computer programs will extend 
the usefulness of decision tables to computer users.
 Two such algorithms, based on work done by M. S. 
Montalbano, are described and extended here to handle
dashes and ELSE-decision rules.  The first algorithm 
minimizes the computer storage space required for the
resultant program, the second minimizes computer 
running time. During the conversion process, both pinpoint
any contradictions or redundancies among the 
rules in a table.
.I 1173
.T
The Performance of a System for Automatic Segmentation
of Programs Within an ALGOL Compiler (GIER 
ALGOL)
.W
The GIER ALGOL compiler makes use of an automatic
system for handling the transfers of program 
segments from the drum store to the core store at program
execution time.  The logic of this system is 
described. The performance of the system is discussed,
primarily on the basis of execution times related 
to two specific programs.  This discussion concludes with
an assessment of the potential gains of various 
ways of improving the system.
.I 1174
.T
Inverse Permutation (Algorithm 250 [G6])
.I 1175
.T
Quickersort (Algorithm 271 [M1])
.I 1176
.T
Finding Eigenvectors by Gaussian Elimination (Algorithm 270 [F2])
.I 1177
.T
Determinant Evaluation (Algorithm 269 [F3])
.I 1178
.T
ALGOL 60 Reference Language Editor (Algorithm 268 [R2])
.I 1179
.T
PUFFT-The Purdue University Fast FORTRAN Translator
.W
A core resident, compile-and-go system designed
for the IBM 7090/7094 computer is described. 
 In little more than half of the 32k word core memory
PUFFT provides a monitor for job sequencing, a 
translator for the full FORTRAN IV language, the FORTRAN
subroutine library, an input--output system 
for use at compile time and at execute time, and a rather
elaborate diagnostic message writing routine. 
 Batches of small- and medium-sized FORTRAN IV source
language programs are processed at very high speeds. 
 Language compatibility has been maintained so that
programs may be debugged in the PUFFT system and 
then recompiled and run in the IBJOB-IBFTC system supplied by the manufacturer.
.I 1180
.T
AXLE: An Axiomatic Language for String Transformations
.W
AXLE is a language designed for data manipulation.
 Data arranged in a linear form in a workspace 
is transformed according to a table of axioms, called imperatives.
 A transformation consists of a matching 
procedure, which decides where an imperative is applicable,
and a replacement procedure that modifies 
that part of the workspace.  Imperatives are applied
in accordance with definitions of symbolic terms, 
presented systematically in an assertion table.  The
process of definition includes the special case 
of recursive assertions.  Several complete programs
of imperatives are given to show a few applications
of the language.
.I 1181
.T
A Simple Data Transmission System Using the Office Telephone
.W
A method has evolved for transmitting data of
a type originating in many laboratory situation 
direct to a central computer.  The method requires almost
no specialized equipment and uses any ordinary 
telephone on a "callup" basis.  Present applications
include cardiac-output calculations, radio-activity 
tracer studies and neurophysiology time-sequence studies of nerve impulses.
.I 1182
.T
Contextual Correlates of Synonymy
.W
Experimental corroboration was obtained for
the hypothesis that the proportion of words common 
to the contexts of word A and to the contexts of word
B is a function of the degree to which A and B 
are similar in meaning.  The shapes of the functions,
however, indicate that similarity of context is 
reliable as criterion only for detecting pairs
of words that are very similar in meaning.
.I 1183
.T
A Note on the Use of a Digital Computer
for Doing Tedious Algebra and Programming
.W
A special purpose compiler was written with
FORTRAN II language and made possible the writing 
of very long programs by the computer.  The procedure is
based on a straight-forward use of FORMAT statements 
for generating machine-written programs.
.I 1184
.T
A Fast Storage Allocator
.W
A fast storage bookkeeping method is described
which is particularly appropriate for list-structure 
operations and other situations involving many sizes
of blocks that are fixed in size and location.  
 This scheme, used in the LLLLLL or L6 (Bell Telephone Laboratories
Low-Level List Language), makes available 
blocks of computer registers in several different sizes:
the smaller blocks are obtained by successively 
splitting larger ones in half, and the larger blocks are reconstituted
if and when their parts are simultaneously 
free.
.I 1185
.T
A program to Solve the Pentomino Problem by the Recursive Use of Macros
.W
A coding technique is described in which certain
macro-instructions are given lists as arguments 
and are thereby used recursively.  The discussion covers
primarily an example in which the technique 
is used to solve the pentomino problem-the problem of
fitting 12 pentominos without overlapping into 
a plane area formed of 60 elemental squares.
.I 1186
.T
Recursive Solution of a Class Of Combinatorial Problems: An Example
.W
Combinatorial problems requiring the selection
of n elements from a set of m elements may be 
solved by a recursion process analogous to that for
computing binomial coefficients.  Several specific 
problems are analyzed, the general technique is exposed,
and an ALGOL program is developed for one of 
the problems.
.I 1187
.T
Note on an ASCII-Octal Code Table (Standards)
.I 1188
.T
An ALGOL-like Computer Design Language
.W
The idea of constructing a computer design
language by making use of an ALGOL-like programming 
language is presented.  A computer designer can benefit
from using a design language at a higher level 
just as a computer user can benefit from a higher level
programming language.  The purposes and requirements 
of the design language are enumerated.  To achieve most
of the purposes a translator is required to translate 
a design of computer logic into a set of Boolean equations.
 The design language is presented in terms 
of vocabulary, statements, sequences and microprogram.
 Included are examples of identifiers, expressions 
with both unary and binary operators, declaration statements,
transfer statements, terminal statements, 
exchange statements, if statements, do statements, go
to statements, several sequences and a microprogram.
.I 1189
.T
Random Normal Deviate (Algorithm 267 [G5])
.I 1190
.T
Pseudo-Random Numbers (Algorithm 266 [G5])
.I 1191
.T
Find Precedence Functions (Algorithm 265 [L2])
.I 1192
.T
Interpolation in a Table (Algorithm 264 [E1])
.I 1193
.T
Gomory 1 (Algorithm 263 [H])
.I 1194
.T
Establishment of the ACM Repository and Principles
of the IR System Applied to its Operation
.W
The history of the establishment of the ACM Repository
at the Moore School, University of Pennsylvania, 
is reviewed briefly.  Two principles are presented as
paramount in the provision of information services: 
(1) easy accessibility to the information files by users
unfamiliar with file organization, and (2) value 
of service exceeding user costs.  These principles serve
as guides in mechanizing the ACM Repository. 
 The main features of the information system are direct
user access via on-line teletypewriter console, 
direct user access to all details of the system organization,
unrestricted and expandable search vocabulary, 
user access through many facets of document indexing,
and stochastic search through linked index terms 
and other file relationships.  The first contribution
to the ACM Repository consisted of 315 documents, 
relating primarily to early research on compilers.  These
documents have been cataloged and indexed and 
the catalog is scheduled to appear in Computing Reviews.
 The indexing system is described in detail. 
 The Main Catalog is used to describe the documents,
and inverted lists are provided by the Repository 
system for retrieval by concept coordination.
.I 1195
.T
UPLIFTS-University of Pittsburgh Linear File Tandem System
.W
A series of computer programs has been developed
and is now operational for processing the 
National Aeronautics and Space Administration linear file
system on an IBM 1401-7090 combined data processing 
system.  The program are note-worthy in that they create
fixed length logical records and fixed length 
blocks from variable length source data, and format
the output for optimization of processing on the 
IBM 7090 system.  The programs are completely self-checking
and test for both validity and accuracy of 
the input materials as provided by the National
Aeronautics and Space Administration.
.I 1196
.T
Applications of Differential Equations in General Problem Solving
.W
A large class of problems leading to digital
computer processing can be formulated in terms 
of the numerical solution of systems of ordinary differential
equations.  Powerful methods are in existence 
for the solution of such systems.  A good general purpose
routine for the solution of such systems furnishes 
a powerful tool for processing many problems.  This is
true from the point of view of ease of programming, 
ease of debugging, and minimization of computer time.
 A number of examples are discussed in detail.
.I 1197
.T
Finding Zeros of a Polynomial by the Q-D Algorithm
.W
A method which finds simultaneously all the zeros
of a polynomial, developed by H. Rutishauser, 
has been tested on a number of polynomials with real
coefficients.  This slowly converging method (the 
Quotient-Difference (Q-D) algorithm) provides starting
values for a Newton or a Bairstow algorithm for 
more rapid convergence.  Necessary and sufficient conditions
for the existence of the Q-D scheme are 
not completely known; however, failure may occur when
zeros have equal, or nearly equal magnitudes.  
Success was achieved, in most of the cases tried, with
the failures usually traceable to the equal magnitude 
difficulty.  In some cases, computer roundoff may result
in errors which spoil the scheme.  Even if the 
Q-D algorithm does not give all the zeros,
it will usually find a majority of them.
.I 1198
.T
Solution of a Problem in Concurrent Programming Control
.W
A number of mainly independent sequential-cyclic
processes with restricted means of communication 
with each other can be made in such a way that at any
moment one and only one of them is engaged in the 
"critical section" of its cycle.
.I 1199
.T
A Computer Center Simulation Project
.W
Today's computation centers are based on rapidly
changing technologies of hardware and software 
systems.  It is difficult, therefore, to base decisions
on experience; in most instances, the benefits 
of comparable experience for a given problem situation
are not available.  In this paper, a mathematical 
model of the Lockheed Central Computer Center is formulated
that describes the operation of a computation 
center in terms of information nets, decision processes,
and control functions.  Experiments performed 
with this model, the results of the experiments,
and the application of the results are discussed.
.I 1200
.T
On Reversible Subroutines and Computers that Run Backwards
.W
A computer design is describe which permits
subroutines to be executed backward as well as 
forward, either with their instructions unchanged or
replaced with conjugate instructions.  It is shown 
that using this concept a number of new subroutine types
can be developed with rather unusual properties. 
 Since these properties are analogous to certain matrix
operations, a parallel nomenclature is suggested 
for their classification.
.I 1201
.T
Generation of Permutations in Lexico-Graphical
Order (Algorithm 202 [G6])
.I 1202
.T
Normal Random (Algorithm 200 [G5])
.I 1203
.T
Normdey (Algorithm 121 [G5])
.I 1204
.T
Character Structure and Character Parity Sense for
Serial-by-Bit Data Communication in the American 
Standard Code for Information Interchange (Proposed American Standard)
.I 1205
.T
An Undergraduate Program in Computer Science-Preliminary Recommendations
.I 1206
.T
The Self-Judgment Method of Curve Fitting
.W
A computer-oriented method for processing and
communicating numerical data is described.  The 
Instrument Reliability Factors (IRF), which exactly
define the limits of reliability of each measured 
item of information, are used to compute the Maximum
Permitted Error (MPE) associated with each values 
of each ordinate.  The Self-Judgment Principle (SJP)
is used to discard wrong information and to compute 
mean values of the parameters and their MPE's in terms
of the IRF.  Data compatibility tests with any 
number of different equations can be made quickly. 
Otherwise intractable problems are easily solved, 
and the design of many experiments is greatly simplified.
 The computational and mathematical techniques 
used to reduce bias in the SJP are discussed.  Inadequacies
in the statistical and graphical methods 
of curve fitting are noted.
.I 1207
.T
Remarks on Simulation of Boolean Functions
.I 1208
.T
Simulation of Computer Logic by Fortran Arithmetic
.I 1209
.T
Negative and Zero Subscripts in Fortran II Programming for the IBM 1620
.I 1210
.T
File-Handling Within FORTRAN
.W
This note describes some FORTRAN subroutines
to facilitate handling of tape files.  They allow 
symbolic naming of information files, without violating
the casual scientific programmer's idea of simplicity. 
 Some comments on two years use of these subroutines are given.
.I 1211
.T
A Note on Storage of Strings
.W
A method for storing strings is described which
uses blocks of indefinite size, and is therefore 
completely dynamic.  Its relation to similar schemes is discussed.
.I 1212
.T
Non-linear Extrapolation and Two-Point Boundary Value Problems
.W
It is suggested that the convergence properties
of the usual Picard successive approximation 
scheme may be improved through use of non-linrar extrapolation
techniques.  A numerical example is provided.
.I 1213
.T
Dynamic Format Specifications
.W
The use and implementation of two new FORTRAN
format conversions are discussed.  These format 
types give the FORTRAN programmer control of input/output
specifications at execution time.
.I 1214
.T
Some Experiments in Algebraic Manipulation by Computer 
.W
A set of subroutines to allow algebraic manipulations
on the IBM 7094 computer has been written 
a List Processor, SLIP.  A series of four problems of increasing
difficulty were solved using these routines.
.I 1215
.T
Some Techniques Used in the ALCOR ILLINOIS 7090
.W
An ALGOL compiler has been written by the
ALCOR group for the IBM 7090.  Some little known 
but significant techniques in compiler writing, together
with organizational details of this compiler, 
are described.  Timing estimates and an indication
of compiler requirements are also given.
.I 1216
.T
Symbolic Derivatives Without List Processing, Subroutines, or Recursion
.W
A routine has been developed which computes and
prints out the symbolic derivative of an absolutely 
continuous elementary function of one or several variables.
 No use is made of list-processing languages. 
 The chain rule is applied and the result is edited to
produce results as elegant and efficient as those 
obtained by hand computation.  A subset may be imbeded
in a formula translator to introduce a differentiation 
operator into an "algebraic" programming language.
.I 1217
.T
Map of Partitions into Integers (Algorithm 264 [A1])
.I 1218
.T
Partition Generator (Algorithm 263 [A1])
.I 1219
.T
Number of Restricted Partitions of N (Algorithm 262 [A1])
.I 1220
.T
9-J Symbols (Algorithm 261 [Z])
.I 1221
.T
6-J Symbols (Algorithm 260 [Z])
.I 1222
.T
Legendre Functions for Arguments Larger Than One (Algorithm 259 [S16])
.I 1223
.T
High Speed Compilation of Efficient Object Code
.W
A three-pass compiler with the following properties
is briefly described:  The last two passes 
scan an intermediate language produced by the preceding
pass in essentially the reverse of the order 
in which it was generated, so that the first pass is the
only one which hasto read the bulky problem-oriented 
input.  The double scan, one in either direction, performed
by the first two passes, allows the compiler 
to remove locally constant expressions and recursively
calculable expressions from loops and to do the 
important part of common subexpression recognition.
 Optimization such as the effective use of index 
registers, although as important, is not discussed since
the object code which would be most efficient 
is highly machine dependent.  The discussion is in terms
of a FORTRAN-like language, although the technique 
is applicable to most algebraic languages.
.I 1224
.T
Determining a Computing Center Environment
.W
An investigation is described in which several
generally unavailable parameters descriptive 
of a computing center environment are obtained.  The
actual data collection and reduction is described, 
and the results of one month of this collection are tabulated and summarized.
.I 1225
.T
The Predictive Analyzer and a Path Elimination Technique
.W
Some of the characteristic features of a predictive
analyzer, a system of syntactic analysis 
now operational at Harvard on and IBM 7094, are delineated.
 The advantages and disadvantages of the 
system are discussed in comparison to those of an immediate
constituent analyzer, developed at the RAND 
Corporation with Robinson's English grammar.  In addition,
a new technique is described for repetitive 
path elimination for a predictive analyzer, which can
now claim efficiency both in processing time and 
core storage requirement.
.I 1226
.T
The Organization of Structured Files
.W
A data file is an integral part of a data processing
system.  In many systems, the selection 
of an organization for the data within the file can
be critical to the system's operating efficiency. 
 This paper provides the systems designer with an information
source which describes ten techniques that 
may be employed for organizing structured data.  The
characteristics of the organizations described are 
application independent, thus providing the designer with
a reference which allows him to limit the number 
of file organizations he must consider for his system.
.I 1227
.T
Transport (Algorithm 258 [H])
.I 1228
.T
Treesort 3 (Algorithm 245 [M1])
.I 1229
.T
Random Permutation (Algorithm 235 [G6])
.I 1230
.T
Method for Hyphenating at the End of a Printed Line
.W
A description of a method of hyphenation is
presented as a result of application of several 
general rules.  The character sets considered by the
routine and the method are briefly outlined.
.I 1231
.T
Peephole Optimization
.W
Redundant instructions may be discarded during
the final stage of compilation by using a simple 
optimizing technique called peephole optimization.
The method is described and examplesare given.
.I 1232
.T
Representation of the Standard ECMA 7-Bit
Code in Punched Cards (ECMA Standard)
.I 1233
.T
Conventions for the Use of Symbols in the Preparation
of Flowcharts for Information Processing 
Systems (A Standard Working Paper)
.W
This paper is intended as an outline of the
various conventions which are being considered 
for the use of flowcharts for information processing
systems.  The conventions are applied to the use 
of the symbols appearing in the proposed American Standard
Flowchart Symbols and not with the symbols 
per se.
.I 1234
.T
The Structure of Yet Another ALGOL Compiler
.W
A high-speed "top down" method of syntax analysis
which completely eliminates "back-up" of 
the source string has been implemented in a convenient
macro-language.  A technique of  simulation at 
compile time of the use of a conventional run-time stack
enables the generation of code for expressions 
which minimizes stores, fetches and stack-pointer motion
at run time, while properly trating recursion 
and side effects of procedures.  Block structure and
recursion are handled without need for interpretive 
methods at run times.  The "context problem" in the transmission
to recursive procedures of parameters 
"called by name" is solved in a manner which permits the
handling of the common cases of simple expressions 
and array identifiers with particular efficiency.
.I 1235
.T
A Stochastic Approach to the Grammatical Coding of English
.W
A computer program is described which will
assign each word in an English text to its form 
class or part of speech.  The program operates at relatively
high speed in only a limited storage space. 
 About half of the word-events in a corpus are identified
through the use of a small dictionary of function 
words and frequently occurring lexical words.  Some suffix
tests and logical-decision rules are employed 
to code additional words.  Finally, the remaining words
are assigned to one class or another on the basis 
of the most probable form classes to occur within the already
identified contexts.  The conditional probabilities 
used as a basis for this coding were empirically derived
from a separate hand-coded corpus.On preliminary 
trials, the accuracy of the coder was 91% to 93%, with
obvious ways of improving the algorithm being 
suggested by an analysis of the results.
.I 1236
.T
The SMART Automatic Document Retrieval System-An Illustration
.W
A fully automatic document retrieval system
operating on the IBM 7094 is described.  The system 
is characterized by the fact that several hundred different
methods are available to analyze documents 
and search requests.  This feature is used in the retrieval
process by leaving the exact sequence of 
operations initially unspecified, and adapting the
search strategy to the needs of individual users. 
 The system is used not only to simulate an actual operating
environment, but also to test the effectiveness 
of the various available processing methods.  Results obtained
so far seem to indicate that some combination 
of analysis procedures can in general be relied upon to
retrieve the wanted information.  A typical search 
request is used as an example in the present report to illustrate
systems operations and evaluation procedures.
.I 1237
.T
Conversion of Decision Tables To Computer Programs
.W
Several translation procedures for the conversion
of decision tables to programs are presented 
and then evaluated in terms of storage requirements,
execution time and compile time.  The procedures 
are valuable as hand-coding guides or as algorithms for
a compiler.  Both limited-entry and extended-entry 
tables are analyzed.  In addition to table analysis,
the nature of table-oriented programming languages 
and features is discussed.  It is presumed that the reader
is familiar with the nature of decision tables 
and conventional definitions.
.I 1238
.T
A Technique for Integrated Reports from a Multi-run System
.W
The requirements of a requisition accounting
system for the San Francisco Overseas Supply Agency 
(OSA) included exception reporting to OSA itself.  The simultaneous
satisfaction of the reporting requirement 
and the accounting requirements posed definite problems
in system design, particularly the handling of 
the reporting function.  A practical and satisfactory
solution was developed by expanding the basic system 
with two tailored service runs for report production.
 These two runs permitted a final system that was 
easier to debug, easy to maintain, efficient in production
and responsive to the changing requirements
of OSA.
.I 1239
.T
Graycode (Algorithm 246 [Z])
.I 1240
.T
Transport (Algorithm 258 [H])
.I 1241
.T
Havie Integrator (Algorithm 257 [D1])
.I 1242
.T
Modified Graeffe Method (Algorithm 256 [C2])
.I 1243
.T
Testing the Understanding of the Difference Between
Call by Name and Call by Value in ALGOL 60
.I 1244
.T
Bit Manipulation in Fortran Language
.I 1245
.T
A Fortran n-Ary Counter
.I 1246
.T
Deeply Nested Iterations 
.I 1247
.T
An Operating Environment for Dynamic-Recursive
Computer Programming Systems
.W
Presented in this paper is a brief nontechnical
introduction to OEDIPUS, a computer programming 
system which can serve as an operating environment for
dynamic and/or recursive programs and programming 
systems.  The available services include dynamic allocation
of storage for contiguous blocks of arbitrary 
size, input and output for a hierarchy of data types,
a public pushdown list for automatic recursive 
programming, a rudimentary compiler for subroutine
communication and bookkeeping, and debugging aids.
.I 1248
.T
On the Automatic Simplification of Computer Programs
.W
Presented in this paper is the problem of writing
a program which would examine any other program 
and perform such simplifications on it as can be detected
from the argument-program's form alone, without 
having any knowledge of what it is supposed to do.
.I 1249
.T
 Recorded Magnetic Tape for Information Interchange
(200 CPI, NRZI) (On the Revised Proposed 
American Standard)
.I 1250
.T
Graphic Symbols for Problem Definition
and Analysis-A Standards Working Paper
.I 1251
.T
American Standard and IFIP/ICC Vocabularies compared
.W
The "Proposed American Standard Vocabulary of
Information Processing" and the "IFIP/ICC Vocabulary 
of Terms Used in Information Processing" are analyzed and compared.
.I 1252
.T
Symbolic Notations for Statistical Tables
and an Approach Towards Automatic System Design
.W
The preparation of statistical tables is an
important function of the data processing systems 
of some organizations, and a symbolic notation for the
description of tables has been shown to be a useful 
aid to documentation.  Such a notation also provides
the first step towards making automatic a tedious 
and time-consuming part of system design and programming
in many computer applications.  One notation 
is described and suggestions are made for the implementation of the larger goal.
.I 1253
.T
QUIKSCRIPT-A SIMSCRIPT- Like Language for the G-20
.W
QUIKSCRIPT is a simulation language based on
SIMSCRIPT and programmed entirely in an algebraic 
language, 20-GATE.  The QUIKSCRIPT language, its internal
implementation, and major differences between 
QUIKSCRIPT and SIMSCRIPT are presented.  This paper is
not a programming guide to the language, but rather 
an attempt to present its flavor.  A brief description of
SIMSCRIPT is included, as is a sufficient description 
of 20-GATE to render this material understandable
to the reader familiar with algebraic languages.
.I 1254
.T
The Iteration Element
.W
A recent addition to the MAD language has made
the iteration structure of the MAD THROUGH statement 
(corresponding to the ALGOL for statement and the FORTRAN
DO statement) available within expressions.
.I 1255
.T
A Method of Data List Processing With Application to EEG Analysis
.W
A set of subroutines is discussed, which is
designed to aid in the programming of computations 
on indexed lists of numbers using machine language
or a symbolic assembly system.  The most commonly 
performed list operations are outlined, and logically
arranged into five groups.  As an example, the 
computation of power spectral density from the autocovariance
function is discussed for a class of EEG 
signals.
.I 1256
.T
Dynamic Variable Formatting
.I 1257
.T
DEBUG-An Extension to Current On-Line Debugging Techniques
.W
A method of on-linr assembly-language debugging
which greatly simplifies several of the bookkeeping 
tasks characteristically associated with that process
has been developed and implemented in a program 
for the UNIVAC M-460 computer at Air Force Cambridge Research
Laboratories.  With this program, an online 
user may insert or delete (in symbolic assembly language)
any number of lines at any point of his previously 
assembled program in core, with the remainder
of the program being relocated appropriately.
.I 1258
.T
An Extended Arithmetic Package
.W
In many fields, for example algebraic number
theory, arithmetic must be carried out to a degree 
of precision which exceeds the normal hardware capacity
of most machines.  In such cases, an extended 
arithmetic package provides a comprehensive and easy-to-use
way of performing such arithmetic.  Such 
a package was coded for the IBM 7090.  In discussing
the general problems associated with the design 
of an extended arithmetic package, specific reference is made to this program.
.I 1259
.T
Applications of Binary Numbers In Computer Routines
.W
A binary number can be thought of as an alternate
form of expression for either a set of letters 
or a decimal number.  There are then three equivalent
expressions, easily translatable to one another, 
each having different characteristics.  Four examples
are given in which the form of an expression is 
changed to an equivalent expression to save space or gain power.
.I 1260
.T
Least-Squares Analysis of Resonance Spectra on Small Computers
.W
The problem of analyzing data from a Mossbauer
effect experiment is discussed.  By using the 
cut step procedure for convergence and by imposing physical
constraints on the functional form of the 
calculation it is possible to make the analysis on a
small computer.  The analysis has been carried out 
on an IBM 1410 computer with a 40,000 BCD core memory.
.I 1261
.T
Modeling and Simulation of Digital Networks
.W
The simulation of digital networks on a digital
computer provides the engineer with an effective 
means of analyzing time-quantized logical behavior.  The
digital network is modeled as a set of time-dependent 
or time-independent Boolean transformations; each transformation
describing the input-output relationship 
of a model element comprising the network mode.  The
simplicity of utilizing the FORTRAN IV Programming 
System as a digital Network Simulator is discussed an
illustrated.  This simplicity is derived from a 
common modeling technique applicable to combinational
and sequential digital networks and a systematic 
programming approach.
.I 1262
.T
Procedure-Oriented Language Statements to Facilitate Parallel Processing
.W
Two statements are suggested which allow a programmer
writing in a procedure-oriented language 
to indicate sections of program which are to be executed
in parallel.  The statements are DO TOGETHER 
and HOLD.  These serve partly as brackets in establishing
a range of parallel operation and partly to 
define each parallel path within this range.  DO TOGETHERs
may be nested.  The statements should be particularly 
effective for use with computing devices capable of
attaining some degree of compute-compute overlap.
.I 1263
.T
Metalanguage and Syntax Specification
.W
Two metalanguages are described, one sufficient
for the table specification of the ALGOL syntax, 
the other with additional metaoperators adequate and used
for the formal table description of Basic FORTRAN.
.I 1264
.T
BLNSYS-A 1401 Operating System with Braille Capabilities
.W
BLNSYS is an operating system designed for
a 4K 1401 with common optional features and two 
attached tape drives.  Printed output of this system
or of executing programs may be in either English 
or braille.  Even though this system was written for
a small machine with minimal peripheral equipment, 
jobs may be batched, so that card handling and lost
processing time is at a minimum.  This system will 
perform any or all of the following users specified
functions: assemble SPS source decks, post list, 
produce condensed or uncondensed object decks, execute
user's program, list card input to a program, 
list punched output, provide a storage dump, execute
a program submitted for execution as an uncondensed 
object deck under debugging trace control, card-to-braille
conversion, brailled listings of 7040 IBSYS 
batch output, and update or duplicate the system tape
itself.  Input-ouput subroutines are also included 
in the system.
.I 1265
.T
On the Relative Efficiencies of Context-Free Grammar Recognizers
.W
A number of diverse recognition procedures
that have been proposed for parsing sentences with 
respect to a context-free grammar are described in this
paper by means of a common device.  Each procedure 
is defined by giving an algorithm for obtaining a nondeterministic
Turing Machine recognizer that is 
equivalent to a given context-free grammar.  The formalization
of the Turing Machine has been chosen 
to make possible particularly simple description of
the parsing procedures considered.  An attempt has 
been made to compare recognition efficiencies for the
procedures defined.  For a few simple grammars 
and sentences a formal comparison has been made.  Empirical
comparison of the recognition of more realistic 
programming languages such as LISP and ALGOL has been
made by means of a program which simulates the 
Turing Machine on the Univac M-460 computer.  Several
algorithms for producing grammars equivalent to 
a given context-free grammar have been considered, and
the increase in recognition efficiency they afford 
has been empirically investigated.
.I 1266
.T
Considerations Relating to Purpose of FORTRAN Standardization
(Appendixes to ASA FORTRAN Standard)
.I 1267
.T
Performance of Systems Used for Data Transmission
Transfer Rate of Information Bits -An ASA Tutorial 
Standard
.W
Information thruput as a characteristic of
systems performance is discussed.  This discussion 
includes the pertinent aspects of information transfer,
of determination of transfer rate of information 
bits (TRIB), of residual errors, and of standard measurement
conditions.  The paper also presents an 
orderly arrangement of characteristics and parameters
that affect information thruput, and some examples 
on procedures for determining a thruput rate in terms of
TRIB.  It concludes that a performance characteristic 
involving information rate can best be expressed as the
TRIB in conjunction with the Residual Error Rate.
.I 1268
.T
Logarithm of a Complex Number (Algorithm 243 [B3])
.I 1269
.T
Computation of Fourier Coefficients (Algorithm [C6])
.I 1270
.T
On ALGOL Education: Automatic Grading Programs
.W
Two ALGOL grader programs are presented for
the computer evaluation of student ALGOL programs. 
One is for a beginner's program; it furnishes random data
and checks answers. The other provides a searching 
test of the reliability and efficiency of an integration
procedure.  There is a statement of the essential 
properties of a computer system, in order that
grader programs can be effectively used.
.I 1271
.T
Secondary Key Retrieval Using an IBM 7090-1301 System
.W
The secondary key retrieval method involves
the preparation of secondary storage lists from 
primary data records. Search requests are satisfied by
logical operations on appropriate lists, producing 
a complete set of addresses of primary records relevant
to the request.  Experimental results are presented 
and a comparative analysis is given.
.I 1272
.T
Expanding the Editing Function In Language Data Processing
.W
In automatic abstracting, citation indexing,
mechanical translation and other such procedures, 
editing is required whenever the automatic method leaves
something to be desired.  This paper discusses 
the economy of editing as a function of the amount of condensation
of text in language processing operations, 
and then contends that editing can be regarded as an
opportunity rather than as an unwelcome necessity. 
 "Heavy editing," which goes beyond mere correction
and improvement of computer output, is exemplified 
by the use of a concordance in preparing a survey article
or lecture.  Other opportunities for heavy 
editing are described, chief among them being interpretation and
expansion of computer output in such 
processes as factor analysis.  Applications are described,
such processes as factor analysis.  Applications 
are described, such as the quick, unbiased evaluation
of a large volume of incoming mail or telegrams, 
yielding summary reports not possible for either
humans or computers to produce alone.
.I 1273
.T
Remark on Romberg Quadrature
.W
A modified form of Romberg quadrature is described,
which is less sensitive to the accumulation 
of rounding errors than the customary one.
.I 1274
.T
On the Numerical Solution of an N-Point Boundary
Value Problem for Linear Ordinary Differential 
Equations
.W
A method for the numerical solution of then-point
boundary value problem for homogeneous linear 
ordinary differential equations is developed.  The
method requires two Runge-Kutta integrations over 
the interval under consideration and the solution of
a linear system of equations with n-1 unknowns.
.I 1275
.T
Code Structures for Protection and Manipulation
of Variable Length Items (Corrigendum)
.I 1276
.T
Still Another Use for FORTRAN II Chaining
.I 1277
.T
The Use of Cobol Subroutines in Fortran Main Programs
.I 1278
.T
Wengert's Numerical Method for Partial Derivatives,
Orbit Determination and Quasilinearization
.W
In a recent article in the Communications
of the ACM, R. Wengert suggested a technique for 
machine evaluation of the partial derivatives of a function
given in analytical form.  In solving non-linear 
boundary-value problems using quasilinearization many
partial derivatives must be formed analytically 
and then evaluated numerically.  Wengert's method appears
very attractive from the programming viewpoint 
equations which might not otherwise be undertaken.
.I 1279
.T
Use of a Conditional Base Number System for
Encoding Sequences of Correlated Characters
.W
A procedure is described for the relatively
efficient encoding of sequences of characters which 
have predecessor-successor selection rules.  The procedure
is shown to assign a unique integer to each 
sequence and to generate a reasonably compact set of values.
.I 1280
.T
Numerical Integration of a Differential-Difference
Equation with a Decreasing Time-Lag
.W
Systems in which variable time-lags are present
are of common occurrence in biology.  Variable 
flow rates are a common cause of these variable lags.
 At present no extensive body of knowledge exists 
concerning the effects which these variable lags can
cause.  Shown here is a method of reducing some 
differential-difference equations to ordinary differential
equations which can then be studied numerically 
with ease.  Subsequent study will deal with situations
in which multiple-lags and lags dependent on the 
solution itself are present.
.I 1281
.T
Data Input by Question and Answer
.W
A data input scheme for a time-sharing computer
is described in this paper.  Instead of using
format statements to determine the input, the computer
asks the user for the required values one at a 
time.  The computer converses with the user during the
input process, checks for errors, provides standard 
data, and allows editing of values input.
.I 1282
.T
The Use of FORTRAN in Subroutines with COBOL Main Programs
.W
By using the proper COBOL coding techniques and
accounting for differences in storage allocation 
and library routines between the two languages, it is
possible to write FORTRAN IV subroutines that may 
be called from COBOL main programs.  Such a technique
enables the programmer to take advantage of the 
most useful properties of each language while
minimizing their respective disadvantages.
.I 1283
.T
Matrix Inversion (Algorithm 231 [F1])
.I 1284
.T
Bessel Function for a Set of Integer Orders
.I 1285
.T
Eigenvalues and Eigenvectors of a Real Symmetric
Matrix by the QR Method (Algorithm 254 [F2])
.I 1286
.T
Eigenvalues of a Real Symmetric Matrix
by the QR Method (Algorithm 253 [F2])
.I 1287
.T
Vector Coupling or Clebsch-Gordan Coefficients (Algorithm 252 [Z])
.I 1288
.T
CLP-The Cornell List Processor
.W
Presented in this paper are the highlights of
CLP, a teaching language which has been employed 
at Cornell University and was constructed to serve as a means
of introducing simulation and other list-processing 
concepts.  The various advantages of CLP are discussed and examples are given.
.I 1289
.T
Proposed Revised American Standard Code for Information Interchange
.I 1290
.T
Transparent-Mode Control Procedures for Data
Communication, Using the American Standard Code 
for Information Interchange -A Tutorial
.W
This paper gives the considerations of Task
Group X3.3.4 in the area of transparent-mode data 
communication control philosophy.  The appearance of this
paper was forecast (underthe name of "second-level 
control") in the earlier tutorial paper, "Control Procedures
for Data Communications," Task Group document 
X3.3.4.44, dated May 1964.  The present paper elaborates
upon solutions to the problems of transparency 
to the basic ASCII communication control characters
as outlined in the previous paper mentioned above. 
 Moreover, it goes on to cover the additional control problems
of handling material such as off line encrypted 
data or non-ASCII codes by means of systems providing
complete character transparency.  It does not cover 
concepts of transparency in which the normal character
structure or modulation rate of a system may be 
abandoned.  In conjunction with the earlier tutorial
paper, this paper is expected to lead to a proposal 
for stand ardizationof data communication control procedures
using the American Stand ard Code for Information 
Interchange.
.I 1291
.T
Tabular Input of Data 
.I 1292
.T
On a Divide-and-Correct Method For Variable Precision Division
.W
Described in this paper is a divide-and-correct
method for variable precision division in digital 
computers.  Unlike the earlier methods of Stein and
Pope, the present method uses a suitably rounded 
form of the normalized divisor for getting an estimate
of the quotient characters.  This results in a 
correction of at most plus or minus one to the estimate,
to obtain the exact quotient character.  It 
is believed that this method will be widely applicable
for division operations in variable word-length 
character-oriented machines.
.I 1293
.T
Method is Randomness 
.W
Certain nonrandom properties of a commonly used
random number generator are described and analyzed.
.I 1294
.T
Note on Triple-Precision Floating-Point Arithmetic with 132-Bit Numbers
.W
In a recent paper, Gregory and Raney described
a technique for double-precision floating-point 
arithmetic.  A similar technique can be developed for
triple-precision floating-point arithmetic and 
it is  the purpose of this note to describe this technique.
 Only the multiplication and the division 
algorithms are described, since the addition-subtraction
algorithm can be obtained by a trivial modification 
of the algorithm in Gregory's and Raney's paper.
.I 1295
.T
PERT Time Calculations Without Topological Ordering
.W
A simplified technique is presented for PERT
Time calculations without topological ordering. 
 Each event is assigned a unique memory location.  An activity
is represented by a link.  A link is defined 
as a memory location containing the address of another
memory location.  The time information for an 
activity is carried with its link.  For a typical net,
the majority of activities can be described by 
one 36-bit cell each.  The remainder use two 36-bit
cells each.  The links are unidirectional; forward 
during the T(E) calculation (expected completion time for
an activity);backward during the T(L) calculation 
(time latest allowable for completion of an activity). 
The calculations progress through the net topologically 
even though the net is not represented topologically in core.
.I 1296
.T
Ative (Algorithm 205 [E4])
.I 1297
.T
Steep1 (Algorithm 203 [E4])
.I 1298
.T
Adaptive Numerical Integration by Simpson's Rule (Algorithm 145 [D1])
.I 1299
.T
Solutions of the Diophantine Equation (Algorithm 139 [A1])
.I 1300
.T
Function Minimization (Algorithm 251[E4])
.I 1301
.T
On ALGOL I/O Conventions
.I 1302
.T
Parallel Signaling Speeds for Data Transmission
(Proposed American Stand ard)
.I 1303
.T
A Correspondence Between ALGOL 60 and Church's Lambda-Notation: Part II*
.I 1304
.T
A Rapid Turnaround Multi-Programming System
.W
In this paper, basic features, system characteristics
and the control algorithm for a multi-programming 
system with rapid turnaround time are described.
.I 1305
.T
The Internal Structure of the FORTRAN CEP Translator
.W
The FORTRAN CEP translator converts a source
program written in the FORTRAN CEP language into 
an object program written in the language of the CEP
computer.  In this paper, after an outline of the 
CEP computer, the internal structure of the translator
is described.  Emphasis is on the compilation 
of expressions, of input/output lists, and of subscripted variables.
.I 1306
.T
A Class of Unambiguous Computer Languages
.W
Discussed in this paper is the concept of
a fully nested computer language which may be one 
means of designing computer languages which would be completely
free of ambiguities.  Several suggestions 
are also given here for the redefinition of ALGOL as a fully nested language.
.I 1307
.T
A Lightpen-Controlled Program For On-Line Data Analysis
.W
This paper describes a technique designed
to ease the use of a data processing system by a 
person, in particular, a scientist, who is intimately and
primarily concerned with interpreting the significance 
of data handled by the system.  Since such a person is
often unable to spend the time necessary to master 
a programming language, it is essential that he be aided
in composing commands to the computer.  In the 
system described, the user is not required to learn
or remember the vocabulary of the language because 
the vocabulary is displayed before him on"menus" by
means of a computer-drive scope.  He selects the 
various vocabulary elements required by pointing with
the light pen.  By use of a small unordered set 
of rewriting rules applied as a result of light pen
selections, the user generates only syntactically
correct commands to the system.  He does not have to learn
or remember the grammar.  The program restricts 
the user severely in the particular language he can use,
but the method for communicating with the program 
makes these restrictions seem quite natural and unconstraining.
 The program has been used successfully 
for over ten months.
.I 1308
.T
A Mathematical Model for Mechanical part Description
.W
The flexibility of a mathematical model takes
advantage of the common information requirements 
of computer-aided engineering drawing, numerical control
tape generation, and physical characteristic 
computation.  By judicious control of man-machine communication
requirements, improved results over conventional 
engineering design processes are possible.  An English-like
input language, tailored for use by draftsmen 
and designers, will describe the part and specify the
output desired.  One approach to the mathematical 
model consists of a group of surface-defining quadric
equations, which are created by a system of modular 
subprogram.  Other subprograms will convert the mathematical
model into instructions for driving automatic 
drafting machines and numerical controlled machine tools.
 Physical part characteristics, such as center 
of gravity, can be computed by subprograms and used in
dynamic analysis work.  The proposed overall system 
is presented and experiments and demonstrations are discussed.
.I 1309
.T
A Computer User-Oriented System
.W
A computer language system has been developed
which makes possible fast preparation of management 
reports, regardless of computational complexity or format
variety.  Costs are sufficiently low so that 
individually tailored reports can be prepared for every
manager.  The system requires initial preparation 
of large data banks containing data in elementary form.
 Use of two special languages, EXTRACT and MATRAN, 
permits selective extraction of any data subset, efficient
processing through any computational sequence, 
and flexible presentation of results in either tabular
or graphical form.  Matrix algebra is used as 
a fundamental vehicle for accomplishing both manipulation and computation.
.I 1310
.T
A Rapid Braille Transliteration Technique for Certain IBM Machines
.I 1311
.T
Efficient Autocorrelation 
.I 1312
.T
Recursion and Iteration
.I 1313
.T
Construction of Nonlinear Programming Test Problems
.I 1314
.T
The Organization of Symbol Tables
.W
An efficient symbol table organization is an
important feature in the design of any compiler. 
 During the construction of the Virginia ALGOL 60 compiler
for the Burroughs B205, the primary consideration 
in the symbol table design was that the recognition of
identifiers and reserved words should be as rapid 
as possible.  The general features of the technique are described.
.I 1315
.T
Automation of the Radioisotope Accountability System
.W
The Radioisotope Service of the Veterans Administration
Hospital, Omaha, Nebraska, used a manual 
system of radioisotope accountability for three years.  The
procedure which was satisfactory but time-consuming 
was converted from manual to a fully automated computer
system in January, 1963.  The program for purchased 
radioisotopes is written in FORMAT FORTRAN for the IBM
1620 Computer.  A second program for maintaining 
accountability for reactor-created radioisotopes is written
 in the FORCOM programming language.  A minimum 
amount of bookkeeping is required by the reactor operating
staff.  The United States Atomic Energy Commission 
regulations specify that records be kept.  This system
provides detailed records for each container of 
radioactive material purchased and/or created in the Triga
reactor indicating the amounts received, used, 
and/or transferred to the health physicist for disposal.
 Consolidated records contain total amounts 
received, used, and/or disposed of for any specified period
of time.  Purchased radioisotopes are reported 
in millicuries; reactor-created radioisotopes in microcuries.
.I 1316
.T
Bessel Functions of the First Kind (Algorithm 236 [S17])
.I 1317
.T
Poisson-Charlier Polynomials (Algorithm 234 [S23])
.I 1318
.T
Arccossin (Algorithm 206 [B1])
.I 1319
.T
Crout with Equilibration and Iteration (Algorithm 135 [F4])
.I 1320
.T
Inverse Permutation (Algorithm 250 [G6])
.I 1321
.T
Outreal N (Algorithm [I5])
.I 1322
.T
Netflow (Algorithm 248 [H])
.I 1323
.T
A Correspondence Between ALGOL 60 and Church's Lambda-Notation: Part I*
.W
This paper describes how some of the semantics
of ALGOL 60 can be formalized by establishing 
a correspondence between expressions of ALGOL 60 and expressions
in a modified form of Church's L-notation. 
 First a model for computer languages and compute behavior
is described, based on the notions of functional 
application and functional abstraction, but also having
analogues for imperative language features.  
Then this model is used as an "abstract object language"
into which ALGOL 60 is mapped.  Many of ALGOL 
60's features emerge as particular arrangements of
a small number of structural rules, suggesting new 
classifications and generalizations.  The correspondence
is first described informally, mainly by illustrations. 
 The second part of the paper gives a formal description,
i.e. an "abstract compiler" into the "abstract 
objct language."  This is itself presented in a "purely
functional" notation, that is one using only 
application and abstraction.
.I 1324
.T
Answering English questions by Computer: A Survey
.W
Fifteen experimental English language question-answering
systems which are programmed and operating 
are described and reviewed.  The systems range from a conversation
machine to programs which make sentences 
about pictures and systems which translate from English
into logical calculi.  Systems are classified 
as list-structured data-based, graphic data-based, text-based
and inferential.  Principles and methods 
of operations are detailed and discussed.  It is concluded
that the data-base question-answer has passed 
from initial research into the early developmental
phase.  The most difficult and important research 
questions for the advancement of general-purpose language
processors are seen to be concerned with measuring, 
dealing with ambiguities, translating into formal
languages and searching large tree structures.
.I 1325
.T
Remote, On-Line, Real-time Computer Diagnosis
of the Clinical Electrocardiogram
.W
Presented in this paper is a brief report on
the hardware, software, system configuration and 
function of a system for the remote, online, real-time digital
computer diagnosis of clinical electrocardiograms. 
 It seems likely that efforts of this sort will lead
to a satisfactory solution to the problem of the 
automatic diagnosis of electrocardiograms.  Current
attempts by the authors to extend the diagnostic 
capabilities of the present system are particularly concerned
with increasing the fidelity of the adaptive 
matched filters, the development of three dimensional pattern analysis,
the analysis of parallel electrocardiographer-computer 
diagnostic interaction, and a study of the possibility
of introducing major, tree-like branching decisions 
early in the diagnostic process.
.I 1326
.T
Boundary Networks
.W
A feasible computer procedure is described
for determining the total or partial inclusion of 
arbitrarily given points and lines with respect to a
set of general polygonal domains which partition 
a plane bounded region.  A scheme for the computer representation
of the boundaries of the domains and 
an algorithm, based on this  scheme, for evaluating
the inclusion relations are specified in detail. 
 The method employs several levels of selection criteria
for the purpose of reducing the number of accesses 
to auxiliary storage devices and the amount of boundary
data for which processing is required.
.I 1327
.T
Use of Decision Tables in Computer Programming
.W
A decision table is a tabular form for displaying
decision logic.  Decision tables have many 
inherent advantages.  The technique to be illustrated
puts these advantages to use in that it enables 
one to program directly from a decision table.  The technique
is based on the creation of a binary image 
of a limited entry decision table in computer memory.
 A binary image of a given set of input conditions 
can also be created.  This data image is used to scan
the decision table image to arrive at the proper 
course of action.  There are several advantages gained
from the programming point view: (1) amount of 
computer memory used is drastically reduced, (2) programming
is simplified, and (3) documentation is 
brief and clear.
.I 1328
.T
Further Remarks on Reducing Truncation Errors
.I 1329
.T
Simulation of Boolean Functions in a Decimal computer
.I 1330
.T
Automated Plotting Flow-Charts on a Small Computer
.I 1331
.T
Code Structures for Protection and Manipulation of Variable-Length Items
.W
When items are made up of a variable number
of characters, each containing the same number 
of bits, certain control information (partition symbols)
is inserted to mark their separations.  Since 
errors in identification of these control characters
can lead to serious trouble, methods of protecting 
these symbols are indicated.  A 6-bit code assignment
of alphanumeric characters for fixed word-length 
computers is given and its suitability for error detection
and variable-length item manipulation is shown. 
 Also indicated is its flexibility during certain arithmetic operations.
.I 1332
.T
Subroutine Assembly
.W
A description is given of an assembly system,
which requires only one pass and does not maintain 
a table of information about the subroutine library.
.I 1333
.T
Reducing Truncation Errors Using Cascading Accumulators
.W
When accumulating a large number of quantities
as in numerical integration, the sum itself 
may become much larger than the individual addends.
 This results in truncation error.  Much of this 
error can be eliminated using cascading accumulators
as noted in a recent article by Wolfe.  A simpler 
and slightly more flexible algorithm is presented which
deals also with the case of negative addends.
.I 1334
.T
Mechanization of Tedious Algebra: The
Newcomb Operators of Planetary Theory
.W
A computer program has been written to generate
tables of formulas for the Newcomb operators 
of planetary theory.  The Newcomb operators are expressed
as polynomials in two variables, one of which 
stands for a simple differential operator, and the other
for an arbitrary integer.  The polynomials are 
generated by a recurrence scheme.  The program is coded in
FORTRAN, using simple array manipulation techniques 
to perform the algebraic operations.  Formulas for over
100 Newcomb operators have been produced by the 
program and typeset photographically on an S-560 Photon system.
.I 1335
.T
Character Set for Optical Character
Recognition (Proposed American Stand ard)
.I 1336
.T
NPL: Highlights of A New Programming Language
.I 1337
.T
EULER: A Generalization of ALGOL, and its Formal Definition
.I 1338
.T
Additional Comments on a Problem in Concurrent Progamming Control
.I 1339
.T
A Contribution to the Development of ALGOL
.I 1340
.T
Multiplexing of Slow Peripherals
.W
The philosophy of a monitor which allows slow
output devices to be multiplexed is presented.
.I 1341
.T
Levels of Computer Systems
.W
In building current computer systems, we tend
to break them down into "levels" of control, 
command and communication; in using the system, we break
our problems down correspondingly.  The continued 
use of such a structure raises questions about its effects
on the usefulness of future systems, particularly 
with regard to such trends as time sharing, parallel
programming, and, eventually, systems which learn. 
 In this essay some of these questions are posed, and
the general attitude we must take in pursuing the 
problem further is discussed.
.I 1342
.T
Transportation Problem (Algorithms 293 [H])
.I 1343
.T
Havie Integrator (Algorithm 257 [D1])
.I 1344
.T
Statistical Computations Based Upon Algebraically Specified Models
.W
Based upon a machine-readable statistical model
and related symbolic specifications, an efficient 
method of performing calculations for statistical models
of a balanced complete nature is presented. 
 Fixes, mixed, and random analysis of variance models
are considered.  A procedure for obtaining variance 
components and calculated F statistics for the model terms is included.
.I 1345
.T
Tensor Calculations on the Computer
.W
A FORMAC program has been written which is capable
of calculating various quantities of interest 
in tensor calculus.  Using this code, Christoffel symbols
have been calculated for 12 basic orthogonal 
coordinate systems.
.I 1346
.T
On the Application of the Process of Equalization
of Maxima to Obtain Rational Approximation 
to Certain Modified Bessel Functions
.W
The second Remes algorithm as originally established
for polynomials, may converge or not when 
the approximating functions are rational.  However, the
few results known in this domain show how efficient 
the algorithm can be to obtain approximations with a
small error, much more than in the polynomial case, 
in which the best approximation can be very nearly
approached directly by a series development.  The 
aim of this paper is to investigate the limitations
of the applicability of certain extensions of the 
algorithm to the case where the approximations are rational
as well as to present some numerical results.
.I 1347
.T
General Time-Varying Systems Error Sensitivities Program
.W
The evaluation, by the propagation of variance
technique, of the sensitivity of time-varying 
systems to initial condition and parameter errors, involves
the determination of several system-dependent 
partial derivative matrices.  This requirement has led to
separate programs for each system under investigation. 
 A new program, through utilization of the Wengert differentiation
technique, automatically determines 
the required matrices from specific system equations supplied
in subroutine form at execution time, eliminating 
the need for individualized programs, and presaging the
further development of extremely general computer 
programs.
.I 1348
.T
FLOWTRACE, A Computer Program for Flowcharting Programs
.W
The FLOWTRACE system produces flowcharts of programs
written in "almost any" programming language. 
 One most describe the syntax of the control statements
in his language; for this purpose a metalanguage 
is available.  The resultant object deck is used to
flowchart any programs in the language described. 
 Several examples of FAP and SNOBOL flowcharts are given.
 However, it is not necessary to confine one's 
scope to existing languages.  One may define his own
language in any "well-structured" manner.  This 
feature is particularly useful when it is desirable
to chart only comments within a program.  Such an 
approach permits the documentation of descriptive remarks
and avoids the inclusion of coding details.
.I 1349
.T
Computing Capabilities at Western European Universities
.W
This report on the author's trip to universities
in Western Europe in the summer of 1966 gives 
brief descriptions of computing activities at each institution
visited.  Present equipment capabilities 
vary from moderate to large scale; however, many institutions
plan to acquire complex time-shared systems 
in the near future.  In the author's opinion, the state
of the art lags behind that on this continent. 
 This lag is attributed to four principal factors: (a)
the handicapping organization of academic procedures; 
(b) the university-government financial relationship;
(c) the subordinated organization of the computing 
facility; (d) the paucity of professional interchange
of knowledge.  The effects of these constraints 
are explicated.
.I 1350
.T
The Augmented Predictive Analyzer for Context-Free
Languages-Its Relative Efficiency
.W
It has been proven by Greibach that for a given
context-free grammar G, a standard-form grammar 
Gs can be constructed, which generates the same languages
as is generated by G and whose rules are all 
of the form Z --> cY(1) ... Y(m), (m >= O) where Z and
Y(i) are intermediate symbols and c a terminal 
symbol.  Since the predictive analyzer at Harvard uses
a standard-form grammar, it can accept the language 
of any context-free Grammar G, given an equivalent standard-form
grammar Gs.  The structural descriptions 
SD(Gs,X) assigned to a given sentence X by the predictive
analyzer, however, are usually different from 
the structural descriptions SD(G,X) assigned to the
same sentence by the original context-free grammar 
G from which Gs is derived.  In Section 1, an algorithm,
originally due to Abbott is described standard-form 
grammar each of whose rules is in standard form, supplemented
by additional information describing its 
derivation from the original context-free grammar. 
A technique for performing the SD(Gs,X) to SD(G,X) 
transformation effectively is also described.  In section
2, the augmented predictive analyzer as a parsing 
algorithm for arbitrary context-free languages is compared
with two other parsing algorithms: a selective 
top-to-bottom algorithm similar to Irons' "error correcting
parse algorithm" and an immediate constituent 
analyzer which is an extension of Sakai-Cocke's algorithm
for normal grammars.  The comparison is based 
upon several criteria of efficiency, covering core-storage
requirements, complexities of the programs 
and processing time.
.I 1351
.T
Automatic Error Bounds on Real Zeros of Rational Functions
.W
A procedure for implementing an interval arithmetic
version of the Newton-Raphson method is 
proposed.  The procedure require only a starting interval
over which the zeros of a given rational function 
are to be located.  The method automatically provides bounds 
for roundoff error.
.I 1352
.T
Automatic Integration of a Function with a Parameter
.W
Two efficient methods for automatic numerical
integration are Romberg integration and adaptive 
Simpson integration.  For integrands of the form f(x)g(x,a)
where a is a parameter, it is shown that 
Romberg's method is more efficient.  A FORTRAN program
shows how to achieve this greater efficiency.
.I 1353
.T
Techniques for Automatic Tolerance Control in Linear Programming
.W
In this technical note, the numerical steps
for the simplex method of linear programming are 
reviewed and the tolerances needed in the numerical procedure
are defined.  Objective criteria are given 
for accomplishing the numerical steps of the method
and the calculation of necessary tolerances.
.I 1354
.T
Conversion of Decision Tables to Computer
Programs by Rule Mark Techniques
.W
The rule mask technique is one method of converting
limited entry decision tables to computer 
programs.  Recent discussion suggest that in many circumstances
it is to be preferred to the technique 
of constructing networks or trees.  A drawback of the
technique as hitherto presented is its liability 
to produce object programs of longer run time than necessary.
 In this paper a modification of the technique 
is discussed which takes into account both rule frequencies
and the relative times for evaluating conditions. 
 This can materially improve object program run time.
.I 1355
.T
Regular Coulomb Wave Functions (Algorithm 292 )
.I 1356
.T
Havie Integrator (Algorithm 257 [D1])
.I 1357
.T
Examination Scheduling (Algorithm 286 [H])
.I 1358
.T
Syntax Macros and Extended Translation
.W
A translation approach is described which allows
one to extended the syntax and semantics of 
a given high-level base language by the use of a new
formalism called a syntax-macro.  Syntax-macros 
define string transformations based on syntactic elements
of the base language.  Two types of macros 
are discussed, and examples are given of their use.  The
conditional generation of macros based on options 
and alternatives recognized by the scan are also described.
.I 1359
.T
Data Filtering Applied to Information Storage and Retrieval Applications
.W
Manipulation of data strings is the most complex
processing function in information storage 
and retrieval applications.  Data string manipulation
is discussed within the context of an interpretive 
processing environment controlled by the use of procedural
directives.  The sequence of procedural directives 
is derived from a job assumed to be expressed in a user-oriented
source language.  Each data string with 
the structured data environment (data bank) is explicitly
or implicitly related to a format declaration
residing in a format library.  The processing mechanics
associated with data string manipulation is developed 
in accordance with a generalized data filtering concept.
 This results in the implementation of a two-part 
data filter module that satisfies internal processing
functions by filtering data strings through format 
declarations associated with its input and output ports.
.I 1360
.T
Description of Systems Used for Data Transmission* (An ASA Tutorial)
.I 1361
.T
Rectangular Holes in Twelve-Row Punched
Cards* (Proposed American Standard)
.I 1362
.T
Code Extension in ASCII* (An ASA Tutorial)
.W
The American Standard Code for Information
Interchange (ASCII) contains a number of control 
characters associated with the principle of code extension,
that is, with the representation of information 
which cannot be directly represented by means of the characters
in the Code.  The manner of use of these 
characters has not previously been completely described.
 This paper presents a set of mutually consistent 
philosophies regarding code extension applications,
and suggests a corollary set of doctrines for the 
application of the code extension characters.  Distinctions
are drawn between code extension and such 
other concepts as "graphic substitution" or "syntactic
representation" which are often used to meet similar 
requirements.  Also covered are certain topics which
are not truly concerned with code extension but 
which are often linked with it in discussion on code applications.
 The material in this paper is equally 
applicable in principle to the (proposed) ISO international
7-bit code for information interchange.
.I 1363
.T
A General Method of Systematic Interval Computation
for Numerical Integration of Initial Value 
Problems
.W
A procedure is given for continuously computing
and monitoring the step size to be used by 
a self-starting, p-th order numerical integration method
to solve an initial value problem.  The procedure 
uses an estimate of the truncation error to calculate the step size.
.I 1364
.T
Mathematical Experimentation in Time-Lag Modulation
.W
Equations of the form du/dt = g(u(t),u(h(t)))
arise in a number of scientific contexts.  The 
authors point out some interesting properties of the
solution u'(t) = -u(t-1-k*sin(wt))+sin(at).  These 
properties were obtained by means of numerical solution.
.I 1365
.T
Eliminating Monotonous Mathematics with FORMAC
.W
The FORMAC (FORmula MAnipulation Compiler)
programming system provides a powerful tool for 
performing mathematical analysis.  It is an extension
of FORTRAN IV which permits the use of the computer 
to perform the tedious algebraic computations that arise
in many different fields.  Among the areas in 
which it has been successfully used are: differentiation
of complicated expressions, expansion of truncated 
power series, solution of simultaneous equations with
literal coefficients, nonlinear maximum likelihood 
estimation, tensor analysis, and generation of the coefficients
of equations in Keplerian motion.  These 
types of analysis-which arose in the solution of specific
practical problems in physics, engineering, 
astronomy, statistics and astronautics-are discussed in
the paper.  In addition to its usage for specific 
problem solutions, FORMAC can also be used to automate
the analysis phase in certain production programming. 
 Several such applications are presented.
.I 1366
.T
Computer Simulation-Discussion of the
Technique and Comparison of Languages 
.W
The purpose of this paper is to present a comparison
of some computer simulation languages 
and of some of the involved in comparing software packages
for digital computers are discussed in Part 
I.  The issue is obvious: users of digital computers
must choose from available languages or write their 
own.  Substantial costs can occur, particularly in training,
implementation and computer time if an inappropriate 
language is chosen.More and more computer simulation
languages are being developed: comparisons and 
evaluations of existing languages are useful for designers
and implementers as well as users.  The second 
part is devoted to computer simulation and simulation
languages.  The computational characteristics of 
simulation are discussed with  special attention being
paid to a distinction between continuous and discrete 
change models.  Part III presents a detailed comparison
of six simulation languages and packages: SIMSCRIPT, 
CLP, CSL, GASP, CPSS and SOL.  The characteristics of
each are summarized in a series of tables.  The 
implications of this analysis for designers of languages,
for users, and for implementers are developed. 
 The conclusion of the paper is that the packages now
available for computer simulation offer features 
which none of the more general-purpose packages do and
that analysis of strengths and weaknesses of each 
suggests ways in which both current and future simulation
languages and packages can be improved.
.I 1367
.T
Character Structure and Character Parity Sense
for Parallel-by-Bit Data Communication in ASCII* 
(Proposed American Standard)
.I 1368
.T
Systematic Generation of Hamiltonian Circuits
.W
For a combinatorial matrix which may specify
both directed and nondirected arcs, the paper 
describes a computer program which generates systematically
and exhaustively all the Hamiltonian circuits. 
Specific application is made to the "traveling salesman" problem.
.I 1369
.T
Half Rotations in N-Dimensional Euclidean Space
.W
An iterative procedure is described for determining
half rotations in n-dimensional Euclidean 
space. The method is a variant of the cyclic Jacobi
procedure and utilizers elementary plane rotations 
to obtain the half rotation matrix.  Numerical examples are given.
.I 1370
.T
Linear Equations, Exact Solutions (Algorithm 290 [F4])
.I 1371
.T
Logarithm of Gamma Function (Algorithm 291 [S14])
.I 1372
.T
Direct Search (Algorithm 178 [E4])
.I 1373
.T
Gamma Function; Gamma Function for Range 1 to
2; Reciprocal Gamma Function to Real Argument; 
Gamma Function; Logarithm of Gamma Function (Algorithms
34[S14]; 54[S14]; 80[S14]; 221[S14]; 291[S14])
.I 1374
.T
Evaluation of Determinant; Determinant
Evaluation (Algorithms 41[F3]; 269[F3])
.I 1375
.T
Function Minimization (Algorithm 251 [E4])
.I 1376
.T
Modified Graeffee Method (Algorithm 256 [C2])
.I 1377
.T
Pseudo-Random Numbers (Algorithm 266 [G5])
.I 1378
.T
Pseudo-Random Numbers (Algorithm 266 [G5])
.I 1379
.T
A Final Solution to the Dangling Else of ALGOL 60 and Related Languages
.W
The dangling else problem consists of a class
of potential ambiguities in ALGOL-like conditional 
statements whose basic form is "if B1 then if B2 then
S1 else S2" where B1 and B2 are Boolean expressions 
and S1 and S2 are basic statements.  The difficulty
lies in whether to attach the else to the first if 
or to the second one.  Existing solutions to the problem
are either ambiguous or unnecessarily restrictive. 
 Let Sand S1 be statements.  We define S to be closed
if "S else S1" is not a statement, and to be open 
if "S else S1" is a statement.  Thus an unconditional
statement is  a closed statement.  Open and closed 
conditional statements are defined by syntax equations
in such a way as to preserve openness and closure. 
 In each case, an else must always be preceded by a closed
statement.  It is shown that the syntax equations 
are unambiguous, and that may change in the statement
types required within the syntax equations would 
lead to either ambiguity or unnecessary restriction.
.I 1380
.T
SIMULA-an ALGOL-Based Simulation Language
.W
This paper is an introduction to SIMULA, a
programming language designed to provide a systems 
analyst with unified concepts which facilitate the
concise description of discrete event systems.  A 
system description also serves as a source language simulation
program.  SIMULA is an extension of ALGOL 
60 in which the most important new concepts
is that of quasi-parallel processing.
.I 1381
.T
Impact of Computers on the Undergraduate Mathematics Curriculum 
.W
The use of computers to permit the widespread application
of mathematical ideas requiring computation 
in science and technology is extremely significant for
the understanding of our current society.  Student 
interest in this development is intense and if properly
utilized should yield a much better understanding 
of mathematical concepts as well as the ideas of programming
and logical structure which have been introduced 
into many fields by the use of computers.  The present
paper suggests that that portion of the undergraduate 
mathematical curriculum which is preparation for the use
of mathematics by persons who are not professional 
mathematicians be modified to include the extensions
and clarifications which are possible because of 
computers.  An early introduction to programming is
desirable to permit a continuing use of automatic 
computation to illustrate and clarify mathematical concepts.
 Following the calculus equation stage an 
intensive introduction to numerical analysis should
be added to the current curriculum.  In addition 
to providing competence in the mostly used computing
techniques, it would permit a more sophisticated 
utilization of the advanced mathematical ideas associated
with complex variables and transform theories.
.I 1382
.T
Desired Computer Impact on Undergraduate Mathematics 
.W
Three matters relating to the theme of the
Symposium are discussed here.  The author examines 
some projections concerning the supply and demand for
mathematicians in the United States through the 
mid-1970s, comments briefly on some of the factors which
may influence the professional activities of 
applied mathematicians over the next several years,
and discusses in broad terms how this information 
may relate to the undergraduate training of mathematicians.
.I 1383
.T
Implications of the Digital Computer
for Education In the Mathematical Sciences
.W
The digital computer has profoundly altered the
definition of what is interesting in mathematics. 
 The importance of applied logic in human affairs is
changed by the existence of the "logical engine." 
 The result is that one should no longer think in terms
of a single discipline of mathematics but in 
terms of a complex of mathematical sciences.
.I 1384
.T
Mathematics for Undergraduate Computer Scientists
.W
The mathematical requirements for an undergraduate
program in Computer Science are a subject 
of debate.  The Association for Computing Machinery's
Curriculum Committee, however, believes that these 
requirements are essentially the same as the mathematical
content of physical sciences undergraduate 
programs.  The Committee believes that these requirements
should assure the student of a broad mathematical 
background and should enable him to take a wide variety
of courses in other scientific disciplines.  
The Committee's concern is to develop a solid
scientific  approach to Computer Science.
.I 1385
.T
Computer Technology in Communist China, 1956-1965
.W
Based on information from translations of Communist
Chinese news items and periodical literature 
for the 1965 period, computer technology in China is
reviewed under the following headings: (1) initial 
planning, organization and educational aspects of computer
technology and automation; (2) machine development 
progress: two major specific machines in 1958-59, with
Soviet aid; a vacuum in 1960-64 due to the withdrawal 
of Soviet aid; then presumably all-Chinese-made machines
from 1965 to the present; (3) computer applications; 
(4) the trend of automation: control of production processes
rather than data processing; and (5) the 
"Yun Ch'ou Hsueh" (Science of Operation and Programming)
campaign of 1958-60, during which an attempt 
was made to bring concepts such as linear programming
to ordinary Chinese workers and peasants.  Communist 
China is adjudged to have a marginal computer capability,
with most of its machines probably being of 
a binary nature; however, a turning point may have been reached in mid-1965.
.I 1386
.T
Symbolic Factoring of Polynomials in Several Variables
.W
An algorithm for finding the symbolic factors of
a multi-variate polynomial with integer coefficients 
is presented.  The algorithm is an extension of a technique
used by Kronecker in a proof that the prime 
factoring of any polynomial may be found in a finite number
of steps.  The algorithm consists of factoring 
single-variable instances of the given polynomial by
Kronecker's method and introducing the remaining 
variables by interpolation.  Techniques for implementing the
algorithm and several examples are discussed. 
 The algorithm promises sufficient power to be used efficiently
in an online system for symbolic mathematics.
.I 1387
.T
Solution of Systems of Polynomial Equations By Elimination
.W
The elimination procedure as described by Williams
has been coded in LISP and FORMAC and used 
in solving systems of polynomial equations.  It is found
that the method is very effective in the case 
of small systems, where it yields all solutions without
the need for initial estimates. The method, by 
itself, appears in appropriate, however, in the solution
of large systems of equation due to the explosive 
growth in the intermediate equations and the hazards
which arise when the coefficients are truncated. 
 A comparison is made with difficulties found in other
problems in non-numerical mathematics such as 
symbolic integration and simplification.
.I 1388
.T
AUTOMAST: Automatic Mathematical Analysis and Symbolic Translation
.W
A procedure for numerically solving systems
of ordinary differential equation is shown to also 
generate symbolic solutions.  The procedure is based
on a finite Taylor series expansion that includes 
an estimate of the error in the final result.  A computer
program is described that reads in a system 
of such equations and then generates the expansions
for all of the dependent variables. The expansions 
are determined symbolically, hence any non-numeric parameters
in the original equations are carried automatically 
into the final expansions.  Thus the exact influence
of any parameters on the problem solution can be 
easily displayed.
.I 1389
.T
A Programmer's Description of L^6
.W
Bell Telephone Laboratories' Low-Linked List Language
L^6 (pronounced "L-six") is a new programming 
language for list structure manipulations.  It contains
many of the facilities which underlie such list 
processors as IPL, LISP, COMIT ad SNOBOL, but permits
the user to get much closer to machine code in 
order to write faster-running programs, to use storage
more efficiently and to build a wider variety 
of linked data structures.
.I 1390
.T
CONVERT
.W
A programming language is described which
is applicable to problems conveniently described 
by transformation rules.  By this is meant that patterns
may be prescribed, each being associated with 
a skeleton, so that a series of such pairs may be searched
until a pattern is found which matches an 
expression to be transformed.  The conditions for a match
are governed by a code which also allows subexpressions 
to be identified and eventually substituted into the
corresponding skeleton.  The primitive patterns 
and primitive skeletons are described, as well as the
principle which allow their elaboration in to more 
complicated patterns and skeletons.  The advantages of the
language are that it allows one to apply transformation 
rules to lists and arrays as easily as strings, that both
patterns and skeletons may be defined recursively, 
and that as a consequence programs may be stated quite concisely.
.I 1391
.T
Computer Experiments in Finite Algebra
.W
A medium-scale programming system is written
in MAD and FAP on the IBM 7094 to manipulate some 
of the objects of modern algebra: finite groups, maps
and sets of maps, subsets and sets of subsets, 
constant integers and truth-values.  Designed to operate
in a time-sharing environment, the system can 
serve as a teacher's aid to the undergraduate student of
modern algebra, as well as for the working scientist 
or engineer wishing to familiarize himself with the subset.
.I 1392
.T
Experience with FORMAC Algorithm Design
.W
Various facets of the design and implementation
of mathematical expression manipulation algorithms 
are discussed.  Concrete examples are provided by the
FORMAC EXPAND and differentiation algorithms, a 
basic FORMAC utility routine, and an experiment in the
extraction of the skeletal structure of an expression. 
 One recurrent theme is the need to avoid excessive
intermediate expression swell in order to minimize 
core storage requirements. Although many details from
the FORMAC implementation are presented, an attempt 
is made to stress principles and ideas of general relevance
in the design of algorithms for manipulating 
mathematical expressions.
.I 1393
.T
PM, A System for Polynomial Manipulation
.W
PM is an IBM 7094 program system for formal manipulation
of polynomials in any number of variables, 
with integral coefficients unrestricted in size.  Some
of the formal operations which can be performed 
by the system are sums, differences, products, quotients,
derivatives, substitutions and greater common 
divisors.  PM is based on the REFCO III list processing
system, which is described and compared with 
the LISP and SLIP systems.  The PM subroutines for arithmetic
of large integers are described as constituting 
an independently useful subsystem.  PM is compared with
the ALPAK system in several respects, including 
the choice of canonical forms for polynomials.  A new
algorithm for polynomial greatest common divisor 
calculation is mentioned, and exaples are
included to illustrate its superiority.
.I 1394
.T
Computation of Algebraic Properties of Elementary
Particle Reactions Using a Digital Computer
.W
A large number of calculations in high-energy
elementary particle physics involve the manipulation 
of complicated algebraic expressions containing both
tensor and noncommutative matrix quantities.  Many 
of these calculations take several months to complete, although
the operations involved follow straightforward 
rules.  In this paper a program is described, which has
been developed in LISP for solving such problems. 
 The manner in which these problems are encountered is
outlined, and their representation in the computer 
discussed.  At present, about six months of human work
takes less than fifteen minutes on an IBM 7090. 
 Limitations of the present system and future plans are also outlined.
.I 1395
.T
On the Implementation of AMBIT, A Language for Symbol Manipulation
.W
A brief description is given of the implementation
technique for the replacement rule of the 
AMBIT programming language.  The algorithm for the "AMBIT
scan" and an example of its application are 
given.  The algorithm is applicable to other members
of the family of string transformation languages 
of which AMBIT is a member, and it provides a rationale
for the design of the AMBIT language.
.I 1396
.T
Survey of Formula Manipulation
.W
The field of formula manipulation is surveyed,
with particular attention to the specific capabilities 
of differentiation, integration and the supporting capabilities
of simplification, displays and input/output 
editing, and precision arithmetic.  General systems-both
batch and online-are described.  Finally, some 
programs to solve specific applications are discussed.
.I 1397
.T
Proceedings of the ACM Symposium on Symbolic and Algebraic Manipulation
.W
The ACM Symposium on Symbolic and Algebraic
Manipulation brought together over four hundred 
people interested in programming languages designed
for manipulation of algebraic formulas and symbol 
strings, in their applications, and in algorithms for
their implementation.  Twenty-eight papers were 
presented, followed by a lively panel discussion of
future directions.  Evening meetings were arranged 
for several interest groups.  The conference was sponsored
by the ACM Special Interest Committee on Symbolic 
and Algebraic Manipulation.  The program committee consisted
of Chairman Jean E. Sammet, Paul Abrahams, 
Thomas E. Cheatham, Max Goldstein, and Douglas Mcllroy.
 Conference arrangements were made by Lewis C. 
Clapp, Daniel Bobrow and James H. Griesmer.-Robert W. Floyd, Editor
.I 1398
.T
Robot Data Screening: A Solution to Multivariate
Type Problems in the Biological and Social Sciences
.W
A new approach is outlined toward the solution
of the type of multivariate problem that is 
found usually in the biological and social sciences as
well as in medicine.  This approach uses a "logical" 
rather than a "statistical" criterion by which variables
are grouped into a deterministic model.  Algorithm 
are developed by which some variables are kept on for
further analysis while others are eliminated.  
Criteria for the acceptance of a variable as well as the
termination of the searching process are derived 
from information theory.
.I 1399
.T
On Top-to-Bottom Recognition and Left Recursion
.W
A procedure is given for obtaining structural
descriptions in a context-free grammar by performing 
the recognition according to a strongly equivalent, 
left-recursion-freegrammar. The effect of allowing 
null strings in the rewriting rules is discussed.
.I 1400
.T
Free-Text Inputs to Utility Routines
.W
Through the use of some rather simple techniques,
it is frequently possible to produce a program 
which will accept free-text inputs.  The techniques are
discussed and related to a general tape manipulation 
routine.
.I 1401
.T
Quasilinearization and the Calculation of Eigenvalues
.W
Several eigenvalue problems for systems of
ordinary differential equations are considered. 
 They are resolved computationally using the quasilinerization
technique, a quadratically convergent 
successive approximation scheme related to
the Newton-Raphson-Kantorovich method.
.I 1402
.T
Partial Step Integration
.W
A partial step integration equation is derived
for use with the Adams or Adams-Bashforth method 
of integration of differential equations.  This method
of obtaining functional values at points intermediate 
to the integration points yields accuracy comparable
to the integration and does not require storing 
of additional information as in interpolation methods.
.I 1403
.T
A Method for Finding the m Smallest Values of
a Monotonic Function Defined on Ordered Sets of 
Positive Integers
.W
The minimum value of a monotonic increasing
function defined on a partially ordered set S is 
assumed on the set of minimal points of S.  This observation
is used to devise an efficient method for 
finding the m smallest functional values of monotonic
functions defined on ordered pairs of positive 
integers.  The method is easily extended to include
monotonic functions defined on ordered n-tuples. 
 Included is a FORTRAN program which was written to implement
the procedure for a certain important case.
.I 1404
.T
Computational Aspects of Multiple Covariance
Analysis on a Multifactor Structure
.W
The computational procedure for the analysis
of multiple covariance in statistics is discussed 
with reference to the analysis of variance.  A special
operator calculus developed by Hartly for programming 
analysis of variance for multifactor experiments is extended
to cover the analysis of covariance.  This 
extension is accomplished by utilizing the connection
between the analysis of covariance and the analysis 
of variance and by introducing a new operator.  The
results are illustrated by a numerical example for 
analysis of covariance, in which the basic computations
are shown to be carried out by an analysis-of-variance 
program.
.I 1405
.T
Matrix Triangulation with Integer Arithmetic (Algorithm 287 [F1])
.I 1406
.T
Solution of simultaneous Linear Diophantine
Equations (Algorithm 288 [F4])
.I 1407
.T
Confidence Interval for a Ratio (Algorithm 289 [G1])
.I 1408
.T
The Eschenbach Drum Scheme
.W
The prime function of a drum, operating in
real time, is to perform accesses quickly.  The 
usual means for increasing this capacity is to incorporate
engineering or hardware improvements.  In 
this paper the problem is attacked not by changing the
drum, but rather by modifying the manner in which 
it operates.  At the outset, a drum is given a functional
definition.  Then a simple design scheme (Eschenbach) 
is introduced which enormously increases the rate of
accessing for drums so defined.  This is shown to 
enable a system to perform a job by employing fewer or
less expensive drums.  It is suggested that although 
the design scheme has a specific use, the method underlying it
has more general applicability.  The question 
of the efficacy of the drum scheme is then raised.  To
deal with this, a standard of efficiency is developed 
in light of realistic real-time circumstances.  The drum
scheme is then modelled in a manner which permits 
it to be analyzed as a problem in queueing theory. 
Thus one is enabled to ascertain whether the drum 
scheme is efficient enough for its application.  Again,
whereas the analysis of the drum scheme has a 
specific use, the methods underlying it have more general applicability.
.I 1409
.T
NEBULA: A Digital Computer Using a 20 Mc Glass Delay Line Memory
.W
Oregon State University has designed and constructed
a medium-speed serial digital computer 
using glass delay lines circulating at 22 Mc as memory.
 The design objectives as originally conceived 
in a special seminar were: (1) to be a research project
in computer design; (2) to be usable as an educational 
machine;and (3) to have easily modifiable hardware for
basic research in computer systems design.  An 
unusual arrangement of information within the 22 Mc
memory allows a simple interface with the 340 Kc 
arithmetic unit, which results in an effective zero latency
time and provides possibilities for an associative 
memory.  The arithmetic unit has a command structure similar
to large parallel machines, and uses flip-flop 
arithmetic and control registers throughout.  All hardware
development has been aimed toward the concept 
of easy modification, elaborate console controls for
effective man-machine interaction and low cost.
.I 1410
.T
Interarrival Statistics for Time Sharing Systems
.W
The optimization of time-shared system performance
requires the description of the stochastic 
processes governing the user inputs and the program activity.
 This paper provides a statistical description 
of the user input process in the SDC-ARPA general-purpose
Time-Sharing System (TSS).  The input process 
is assumed to be stationary, and to be defined by the
interarrival time distribution.  The data obtained 
appear to justify satisfactorily the common assumption
that the interarrival times are serially independent. 
 The data do not appear to justify, except as a very
rough approximation, the usual assumption off an 
exponential distribution for interarrival time.  A much
more satisfactory approximation to the data can 
be obtained with a biphase or triphase hyperexponential distribution.
.I 1411
.T
Comparison of Several Algorithms for Computation
of Means, Standard Deviations and Correlation 
Coefficients
.W
Several algorithms for computation of basic
statistics are compared by their performance on 
systematically generated test data.  The statistics
calculated were the mean, standard deviation and 
correlation coefficient.  For each statistic, the algorithm
included the usual computing formulas, correction 
due to an accumulated error term, and a recursive computation
of the current value of the statistic. 
 The usual computing formulas were also evaluated in
double precision.  Large errors were noted for some 
calculation using the usual computing formulas.  The most
reliable technique was correction of the initial 
estimate by use of an accumulated error term.  To eliminate
the need for making two passes on the data, 
it was suggested that the initial estimate of the
mean be obtained from a subset of the data.
.I 1412
.T
The Banking Information System Concept
.W
Most large commercial banks have progressed to
the  point where their major accounting applications 
have been automated and more sophisticated usage of
data processing equipment is being sought.  This, 
coupled with the availability of equipment well suited
to real-time, direct access processing,has led 
to development within some banks of the central file
of data base approach toward a banking information 
system.  The banking information system now serves the
two-fold purpose of providing real-time responses 
to inquires about individual account stasus and providing
more complex combinations of information for 
management use.  Both kinds of processing draw upon a
common store of data contained in the direct access 
central file.  This data base includes indexes which
facilitate cross referencing of account information 
so that all relationships between bank and customer may
be discerned.  In introducing the banking information 
system concept, a gradual approach to account cross-referencing
and file conversion is most prudent. 
 Generally, this system must interface with other computer
applications already existing within the bank.
.I 1413
.T
A Vision of Technology and Education
.W
Educational technology is currently quite
fashionable.  Here, as in many other branches or 
aspects of technology, changes possible in the next generation
or two are now known as ideas, discoveries 
or inventions.  The unknown is whether the potential
will become the actual and, if so, on what time 
scale.  This ignorance stems largely from ignorance about
the social response to potential technological 
change.  The object of this paper is to present a vision
of potential educational technology and to raise 
questions about the modes of social response and
adaptation likely to be evoked by such a vision.
.I 1414
.T
Twelve-Row Punched-Card Code for Information
Interchange* (Proposed American Standard)
.I 1415
.T
Automatic Derivation of Microsentences
.W
The decomposition of long complex English sentences
into shorter kernel-like constituent sentences 
(microsentences)has often been suggested as an avenue
toward conducting automatic retrieval of natural 
language messages.  To explore the prospects of such
a step, the authors attempted in 1963 to prepare 
a general program for deriving microsentences from longer
sentences that had been syntactically analyzed 
by the Harvard Multipath Analysis Program.  The basic
idea was to extract the subject, verb and object 
(if any) of each clause and to reassemble these materials
into a grammatical microsentence.  A program 
is described in this paper, which was designed to operate
on the tree structure output of the analyzer, 
and the microsentences that were produced are exhibited.
 The authors conclude that while microsentences 
of the quality achieved do not open up immediate prospects
for improving the performance of automatic 
message retrieval systems, they may have practical
value in man-machine systems using human monitors 
to select the preferred syntactic interpretation of a sentence.
.I 1416
.T
A Fortran Technique for Simplifying Input to Report Generators
.W
Typical report generators allow the production
of standard forms when tabulating a magnetic 
tape file; the extraction of nonstandard sets of information,
with suitable annotation, involves troublesome 
forms design.  A method of information extraction involving
the calculation of suitable FORTRAN FORMAT 
statements, which combats this problem, is described.
.I 1417
.T
Economies of Scale and the IBM System/360
.W
Cost functions among five System/360 models
are analyzed through examinations of instruction 
times, program kernels and a "typical" instruction mix.
 Comparisons are made between the data developed 
here and Grosch's Law which seems to be applicable to
much of the data.  Sizable economies of scale are 
unquestionably present in computing equipment. 
.I 1418
.T
Examination Scheduling (Algorithm 286 [ZH])
.I 1419
.T
Chebyshev Quadrature (Algorithm 279 [D1])
.I 1420
.T
A New Uniform Pseudorandom Number Generator
.W
A new multiplicative congruential pseudorandom
number generator is discussed, in which the 
modulus is the largest prime within accumulator capacity
and the multiplier is a primitive root of that 
prime.  This generator passes the usual statistical
tests and in addition the least significant bits 
appear to be as random as the most significant bits-a
property which generators having modulus 2^k do 
not possess.
.I 1421
.T
A Contribution to the Development of ALGOL
.W
A programming language similar in many respects
to ALGOL 60, but incorporating a large number 
of improvements based on six years experience with that
language, is described in detail.  Part I consists 
of an introduction to the new language and a summary
of the changes made to ALGOL 60, together with a 
discussion of the motives behind there visions.  Part II
is a rigorous definition of the proposed language. 
 Part III describes a set of proposed standard procedures
to be used with the language, including facilities 
for input/output.
.I 1422
.T
Eleven-Sixteenths Inch Perforated
Paper Tape (Proposed American Standard)
.I 1423
.T
A Simple Algorithm for Computing the Generalized Inverse of a Matrix
.W
The generalized inverse of a matrix is important
in analysis because it provides an extension 
of the concept of an inverse which applies to all matrices.
 It also has many applications in numerical 
analysis, but it is not widely used because the existing
algorithms are fairly complicated and require 
considerable storage space.  A simple extension has
been found to the conventional orthogonalization 
method for inverting non-singular matrices, which gives
the generalized inverse with little extra effort 
and with no additional storage requirements.  The algorithm
gives the generalized inverse for any m by 
n matrix A, including the special case when m+n and A
is non-singular and the case when m>n and rank(A) 
= n.  In the first case the algorithm gives the ordinary
inverse of A.  In the second case the algorithm 
yields the ordinary least squares transformation matrix
INV(A'A)A' and has the advantage of avoiding 
the loss of significance which results in forming the product A'A explicitly.
.I 1424
.T
Automatic Analysis of Electronic Digital Circuits Using List Processing
.W
A mapping from black diagrams of digital circuits
to list structures is described, together 
with a list processing program written for the Control
Data 3600 which uses this mapping to automatically 
carry out circuit analysis.
.I 1425
.T
Flow Diagrams, Turing Machines And
Languages With Only Two Formation Rules
.W
In the first part of the paper, flow diagrams
are introduced to represent inter al. mappings 
of a set into itself.  Although not every diagram is
decomposable into a finite number of given base 
diagrams, this becomes true at a semantical level due
to a suitable extension of the given set and of 
the basic mappings defined in it.  Two normalization
methods of flow diagrams are given.  The first has 
three base diagrams; the second, only two.  In the second
part of the paper, the second method is applied 
to the theory of Turing machines.  With every Turing
machine provided with a two-way half-tape, there 
is associated a similar machine, doing essentially
the same job, but working on a tape obtained from 
the first one by interspersing alternate blank squares.
 The new machine belongs to the family, elsewhere 
introduced, generated by composition and iteration from
the two machines L and R.  That family is a proper 
subfamily of the whole family of Turing machines.
.I 1426
.T
A Simulation of Hospital Admission Policy
.W
A study is described which simulates different
admission policies of a large specialized hospital. 
 The objective is to determine better policies for
stabilization of admission and census rates while 
maintaining a reasonably full hospital.  There types of
policies were examined: admission based on percentages 
of discharge rates, discharge rates plus or minus a
constant, and fixed authorizations independent of 
discharge rates.  The last type policy produced more stable
simulated results, and when put into practice, 
improvements were realized.
.I 1427
.T
Simulation of Radioisotope Scans by Computer
.W
In radioisotope scanning, a field which is assuming
increasing importance in medical diagnosis, 
the scan is a two-dimensional pattern made up of dots.
 Areas of increased source activity are represented 
on the scan by areas of increased dot density.  To study
the output of scanners with various characteristics, 
a program which simulates radioisotope scans has been
written  for a PDP-1 computer with auxiliary disk 
storage and cathode ray tube display.  Past and present
research using the output of the simulator has 
shown the flexibility of the system to be important.
 The structure of this program can be useful in 
the simulation of the output of any quantum-limited system.
.I 1428
.T
SHOCK III, A Computer System As an Aid
in the Management of Critically III Patients
.W
SHOCK III, an online digital computer system
to assist the physician, nurse and paramedical 
personnel in monitoring and reporting on critically ill patients, is described.
.I 1429
.T
Matrix Reduction Using the Hungarian Method
For The Generation of School Timetables
.W
The application of Kuhn's Hungarian Method
to the problem of matrix reduction as needed in 
Gotlieb's method for timetable generation is described.
 The method is suited to both hand and computer 
calculation.  Devices to improve the efficiency
of the basic algorithm are discussed.
.I 1430
.T
Multiple Precision Floating-Point Conversion
from Decimal-to-Binary and Vice Versa
.W
Decimal-to-binary and binary-to-decimal floating-point
conversion is often performed by using 
a table of the powers 10^i, (ia positive integer) for
converting from base 10 to base 2, and by using 
a table of the coefficient of a polynomial approximation
of 10^x, (0<=x<1) for converting from base 2 
to base 10.  These tables occupy a large storage region
in the case of a nonsingle precision conversion. 
 This paper shows that a single small table suffices
for a floating-point conversion from decimal to 
binary, and vice versa, in any useful precision.
.I 1431
.T
On a Storage Mapping Function For Data Structures
.W
Some basic facts about certain data structures
are reviewed and an efficient algorithm is presented 
for constructing a storage mapping function for
a structure from the structure's definition.
.I 1432
.T
Incorporation of Nonstandard Input/Output Devices into FORTRAN Systems
.W
A FORTRAN system may readily be modified to
handle input/output with nonstandard media on the 
same basis on which it handles the standard media.  This
is done by providing a character-handling subroutine 
suited to the nonstandard medium and arranged to be called
by an otherwise unused output statement type 
or unit number. This method was used to control output
of alphanumeric information on a digital graph 
plotter.
.I 1433
.T
A Note on Linear Programming Algorithm Design: A Combinatorial Problem
.W
As linear programming models grow bigger and
bigger in size, much actual data that must be 
memorized is often put on magnetic tape or disk, and
consequently there is an improportionality fast 
rise in the consumption of computer time.To cut down
this expense, an ever increasing effort is made 
to design more efficient algorithms.  This paper is
meant to support the effort.  It is attempted to 
find some characteristics of the way a pivot column
is found.  The number of repetitions of a certain 
transfer of data from tape to core memory is considered.
 After some simplification, the problem is restated 
in a general way.  The generating function of the probability
distribution and the moment generating 
function of the number of repetitions is found.  Asymptotic
formulas are given for the moments using 
a result from a paper of S. Narumi [1].  The results
may be applied to write very efficient routines 
that search for an extreme value in a table.  Formulas
provide a means of calculating the computer timings 
in this case.
.I 1434
.T
A Monte Carlo Algorithm for Assigning Students to Classes
.W
A technique of random choice is illustrated
by application to the problem of assigning students 
to a fixed schedule of courses.  Using the technique
it is possible to reduce or eliminate difficulties 
that result when a popular section is filled and closed
before all students requesting and requiring 
it have been scheduled.  The effectiveness of automatic
scheduling is retained without loss of the students 
privilege of picking favorite instructors.
.I 1435
.T
Design of Computer Simulation Experiments for Industrial Systems
.W
The aim of this paper is to provide background
information on the existing literature on experimental 
design techniques which may be applicable to the design
of computer simulation experiments for industrial 
systems.  Although major emphasis is placed on analysis
of variance techniques, three other techniques 
of data analysis are considered-multiple ranking procedures,
sequential sampling and spectral analysis. 
 The paper treats four specific experimental design
problems and several techniques for solving them. 
 The four experimental design problems are: (1) the
problem of stochastic convergence, (2) the problem 
of factor selection, (3) the problem of motive
and (4) the many response problem.
.I 1436
.T
Interchange of Two Blocks of Data (Algorithm 284 [K2])
.I 1437
.T
The Mutual Primal-Dual Method (Algorithm 285 [H])
.I 1438
.T
A Method for Locating Zeros of Complex Functions
.W
A method for computing the index, or winding
number, is developed and applied to the problem 
of finding zeros of functions from the plane into the plane.
.I 1439
.T
Mechanization of the Curve Fitting Process: DATAN
.W
A process for fitting a curve to approximate data
and the problem it creates for the engineer-programmer 
is defined.  An approach has also been defined and a system
has been written for the SRU 1107 to mechanize 
a major portion of this process.  The techniques developed
to accomplish the mechanization are largely 
empirical, and are dependent for their information
only on the actual data points.
.I 1440
.T
Starting Approximations for Square Root Calculation on IBM System/360
.W
Several starting approximations for square
root calculation by Newton's method are presented 
in a form to facilitate their use in IBM System/360 square
root routines.  These approximations include 
several for the range [1/16, 1], which is the interval
of primary interest on IBM System/360.
.I 1441
.T
Methods of Numerical Integration Applied to
a System Having Trivial Function Evaluations
.W
A study has been made to determine which methods
of numerical integration require the least 
computation time for a given amount of truncation error
when applied to a particular system of ordinary 
differential equations where function evaluations are
relatively trivial.  Recent methods due to Butcher 
and Gear are compared with classic Runge-Kutta, Kutta-Nystrom
and Adams methods.  Some of the newer one-step 
methods due to Butcher are found to be slightly superior,
but no one method is found to have any great 
advantage over the others in the application to this particular problem.
.I 1442
.T
Recorded Magnetic Tape For Information Interchange
(800 CPI, NRZI)* (Proposed American Standard)
.I 1443
.T
A Method for Finding the Least Squares Estimate
of the Intersection Point of Two Helices in Space
.W
When the helical trajectories of two charged
particles moving away from a common point in a 
magnetic field are reconstructed from measurements on
the tracks, the reconstructed tracks are perturbed 
by measurement and other errors and do not, in general,
intersect.  A method is given for adjusting the 
reconstructed tracks in a least squares manner so that they do intersect.
.I 1444
.T
An Algorithm for Generating Projective Reduction
Formulas for Matrix Elements of Many-Electron 
Wavefunctions
.W
An ALGOL procedure is given for automatically
generating formulas for matrix elements arising 
in the variational solution of the Schrodinger
equation for many-electron systems.
.I 1445
.T
Use of the Computer to Teach Introductory Statistics
.W
It has always been obvious that the aid to calculation
offered by the computer forces a change 
in the curricula of mathematics, statistics, physics,
engineering and other courses.  Not so obvious 
are the many pedagogic aids the computer can offer in
teaching the subject matter.  The possibilities 
of giving the student a better technical as well as conceptual
understanding of statistics were explored 
for a number of years at the College of Medicine of
the University of Cincinnati and are reported here.
.I 1446
.T
Chebyshev Quadrature (Algorithm 279 [D1])
.I 1447
.T
Abscissas and Weights for Gregory Quadrature [D1])
.I 1448
.T
Abscissas and Weights for Romberg Quadrature (Algorithm 281 [D1])
.I 1449
.T
Derivatives (Algorithm 282 [S22])
.I 1450
.T
Simultaneous Displacement of Polynomial
Roots if Real and Simple (Algorithm 283 [C2])
.I 1451
.T
Runge-Kutta Integration (Algorithm 9 [D2])
.I 1452
.T
Kutta-Merson (Algorithm 218 [D2]
.I 1453
.T
A Nonrecursive Method of Syntax Specification
.W
The use of the Kleene regular expression notation
for describing algebraic language syntax, 
in particular of ALGOL, is described in this paper. 
A FORTRAN II computer program for carrying out the 
elimination algorithm of Gorn,similar to Gaussian elimination
for linear systems of algebraic equations, 
is described.  This was applied to numerous smaller
languages, including some sublanguage of ALGOL.  
A hand calculation result of the application of the algorithm
to all of ALGOL is given, thus expressing 
the Revised ALGOL 1960 syntax in completely nonrecursive
terms, as far as its context-free portion is 
concerned.  This description in many ways is far more
intuitively understood than the previous recursive 
description, it is suggested.  The paper also includes
results of the machine program, which does not 
include a simplification algorithm.
.I 1454
.T
A Simple User-Oriented Compiler Source Language
for Programming Automatic Test Equipment
.W
For the nonprogrammer, difficulty in using
a language increases rapidly with the number of 
nonproblem-oriented conventions.  A simple language, even
if inelegant, which considers the user's background 
as part of the problem may be more effective than a source
language containing subtle and more powerful 
capabilities.  The language described in this paper is
used to write computer programs which test electronic 
equipment.  Because this testing process contains few
complex ideas, there is little need for the elegance 
and redundancy of a highly syntax-oriented language.
 A simple and direct language will suffice for the 
problem.  The eventual users of this language are military
depot personnel who cannot he expected to 
have computer programming skill or significant programming
training.  For this nonprogramming-oriented 
user, it was essential to create a language using familiar
engineering statements; programming-oriented 
conventions would have unnecessarily complicated his task.
.I 1455
.T
TRAC, A Procedure-Describing Language for the Reactive Typewriter
.W
A description of the TRAC (Text Reckoning
And Compiling) language and processing algorithm 
is given.  The TRAC language was developed as the basis
of a software package for the reactive typewriter. 
 In the TRAC language, one can write procedures for
accepting, naming and storing any character string 
from the typewriter; for modifying any string in any way;
for treating any string at any time as an executable 
procedure, or as a name, or as text; and for printing
out any string.  The TRAC language is based upon 
an extension and generalization to character strings
of the programming concept of the "macro."  Through 
the ability of TRAC to accept and store definitions of
procedures, the capabilities of the language can 
be indefinitely extended, and can deal with character
strings, integers and Boolean vector variables.
.I 1456
.T
Storage and Retrieval of Aspects of Meaning in Directed Graph Structures
.W
An experimental system that uses LISP to make
a conceptual dictionary is described.  The dictionary 
associates with each English word the syntactic information,
definitional material, and references to 
the contexts in which it has been used to define other words.
 Such relations as class inclusion, possession, 
and active or passive actions are used as definitional
material.  The resulting structure serves as a 
powerful vehicle for research on the logic of question answering.
 Examples of methods of inputting information 
and answering simple English questions are given.  An
important conclusion is that, although LISP and 
other list processing languages are ideally suited for
producing complex associative structures, they 
are inadequate vehicles for language processing on any
large scale-at east until they can use auxiliary 
memory as a continuous extension of core memory.
.I 1457
.T
Data Manipulation and Programming Problems
in Automatic Information Retrieval
.W
Automatic information retrieval programs require
the manipulation of a variety of different 
data structures, including linear text, sparse matrices,
and tree or list structures.  The main data 
manipulations to be performed in automatic information
systems are first briefly reviewed.  A variety 
of data representations which have been used to describe
structured information are then examined, and 
the characteristics of various processing languages are
outlined in the light of the procedures requiring 
implementation.  Advantages of these programming languages
for the retrieval application are examined, 
and suggestions are made for the design of programming
facilities to aid in information retrieval.
.I 1458
.T
Online Programming
.W
When the transition has been made from off line
to online programming, there are a number of 
changes in the working conditions noted.  These changes
in the environment make necessary corresponding 
changes in the processes related to producing and checking
out programs.  In the main, it it not the 
programming language itself which must be changed to
provide a facility for the online user; it is the 
system surrounding the programming language.  In this
paper the online environment and its effect on 
programming are discussed.
.I 1459
.T
Requirements for Real-Time Languages
.W
Real-time languages have different requirements
from other programming languages because of 
the special nature of their applications, the environment
in which their object programs are executed 
and the environment in which they may be compiled.  It
may not be the language extensions that ultimately 
advance developments in the field.  Progress may be made
by attacking the special compiling and executing 
system problems that must be solved.
.I 1460
.T
Evolution of the Meta-Assembly Program
.W
A generalized assembler called a "meta-assembler"
is described.  The meta-assembler is defined 
and factors which contributed to its evolution are presented.
 How a meta-assembler is made to function 
as an assembly program is described. Finally, the implication
of meta-assemblers on compiler design is 
discussed.
.I 1461
.T
Discussion Summary on Operating Systems
.I 1462
.T
Multilevel Operating Systems
.W
The Basic software for all newer computers
is built on the well-established need for standard 
operating systems. This implies that all applications-no
matter how large, complex or time consuming-must 
operate under (or, more precisely, on top of) the standard
system.  Large applications require supervisory 
monitors which handle problems similar to those of
the operating systems, but at a different level.  
Sometimes, still a third or even a fourth such level
is required or desirable.  This leads naturally 
to the concept of multilevel systems-similar vertically,
but different horizontally.  Proper division 
of responsibility between levels leads to greater efficiency and
less logical complexity, while actually 
enhancing capability.
.I 1463
.T
More on Extensible Machines
.W
One of the most salient characteristics of extensible
machines (EM) is the facility for providing 
system control over program-to-program and program-to-data
linkage (e.g., address connection).  It is 
the intent of this paper to expand and clarify the remarks
concerning program-to-program and program-to-data 
linkage that were embodied in the authors' previous
paper on the EM concepts, and to, finally, trace 
the employment of linkage mechanisms through
various levels of programming languages.
.I 1464
.T
An ALGOL Compiler: Construction and Use
in Relation to an Elaborate Operating System
.W
An ALGOL translator has been prepared and integrated
into the IBSYS Operating System.  Assembly 
and "go" features of IBSYS permit immediate execution with
optional listings, decks and debugging information. 
 Using the chain feature of IBSYS, links written in
MAP or FORTRAN as well as ALGOL may be called by 
the ALGOL main program.  In addition, procedures coded
in MAP may be included in any ALGOL program.  
Although assembly plus loading time exceeds compilation
time, the total time is satisfactory and the 
user gets ease and facility which are fully compensating.
.I 1465
.T
Program Translation Viewed as a General Data Processing Problem
.W
Efficiency dictates that the overall effectiveness
of a compiler be increased by all means 
available.  For a compiler to have a substantial useful
life it needs a clear logical structure, reliability 
and sound data processing techniques.  A compiler must
be based on fixed conventions to preserve efficiency 
and reliability; empty options and default conventions
violate this dictum.  Use of structure to associate 
various parts of a program and economy of
features promote clarity and reliability.
.I 1466
.T
Discussion Summary on Graphical Languages
.I 1467
.T
A Graphical ServiceSystem With Variable Syntax
.W
Man-machine interaction in many fields of endeavor
should be greatly facilitated in the near 
future through the use of interactive graphical languages.
 To provide a variety of display scope communication 
procedures, a Graphic Service system which functions
as a generalized graphical language translator, 
is being developed to aid the definition as
well as the use of new graphical languages.
.I 1468
.T
Syntax-Directed Interpretation of Classes of Pictures
.W
A descriptive scheme for classes of pictures based
on labeling techniques using parallel processing 
algorithms was proposed by the author some years ago.
 Since then much work has been done in applying 
this to bubble chamber pictures.  The parallel processing
simulator, originally written for an IBM 7094
system, has now been rewritten for a CDC 3600 system.
 This paper descriptive models by considering their 
specific application to bubble chamber pictures.  How
the description generated in this phase can be 
embedded in a larger "conversation" program is explained
by means of a certain specific example that 
has been worked out.  A partial generative grammar for
"handwritten" English letters is given, as are 
also a few computer-generated outputs using this grammar
and the parallel processing simulator mentioned 
earlier.
.I 1469
.T
The Next 700 Programming Languages 
.W
A family of unimplemented computing languages
is described that is intended to span differences 
of application area by a unified framework.  This framework
dictates the rules about the uses of user-coined 
names, and the conventions about characterizing functional
relationships.  Within this framework the 
design of a specific language splits into two independent
parts.  One is the choice of written appearances 
of programs (or more generally, their physical representation).
 The other is the choice of the abstract 
entities (such as numbers, character-strings, lists
of them, functional relations among them) that can 
be referred to in the language.  The system is biased
towards "expressions" rather than "statements." 
 It includes a nonprocedural(purely functional) subsystem
that aims to expand the class of users' needs 
that can be met by a single print-instruction, without sacrificing
the important properties that make 
conventional right-hand-side expressions easy to construct and understand.
.I 1470
.T
The Structure of Programming Languages
.W
The following are identified as major components
of every programming language: (1) the elementary 
program statement, (2) mechanisms for linking elementary
statements together, (3) the means by which 
a program can obtain data inputs.  Several alternative
forms of each of these components are described, 
compared and evaluated.  Many examples, frequently from
list processing languages, illustrate the forms 
described.  Elementary program statements usually take
the form of commands, requirements, or implicit 
specifications.  A command is an imperative statement
that commands the action to be taken.  A requirement 
describes the effect to be achieved without saying anything
about the actions to be taken.  An implicit 
specification is similar to a requirement, but the programmer
must understand what actions will be taken 
to achieve the desired effect.  Subroutines may be entered
explicitly, by execute call, or by function 
composition.  Explicitly called subroutines generally
require special linkage conventions.  An execute 
subroutine call is syntactically indistinguishable from
a basic instruction of the programming language. 
 Function composition is a convenient alternative to
the explicit call.  The three principal ways of 
getting inputs for routines are (1) by referring to
the data itself, (2) by referring to the data by 
a "name", and (3) by referring to it implicitly by means
of variables or functions.  Names are useful 
entry points into permanent data structures, but can
be error-causing distractions in other contexts. 
The author discusses advantages, disadvantages, and factors
influencing the choice of a form of component 
for a language.   He concludes by suggesting the evolution
of programming languages toward one which 
will permit all the most convenient ways of structuring
programs, organizing systems, and referencing 
data.
.I 1471
.T
Programming Semantics for Multiprogrammed computations
.W
The semantics are defined for a number of meta-instructions
which perform operation essential 
to the writing of programs in multiprogrammed computer
systems.  These meta-instructions relate to parallel 
processing, protection of separate computations, program
debugging, and the sharing among users of memory 
segments and other computing objects, the names of which
are hierarchically structured.  The language 
sophistication contemplated is midway between an assembly
language and an advanced algebraic language.
.I 1472
.T
Description of a High Capacity, Fast
Turnaround University Computing Center
.W
The operating system for the UNIVAC 1107 at Case
Institute is reviewed.  The system is of interest 
because of the low turnaround times achieved, the high
throughput achieved and the lack of an operating 
staff.  Turnaround times below 5 minutes and job volume
above 75,000 per quarter year one reported.
.I 1473
.T
The Stability of the Fourth Order Runge-Kutta
Method for the Solution of Systems of Differential 
Equations
.W
The problem of the region of stability of the
fourth order-Runge-Kutta method for the solution 
of systems of differential equations is studied.  This
region can be characterized by means of linear 
transformation but can not be given in a closed form.
 In the paper, this region is determined by the 
electronic digital computer Z22.
.I 1474
.T
Tests of Probabilistic Models for Propagation of Roundoff Errors
.W
In any prolonged computation it is generally
assumed that the accumulated effect of roundoff 
errors is in some sense statistical.  The purpose of this
paper is to give precise descriptions of certain 
probabilistic models for roundoff error, and then to
describe a series of experiments for testing the 
validity of these models.  It is concluded that the models
are in general very good.  Discrepancies are 
both rare and mild.  The test techniques can also be
used to experiment with various types of special 
arithmetic.
.I 1475
.T
Dribble Posting a Master File
.W
Many business applications employ sequential
magnetic tape rather than random-access storage 
techniques to process a very small number of transactions
against a voluminous master file.  In such 
situations, it may prove economical to avoid creating a
new master file during each updating run by producing 
instead a dribble ledger containing only those master
file accounts which have experienced activity.
.I 1476
.T
Control Procedures for Data Communication-An ASA Progress Report
.W
Sectional Committee X.3 of the American Standards
Association, has charged one of its task 
groups, X3.3.4, with the responsibility to "Define and specify
functional control requirements and characteristics 
governing the operation of digital data generating and
receiving systems interconnected by communication 
system."  This effort is primarily directed toward systems
employing the American Standard Code for Information 
Interchange (ASCII).  This paper represents a progress
report on the work of this group toward a proposal 
for national and international standardization in the
field of control procedures.  It describes both 
the old and new work of the task group.  The new work
is presented in detail, while the work that has 
been presented in earlier papers ["Control Procedures for
Data Communication," Task Group document X3.3.4/44, 
May 1964: "Transparent-Mode Control Procedures for Data
Communication," Task Group document X3.3.4/58, 
December, 1964: Comm. ACM 8 (Apr. 1965), 203-206; "Control
Procedures for Data Communications," Task 
Group document X3.3.4/60, March, 1965] is retained here
in summary form.  Many of the concepts and principles 
described herein have been submitted to the International
Organization for Standardization via earlier 
papers and are now embodied in working papers of that organization. 
.I 1477
.T
EULER: A Generalization of ALGOL, and its Formal Definition: Part II*
.I 1478
.T
Exponential Curve Fit (Algorithm 275 [E2])
.I 1479
.T
Constrained Exponential Curve Fit (Algorithm 276 [E2])
.I 1480
.T
Computation of Chebyshev Series Coefficients (Algorithm 277[C6])
.I 1481
.T
Graph Plotter (Algorithm 278 [J6])
.I 1482
.T
BUGSYS: A Programming System for Picture Processing-Not for Debugging
.W
BUGSYS is a picture processing and measuring
system that depends upon a pictorial input to 
the computer's memory.  BUGSYS can be used for many
types of applications.  In particular, the authors 
have used the system for the analysis of linear graphs.
 The main concept of the system is the use of 
a collection of programmable pointers, which
are visualized as a family of "bugs."
.I 1483
.T
A Comparison of the FORTRAN Language
Implementation for Several Computers
.W
A feature-by-feature comparison is made of five
different implementations of FORTRAN IV representing 
three different manufacturers.  A table is constructed
showing, where possible, the use of each feature 
in each implementation.  Only those items which are
different from, or have been added to FORTRAN II 
are shown.
.I 1484
.T
A Language for Describing the Functions of Synchronous Systems* 
.W
Before the design of a system is started, the
exact function desired of it should be specified. 
 It is suggested that a computer-oriented language be
used for this purpose.  The inadequacies of the 
standard programming languages for the description of
systems are discussed, and a dialect of ALGOL which 
is suitable for describing synchronous systems is introduced.
 These descriptions can be used for simulation 
and automatic design of the system described, in
addition to communicating system specifications.
.I 1485
.T
The Structure of Programming Languages
.W
In this paper the major components of every
programming language are identified as: (1) the 
elementary program statement, (2) mechanisms for linking
elementary statements together, (3) the means 
by which a program can obtain data inputs.  Several
alternative forms of each of these components are 
also described, compared and evaluated.  Many examples,
frequently from list processing languages, illustrate 
the forms described.  The advantages, disadvantages and
factors influencing the choice of a form of component 
for a language are discussed, and the paper concludes
with the suggestion that programming languages 
evolve toward one which will permit all the most convenient
ways of structuring programs, organizing 
systems and referencing data.
.I 1486
.T
A Reprogramming Machine
.W
In this paper a description is given of a model
programming system which is directed by a programming 
language and has a library for storing the user's items.
 Rules are given for transforming programs written 
in the language and for rearranging the items in the
library so that they share their common parts.  
Some speculations are made about how the mechanical
detection of common parts or patterns of library 
items could help a user to solve his problems, and about
the relationships between the behavior of the 
reprogramming machine and human intelligent behavior.
.I 1487
.T
ELIZA-A Computer Program For the Study ofNatural
Language Communication Between Man And Machine
.W
ELIZA is a program operating within the MAC
time-sharing system at MIT which makes certain 
kinds of natural language conversation between man and
computer possible.  Input sentences are analyzed 
on the basis of decomposition rules which are triggered
by key words appearing in the input text.  Responses 
are generated by reassembly rules associated with selected
decomposition rules.  the fundamental technical 
problems with which ELIZA is concerned are: (1)the
identification of key words, (2) the discovery of 
minimal context, (3) the choice of appropriate transformations,
(4) generation of responses in the absence 
of key words, and (5) the provision of an editing capability
for ELIZA "scripts".  A discussion of some 
psychological issues relevant to the ELIZA approach as
well as of future developments concludes the paper.
.I 1488
.T
Programming Decision Tables in FORTRAN, COBOL or ALGOL
.W
A simple broad-based approach for programming
decision tables in FORTRAN or COBOL is developed 
and presented.  With inputs in standard form, as defined
in the paper, the programming of any decision 
table can be done with one or two FORTRAN statements,
or with two COBOL statements, if the COMPUTE verb 
is available in the COBOL processor.  It is  shown
that the method is applicable even when there are 
more than two mutually exclusive states of one, two or
more table conditions.  It is further shown that 
multi-state conditions in decision tables can often
simplify the programming.  The method outlined has 
the further advantage that all possible combinations
of conditions are considered.  It is shown that 
the suggested procedure is easily implemented in ALGOL.
.I 1489
.T
Data, Documentation and Decision Tables
.W
In business data processing systems, it is
necessary to be able to define and document data, 
files, programs and decision rules in a way that adequately
represents both (1) their changing information 
content, and (2) their continuous interaction.  Tabular
description makes this possible, being notably 
objective, through and economical in cost and time when
systems must be analyzed and programs prepared 
or modified.  To show how quickly tabular techniques
make an unfamiliar system manageable, a detailed 
example and a self-test are provided.
.I 1490
.T
One Inch Perforated Paper Tape for Information
Interchange (Proposed American Standard)
.I 1491
.T
EULER: A Generalization ALGOL, and its Formal Definition: Part I*
.W
A method for defining programming languages is
developed which introduces a rigorous relationship 
between structure and meaning.  The structure of a
language is defined by a phrase structure syntax, 
the meaning in terms of the effects which the execution
of a sequence of interpretation rules exerts 
upon a fixed set of variables, called the Environment.
 There exists a one-to-one correspondence between 
syntactic rules and interpretation rules is determined by
the sequence of corresponding syntactic reductions 
which constitute a parse.  The individual interpretation
rules are explained in terms of an elementary 
an d obvious algorithmic notation.  A constructive
method for evaluating a text is provided, and for 
certain decidable classes of languages their unambiguity
is proved.  As an example, a generalization 
of ALGOL is described in full detail to demonstrate that
concepts like block-structure, procedures, parameters, 
etc. can be defined adequately and precisely by this method.
.I 1492
.T
Serrev (Algorithm 273 [C1])
.I 1493
.T
Generation of Hilbert Derived Test Matrix (Algorithm 274 [F1])
.I 1494
.T
Complete Elliptic Integral of the Second Kind (Algorithm 56 [S21])
.I 1495
.T
Solution of Transcendental Equations by Series Reversion
.W
An algorithm is developed for expressing the
solution Y, of the equation F(Y) = G(X) as a power 
series in (X - X0) when f and g are given as power series,and
the root Y0, is known at Y=X0.  The algorithm 
is illustrated for the equation Y^Y = X, i.e., (1+y)*ln(1+y) = ln(1+x).
.I 1496
.T
A Formal Semantics for Computer Languages
and its Application In a Compiler-Compiler
.W
A semantic meta-language has been developed
for representing the meanings of statements in 
a large class of computer languages.  This meta-language
has been the basis for construction of an efficient, 
functioning compiler-compiler.  An informal discussion
of the meta-language based on the example of a 
complete translator for a small language is presented.
.I 1497
.T
On the Normalization Requirement of
Divisor in Divide- and- Correct Methods
.W
This paper presents an analysis on the normalization
requirement of the divisor in a divide-and-correct 
method.  This analysis is made subject to the condition
that not more than one correction is required 
to obtain the true quotient character, from the trial
estimate got from the division of a two-precision 
segment of every partial remainder by a suitably rounded
single-precision divisor.  (This segmented division 
is denoted here as a (2, 1) precision basic division.)
 It is found that the normalization requirement 
could be narrowed down to a smaller range of divisors,
provided the magnitude of the character next to 
the leading character of the divisor is known.  If,
however, the normalization is to be eliminated one 
has to choose proper higher precision segments of operands
for the basic division.  Also considered is 
the possibility of eliminating the normalization by an
increase on the number of corrections on the quotient 
estimate got from a (2, 1) precision basic division.
 It is shown that such a scheme is economical only 
for small radices.
.I 1498
.T
The ALCOR Illinois 7090/7094 Post Mortem Dump
.W
A dump technique for programs written in ALGOL
60 is described.  This technique provides an 
intelligible analysis of an unsuccessful computation
process in terms of the original source program.
.I 1499
.T
Chebyschev Curve-Fit (revised) (Algorithm 318 [E2])
.I 1500
.T
Chebyschev Curve-Fit (Algorithm 91 [E2])
.I 1501
.T
Eigenvectors of a 2n x 2n Matrix
.W
It has been known that the eigenvalues of a
certain 2n x 2n matrix can be obtained by use of 
two smaller matrices of order n which can be easily
constructed.  An algorithm is given to obtain the 
eigenvectors of the 2n x 2n matrix by use of
the eigenvectors of the smaller matrices.
.I 1502
.T
An Online Editor
.W
An online, interactive system for test editing
is described in detail, with remarks on the 
theoretical and experimental justification for its form.
 Emphasis throughout the system is on providing 
maximum convenience and power for the user.  Notable
features are its ability to handle any piece of 
text, the content-searching facility, and the character-by-character
editing operations.  The editor 
can be programmed to a limited extent.
.I 1503
.T
A SIMSCRIPT-FORTRAN Case Study
.W
Two programs for a vehicle dispatching model,
one written in 7040 SIMSCRIPT and the other in 
7040 FORTRAN IV are compared. The comparison is made
in terms of basic program design decisions, storage 
requirements, computer time used, and the ease of making
changes.  In the SIMSCRIPT program, the primary 
design considerations center around the choice of model
variables, model changing events, and model testing. 
 In the FORTRAN program, basic design problems relate
to the representation of the passage of time, the 
allocation of storage, and the organization of input
data.  The comparison of these differently designed 
programs shows that the SIMSCRIPT program uses more computer
storage and more computer time, but requires 
fewer program changes to introduce model revisions.
.I 1504
.T
Algorithms for Finding a Fundamental Set
of Cycles for an Undirected Linear Graph
.W
Given the adjacency matrix of the graph, the algorithm
presented in this paper finds a spanning 
tree and then constructs the set of fundamental cycles.
 Our algorithm is slower than an algorithm presented 
by Welch by a ratio of N/3 (N is the number of nodes)
but requires less storage.  For graphs with a large 
number of nodes and edges, when storage is limited our
algorithm is superior to Welch's; however, when 
the graphs are small, or machine storage is very large,
Welch's algorithm is superior.  Timing estimates 
and storage requirements for both methods are presented.
.I 1505
.T
A System Organization for Resource Allocation 
.W
This paper introduces a system for resource management
using the concepts of "process," facility," 
and "event."  Except for the processor no attempt has
been made to give serious suggestions for the policy 
to be followed for resource allocation.  However, a basic
framework is provided in which a system analyst 
can express solutions to resource management problems.
 The paper is divided into a tutorial presentation, 
a description of the system primitives, and a small collection
of examples of the use of the primitives.
.I 1506
.T
The LACONIQ Monitor: Time Sharing for Online Dialogues
.W
The LACONIQ (Laboratory Computer Online Inquiry)
Monitor was developed primarily to support 
non-numerical applications such as retrieval from very
large files by means of a "dialogue" between a 
system user and a retrieval application.  The monitor
was designed so that it could work with a small 
computer (an IBM System 360/30).  Therefore techniques
for resource allocation were important.  For this 
reason the use of core storage, computational facilities,
and input-output were all scheduled.  An unusual 
feature of the system is that it is event-driven rather
than clock-driven.  The program segments called 
into execution by the remote CRT consoles are invariably
run to completion rather than "rolled-out" to 
be brought back at a later time.
.I 1507
.T
A Multiprogramming Environment for Online Data Acquis ition and Analysis
.W
An experimental system for acquis ition and analysis
of large bodies of data derived from scientific 
experiments is described.  Its architecture and implementation
is largely based on certain objectives 
and characteristics of a general data analysis scheme.
 Early applications have been oriented towards 
the investigation of data obtained in biological research.
 Some of the problems encountered by the chosen 
approach are discussed.
.I 1508
.T
Magnetic Tape Labels for Information Interchange (Proposed USA Standard)
.I 1509
.T
Recorded Magnetic Tape for Information Interchange
(200 CPI, NRZI) (Proposed USA Standard)
.I 1510
.T
Finding a Solution of N Functional Equations
in N Unknown (Algorithm 314 [C5])
.I 1511
.T
The Damped Taylor's Series Method for Minimizing
a Sum of Squares and for Solving Systems of 
Nonlinear Equations
.I 1512
.T
Solution of Simultaneous Non-Linear Equations (Algorithm 316[C5])
.I 1513
.T
PERMUTATION (Algorithm 317 [G6])
.I 1514
.T
On the Expected Gain From Adjust ing Matched Term Retrieval Systems
.W
A file adjustment procedure based on maximizing
the Bayes expected gain proposed for matched 
term retrieval systems.  The expected gain and its probability
distribution are derived as a function 
of: (1) the prior proportion of omitted terms, and (2) the
coefficient of separation between two distributions 
corresponding to values of an adjustment statistic.  An
example evaluates the gain parameters for a typical 
information retrieval system.
.I 1515
.T
A Computer System for Inference Execution and Data Retrieval
.W
This paper presents a RAND project concerned
with the use of computers as assistants in the 
logical analysis of large collections of factual data.
 A system called Relational Data File was developed 
for this purpose.  The Relational Data File is briefly
detailed and problems arising from its implementation 
are discussed.
.I 1516
.T
Automatic Data Compression
.W
The "information explosion" noted in recent
years makes it essential that storage requirements 
for all information be kept to a minimum.  A fully automatic
and rapid three-part compressor which can 
be used with "any" body of information to greatly reduce
slow external storage requirements and to increase 
the rate of information transmission through a computer
is described in this paper.  The system will 
also automatically decode the compressed information
on an item-by-item basis when it is required.  The 
three component compressors, which can be used separately
to accomplish their specific tasks, are discussed: 
NUPAK for the automatic compression of numerical data, ANPAK
for the automatic compression of "any" information, 
and IOPAK for further compression of information to be stored on tape or cards.
.I 1517
.T
Methods for Analyzing Data from Computer Simulation Experiments
.W
This paper addresses itself to the problem of
analyzing data generated by computer simulations 
of economic systems.  We first turn to a hypothetical firm,
whose operation is represented by  single-channel, 
multistation queueing model.  The firm seeks to maximize
total expected profit for the coming period 
by selecting one of five operating plans, where each
plan incorporates a certain marketing strategy, 
an allocation of productive inputs, and a total cost.
 The results of the simulated activity under each 
plan are subjected to an F-test, two multiple comparison
methods, and a multiple ranking method.  We 
illustrate, compare, and evaluate these techniques.
 The paper adopts the position that the particular 
technique of analysis (possibly not any one of the above)
chosen by the experimenter should be an expression 
of his experimental objective: The F-test tests the homogeneity
of the plans; multiple comparison methods 
quantify their differences; and multiple ranking methods
directly identify the one best plan or best 
plans.
.I 1518
.T
An Experimental Model of System/360
.W
The problem of predicting the performance of
modern computer systems is formidable.  One general 
technique which can ease this problem is macroscopic simulation.
 This paper reports on the applicability 
of that technique to System/360.  The paper describes
an experimental model of System/360-its hardware, 
software, and its environment.  The measures of system performance
produced by the model consist of statistics 
relating to turnaround time, throughput, hardware utilization,
software utilization, and queueing processes. 
 The model is mechanized in SIMSCRIPT and consists of
some 1750 statements.  An auxiliary programs, the 
Job Generator, creates automatically the properties
of System/360 jobs that get simulated.
.I 1519
.T
GEORGE 3-A General Purpose Time Sharing and Operating System
.W
An Operating System is described which will
run on a wide variety of configurations of the 
I.C.T. 1900, and can handle a large number of online console
users while at the same time running several 
off line (background) jobs.  The system is not oriented
towards either mode and can be either a batch 
processing system (such as the ATLAS Supervisor, IBSYS,
or GECOS), or a multiaccess system (resembling, 
to the user, CTSS or MULTICS), or both simultaneously,
depending on the installation, which can adjust 
the Schedulers.  Both online users and off line jobs use
a common Command Language.  The system includes 
a Multilevel device-independent File Store.
.I 1520
.T
Absolute Value and Square Root of a Complex Number (Algorithm 312 [A2])
.I 1521
.T
Multi-Dimensional Partition Generator (Algorithm 313 [A1])
.I 1522
.T
Chebyschev Quadrature (Algorithm 279 [D1])
.I 1523
.T
SHARER, a Time Sharing System for the CDC 6600
.W
A time sharing system embedded within the
standard batch processing system for the CDC 6600 
is described.  The system is general purpose and file-based,
providing facilities for file input, manipulation, 
editing, compilation, and conversational execution.
 It uses a simple scheme for system extension for 
a machine with only one relocation and memory bound register.
 No attempt was made to use reentrant code, 
or to simulate segmentation or paging.  Implementation
time was approximately six man-years, with the 
majority of the code being written in FORTRAN.
.I 1524
.T
A Stopping Criterion for Polynomial Root Finding
.W
When searching for the root of a polynomial,
it is generally difficult to know just when to 
accept a number as an adequate approximation to the root.
 In this paper an algorithm is presented which 
allows one to terminate the iteration process on the
basis of calculated bounds for the roundoff error 
which occurs in evaluating the polynomial.  This stopping
criterion has been tested on numerous examples 
and has been found to serve as a satisfactory means
for accepting a complex number as a zero of a real 
polynomial.
.I 1525
.T
On Computing The Fast Fourier Transform
.W
Cooley and Tukey have proposed a fast algorithm
for computing complex Fourier transform and 
have shown major time savings in using it to compute
large transforms on a digital computer.  With n 
a power of two, computing time for this algorithm is
proportional to n log2 n, a major improvement over 
other methods with computing time proportional to n^2.
 In this paper, the fast Fourier transform algorithm 
is briefly reviewed and fast difference equation methods
for accurately computing the needed trigonometric 
function values are given.  The problem of computing
a large Fourier transform on a system with virtual 
memory is considered, and a solution is proposed.  This
method has been used to compute complex Fourier 
transforms of size n = 2^16 on a computer with 2^15
words of core storage; this exceeds by a factor of 
eight the maximum radix two transform size with fixed
allocation of this amount of core storage.  The 
method has also been used to compute large mixed radix
transforms.  A scaling plan for computing the 
fast Fourier transform with fixed-point arithmetic is also given.
.I 1526
.T
Multiprogramming under a Page on Demand Strategy
.W
A model of multiprogramming for a particular
computer system using a page on demand strategy 
is developed.  Analysis of this model is used to predict
performance (measured by the average usage of 
the CPU) when user programs are typical of those arising
from an interactive time sharing environment. 
 The effect of several hardware modifications is also
analyzed.  A parameter, readily calculated from 
the hardware characteristics and the program statistics,
is proposed for gauging the effect of multiprogramming.
.I 1527
.T
A Grammar Base Question Answering Procedure
.W
The subject of this paper is a procedure for
the automatic retrieval of certain segments of 
stored information, either explicitly or implicitly represented,
through questions posed in natural language 
sentences.  This procedure makes use of a sentence recognition
device for the class of grammars which 
will correctly decide between the grammatical and ungrammatical
sentences of a natural language.  It 
is possible to make use of a recognition device of this
sort for the following reason: Much data is fully 
expressible as a set of sentences in a natural language,
a set which can be exhaustively and exclusively 
generated by a grammar.  Based upon the rules of this grammar,
a sentence recognizer will evaluate sentences, 
questions in the normal situation.  Since the recognition
function succeeds just in case the posed question 
is drawn from the set of sentences expressing the data,
or, more correctly, is grammatical in terms of 
the grammar for this set of sentences, sentence recognition
itself is a procedure for retrieving information. 
 When the recognition function succeeds, its
value represents the requested information.
.I 1528
.T
Three Fonts of Computer Drawn Letters
.W
Detailed descriptions are given for three fonts
of letters.  Letter shapes are entirely described 
by numbers.  The basic vectors are in a general form
so the fonts may be easily drawn on a variety of 
computers and cathode-ray tubes.  The fonts include both
upper and lower case Roman letters, mathematical 
signs, and upper and lower case Greek letters.  Design
of the fonts is described.  However, the principal 
contribution of this paper concerns the fonts themselves.
.I 1529
.T
Decomposition Programming An Analysis of Matrix Substructure 
.W
A petroleum blending problem was analyzed in order
to compare the primal and primal-dual decomposition 
algorithms.  In the course of the analysis, a substructure
was discovered which has relevance to the 
relative performance of the two algorithms and to their
absolute performance as compared with a standard 
primal-Simplex solution without decomposition.
.I 1530
.T
The ML/I Macro Processor
.W
A general purpose macro processor called ML/I
is described.  ML/I has been implemented on the 
PDP-7 and I.C.T. Atlas 2 computers and is intended as a
tool to allow users to extend any existing programming 
language by incorporating new statements and other
syntactic forms of their own choosing and in their 
own notation.  This allows a complete user-oriented
language to be built up with relative ease.
.I 1531
.T
The Remaining Trouble Spots in ALGOL 60
.W
This paper lists the ambiguities remaining
in the language ALGOL 60, which have been noticed 
since the publication of the Revised ALGOL 60 Report in 1963.
.I 1532
.T
The Hardware-Software Complementarity
.I 1533
.T
A Marovian Model of the University of Michigan Executive System
.W
A mathematical model of a computer's executive
system is postulated and its parameters estimated 
with the aid of extensive data on the system's operation.
 Although simplifying assumptions are made, 
the results predicted by the model agree reasonable well
with actual results.  The model is used to study 
the effects of changes in the executive system and
in one of its compilers.  Further applications of 
the model are discussed.
.I 1534
.T
DAD, The C.S.I.R.O. Operating System
.W
The design and implementation of the C.S.I.R.O.
operating system, DAD, is described in detail. 
 This system is designed for the Control Data 3600 using
a large drum backing store and is intended to 
allow the integration of a remote console (display) subsystem
into a conventional job stack environment. 
 The use of the drums, the buffering of input and output
on slow peripherals, and the execution of normal 
job stack work are described.  The display subsystem
is described only as it integrates into the rest 
of the system.  The techniques found useful in the development
of DAD are given, and an assessment is 
made of the validity of various design decisions.  Performance
figures based on several months of operation 
are tabulated.
.I 1535
.T
A Comment on Index Register Allocation
.W
A technique is presented to reduce the enumeration
required by a known procedure for optimal 
index register allocation in straight-line programs.
 This technique is based on the construction of 
a link diagram, which shows at any step the future occurrences
of indexes which must be loaded into index 
registers.  This diagram determines in advance the required
register configuration at certain steps of 
the program, so that the program is subdivided into separate
portions to which the allocation procedure 
may be applied independently.
.I 1536
.T
Dynamic Computation of Derivatives
.W
It is shown how Wengert's procedure for computation
of derivatives can be implemented conveniently 
by use of compiler-generated complex addition, subtraction,
and linkage to complex arithmetic subroutines.
 Evaluation of a function and derivative proceed in
parallel, as in Wengert's procedure, but with the 
"imaginary" parts of variables declared complex bearing
the values of the derivatives of the real parts. 
 This technique provides a simple way to compute the
derivatives of a function, without the need for 
deriving and programming the evaluation of
explicit formulas for the derivatives.
.I 1537
.T
Prime Number Generator 1 (Algorithm 310 [A1])
.I 1538
.T
Prime Number Generator 2 (Algorithm 311 [A1])
.I 1539
.T
Prime Number Generator 1; Prime Number Generator
2 (Algorithm 35[A1]; Algorithm 310[A1]; Algorithm 
311[A1])
.I 1540
.T
An Algorithm for Class Scheduling With Section Preference
.W
An algorithm for assignment of students to classes
in a fixed time schedule that allows students 
to give a preference for sections within courses is given.
 If consistent with the objective of balanced 
sections, these preferences will be honored.  The algorithm
is more stochastic than Monte Carlo in nature. 
 Results are given that compare it to a nonpreference assignment algorithm.
.I 1541
.T
A Language for Modeling and Simulating Dynamic Systems
.W
The general objective of this language is
to facilitate both the modeling and experimental 
aspects of simulation studies.  The ability to represent
systems containing highly interactive processes 
is an essential feature.  The nature of the language,
and the role of the process concept, is presented 
by means of an extended example.
.I 1542
.T
A Microprogrammed Implementation of EULER on IBM System/360 Model 30
.W
An experimental processing system for the algorithmic
language EULER has been implemented in 
microprogramming on an IBM System/360 Model 30 using a
second Read-Only Storage unit.  The system consists 
of a microprogrammed compiler and a microprogrammed
String Language Interpreter, and of an I/O control 
program written in 360 machine language.  The system is described
and results are given in terms of microprogram 
and main storage space required and compiler and interpreter
performance obtained.  The role of microprogramming 
is stressed, which opens a new dimension in the processing
of interpretive code.  The structure and content 
of a higher level language can be matched by an appropriate
interpretive language which can be executed 
efficiently by microprograms on existing computer hardware.
.I 1543
.T
Computer Formulation of the Equations of Motion Using Tensor Notation
.W
A means is described for extending the area
of application of digital computers beyond the 
numerical data processing stage and reducing the need for
human participation in the formulation of certain 
types of computer problems.  By the use of tensor calculus
and a computer language designed to facilitate 
symbolic mathematical computation, a method has been
devised whereby a digital computer can be used to 
do non-numeric work, that is, symbolic algebraic manipulation
and differentiation. To illustrate the 
techniques involved, a digital computer has been used
to derive the equations of motion of a point mass 
in a general orthogonal curvilinear coordinate system.
 Since this operation involves a formulation in 
terms of first- and second-order differential coefficients,
it provides a good demonstration of a computer's 
capability to do non-numeric work and to assist in the
formulation process which normally precedes the 
numerical data processing stage.  Moreover, this particular
problem serves to illustrate the advantages 
of the mathematical techniques employed.  With the program
prepared for this purpose the computer will 
derive the equations of motion in any coordinate system
requested by the user.   Results are presented 
for the following coordinate systems: cylindrical
polar, spherical polar, and prolate spheroidal.
.I 1544
.T
Tele-CUPL: A Telephone Time Sharing System
.W
A general purpose, remote access, computing system
is described, that employs twelve-key keyboard 
telephones as terminals.  Audio output is provided directly
to the telephone terminals, but the system 
will normally be used in conjunction with remotely located
high speed printing devices.  The system is 
a compatible extension of an existing batch processing
system.  A significant element of the system is 
a scheme for transmitting alphanumeric information by single
strokes on a numeric keyboard.  The programmed 
scanner uses context to eliminate the ambiguity in transmission.
.I 1545
.T
Legal Safeguards to Insure Privacy in a Computer Society
.I 1546
.T
Toward Standards for Handwritten Zero and Oh
.I 1547
.T
Gamma Function with Arbitrary Precision (Algorithm 309 [S14])
.I 1548
.T
Parsing of Decision Tables
.W
Reduction in the size of decision tables can be
accomplished by several techniques.  The techniques 
considered in this paper are on the parsing of decision
tables with regard to horizontal and vertical 
data structures, job identity, hardware and job priorities,
and context relationships.  Such parsing 
rests upon some conventions for the linkage of decision tables.
.I 1549
.T
An Efficient Machine-Independent Procedure for
Garbage Collection in Various List Structures
.W
A method for returning registers to the free
list is an essential part of any list processing 
system.  In this paper, past solutions of the recovery
problem are reviewed and compared.  A new algorithm 
is presented which offers significant advantages of speed
and storage utilization.  The routine for implementing 
this algorithm can be written in the list language with
which it is to be used, thus insuring a degree 
of machine independence.  Finally, the application of the
algorithm to a number of different list structures 
appearing in the literature is indicated.
.I 1550
.T
A Comparison of Batch Processing and Instant Turnaround
.W
A study of the programming efforts of students
in an introductory programming course is presented 
and the effects of having instant turnaround (a few minutes)
as opposed to conventional batch processing 
with turnaround times of a few hours are examined.  Among
the items compared are the number of computer 
runs per trip to the computation center, program preparation
time, keypunching time, debugging time, 
number of runs, and elapsed time from the first run
to the last run on each problem.  Even though the 
results are influenced by the fact that "bonus points"
were given for completion of a programming problem
in less than a specified number of runs, there
is evidence to support "Instant" over "Batch".
.I 1551
.T
On Compiling Algorithms for Arithmetic Expressions
.W
This paper deals with algorithms concerning arithmetic
expressions used in a FORTRAN IV compiler 
for a HITAC-5020 computer having n accumulators.  The
algorithms generate an object code which minimizes 
the frequency of storing and recovering the partial results
of the arithmetic expressions in cases where 
there are several accumulators.
.I 1552
.T
The AED Free Storage Package
.W
The most fundamental underlying problem in sophisticated
software systems involving elaborate, 
changing data structure is dynamic storage allocation
for flexible problem modeling.  The Free Storage 
Package of the AED-1 Compiler Systems allows blocks
of available storage to be obtained and returned 
for reuse.  The total available space is partitioned
into a hierarchy of free storage zones, each of 
which has its own characteristics.  Blocks may be of
any size, and special provisions allow efficient 
handling of selected sizes, control of shattering and
garbage collection, and sharing of physical space 
between zones.  The routines of the package perform
high level functions automatically, but also allow 
access and control of fine internal details as well.
.I 1553
.T
Contextual Understanding by Computers
.W
A further development of a computer program
(ELIZA) capable of conversing in natural language 
is discussed.  The importance of context to both human
and machine understanding is stressed.  It is 
argued that the adequacy of the level of understanding
achieved in a particular conversation depends 
on the purpose of that conversation, and that absolute
understanding on the part of either humans or 
machines is impossible.
.I 1554
.T
A Computer Technique for Displaying n-Dimensional Hyperobjects
.W
A digital computer and automatic plotter have
been used to generate three-dimensional stereoscopic 
movies of the three-dimensional parallel and perspective
projections of four-dimensional hyperobjects 
rotating in four-dimensional space.  The observed projections
and their motions were a direct extension
of three-dimensional experience, but no profound "feeling"
or insight into the fourth spatial dimension 
was obtained.  The technique can be generalized to n-dimensions
and applied to any n-dimensional hyperobject 
or hypersurface.
.I 1555
.T
Symmetric Polynomials (Algorithm 305 [C1])
.I 1556
.T
Permutations with Repetitions (Algorithm 306 [G6])
.I 1557
.T
Symmetric Group Characters (Algorithm 307 [A1])
.I 1558
.T
Generation of Permutations in Pseudo-Lexicographic
Order (Algorithm  [G6])
.I 1559
.T
Permutation Generator; Permutation in Lexicographical
Order; Permute; Generation of Permutations 
in Lexicographical Order (Algorithm 87[G6]; Algorithm
102[G6]; Algorithm 130[G6]; Algorithm 202[G6])
.I 1560
.T
Transport; Transportation Problem (Algorithm 258[H]; Algorithm 293[H])
.I 1561
.T
The Mutual Primal-Dual Method (Algorithm 285 [H])
.I 1562
.T
Airy Function (Algorithm 301 [S20])
.I 1563
.T
A Method for Finding Hamilton Paths and Knight's Tours
.W
The use of Warnsdorff's rule for finding a
knight's tour is generalized and applied to the 
problem of finding a Hamilton path in a graph.  A graph-theoretic
justification for the method is given.
.I 1564
.T
Description of Basic Algorithm in DETAB/65 Preprocessor
.W
The basic algorithm for the conversion of decision
tables into COBOL code is contained in the
generator portion of the DETAB/65 preprocessor.  The
generator analyzes a decision table and produces 
simple COBOL conditional statements.  Core storage is
saved by using queueing techniques and extensive 
indexing and also by outputting the code as it is generated,
a line at a time.  The only optimization 
attempted is the elimination of obviously unnecessary
tests on certain conditions in the decision table. 
 Since the preprocessor and this language associated with
it were developed for COBOL users, the preprocessor 
was written in a modular form in required COBOL-61.
.I 1565
.T
A Language-Independent Macro Processor
.W
A macro processor is described which can be
used with almost any source language.  It provides 
all features normally associated with a macro facility,
plus the ability to make arbitrary transformations 
of the argument strings.  The program is used at the
Basser Computing Department, University of Sydney, 
Sydney, Australia, to process text for eight different compilers.
.I 1566
.T
Optimal Starting Values for Newton-Raphson Calculation of SQRT(x)
.W
The problem of obtaining starting values for
the Newton-Raphson calculation of SQRT(x) on a 
digital computer is considered.  It is shown that the
conventionally used best uniform approximations 
to SQRT(x) do not provide optimal starting values. 
The problem of obtaining optimal starting values. 
 The problem of obtaining optimal starting values is
stated, and several basic results are proved.  A 
table of optimal polynomial starting values is given.
.I 1567
.T
On the Representation of Symmetric Polynomials
.W
Relations are given between certain symmetric
polynomials in the light of the theory of the 
symmetric group.  Such an approach unifies earlier work
and lends insight to previously published work 
by Aaron Booker.  A generalization of Graeffe's root-squaring
technique for the determination of the 
roots of a polynomial is suggested.
.I 1568
.T
Plotting a Function of Three Independent Variables
.W
A method is developed for constructing an approximate
plot of a function of three independent 
variables.  The plot is similar to a conventional contour
map except that there are three scales to represent 
the independent variables.  Scale values of the three
independent variables are added vectorially, and 
the value of the function is then read from
the values associated with nearby contours.
.I 1569
.T
Implementing Phrase-Structure Productions in PL/I
.W
A method is described for implementing the productions
of a context-free phrase structure grammar 
in a PL/I procedure whose structure and statements parallel
the structure and notation of the grammar.
.I 1570
.T
String Processing Techniques
.W
The internal organization of string processing
systems is discussed.  Six techniques for data 
structures are presented and evaluated on the basis of:
(1) creation of strings; (2) examination of strings; 
and (3) alteration of strings.  Speed of operation, storage
requirements, effect on paging, and programmer 
convenience are also considered.  One of the techniques,
single-word linked blocks, is used in an example 
demonstrating an implementation of a SNOBOL string
processing language on an IBM System/360.
.I 1571
.T
A User-Oriented Time-Shared Online System
.W
An existing system and planned additions within
the Data Processing Laboratory of the Brain 
Research Institute at UCLA is described.  The system
represents an attempt to provide research workers 
of the Institute with the ability to interact directly
with a highly sophisticated digital computing 
complex in the most direct and simple fashion possible.
 It is anticipated that, with the accumulation 
of experience using the present system, significant advances
will be possible in the system design through 
determination of interface parameters between the
biological scientist and the digital computer.
.I 1572
.T
The Simulation of Time sharing Systems
.W
The development of new large scale time-sharing
systems has raised a number of problems for 
computation center management.  Not only is it necessary
to develop an appropriate hardware configuration 
for these systems, but appropriate software adjustments
must be made.  Unfortunately, these systems often 
do not respond to changes in the manner that intuition
would suggest, and there are few guides to assist 
in the analysis of performance characteristics.  The
development of a comprehensive simulation model 
to assist in the investigation of these questions is
described in this paper.  The resulting model has 
a general purpose design and can be used to study a
variety of time-sharing systems.  It can also be 
used to assist in the design and development of new time-sharing
algorithms or techniques.  For the sake 
of efficiency and greater applicability, the model was
implemented in a limited FORTRAN subset that is 
compatible with most FORTRAN IV compilers. The use of
the simulation is demonstrated by a study of the 
IBM 360/67 time-sharing system.
.I 1573
.T
An Adaptive Quadrature Procedure with
Random Panel Sizes (Algorithm [D1])
.I 1574
.T
Normal Curve Integral (Algorithm 304 [S15])
.I 1575
.T
Incomplete Beta Ratio (Algorithm 179 [S14])
.I 1576
.T
Eigenvalues of a Real Symmetric Matrix
by the QR Method (Algorithm 253 [F2])
.I 1577
.T
Eigenvalues and Eigenvectors of a Real Symmetric
Matrix by the QR Method (Algorithm 254 [F2])
.I 1578
.T
Generalized Least Squares Fit By Orthogonal
Polynomials (Algorithm 296 [E2])
.I 1579
.T
Real Error Function, ERF(x) (Algorithm 123 [S15])
.I 1580
.T
Error Function-Large X (Algorithm 180 [S15])
.I 1581
.T
Complementary Error Function-Large X (Algorithm 181 [S15])
.I 1582
.T
GAUSS (Algorithm 209 [S15])
.I 1583
.T
Normal Distribution Function (Algorithm 226 [S15])
.I 1584
.T
Procedure for the Normal Distribution Functions (Algorithm 272 [S15])
.I 1585
.T
Normal Curve Integral (Algorithm 304 [S15])
.I 1586
.T
A Generalized Bairstow Algorithm
.W
The Bairstow algorithm is generalized to the
case of a polynomial which is itself a linear 
combination of polynomials satisfying a three-term recursion.
 Convergence properties of the method are 
derived.
.I 1587
.T
Storage Allocation in a Certain Iterative Process
.W
A method of core storage allocation in a certain
iterative process is described and estimates 
of the machine time required are given.  The method is
applicable to iterative processes in which input 
data items once chosen are never again needed.  In this
method the input data is continuously relocated 
and the space made available apportioned to the output
tables when an overflow occurs.  Some important 
special cases are considered in which considerable simplification occurs.
.I 1588
.T
PL/I List Processing
.W
The concepts of list processing have been introduced
into the PL/I language.  With these new 
facilities, it is possible to write PL/I procedures that
operate on simple and complex data list organizations. 
 Most list-processing languages have suffered from their
inability to deal directly with complex data 
structures and/or from their inability to perform the
complete range of programming language operations 
upon the data list structures.  These two problems have
been eliminated in the list-processing facilities 
of PL/I.  The basic concepts of list processing and
the philosophy of the PL/I language extensions are 
discussed.  In addition, several detailed list-processing examples are provided.
.I 1589
.T
DIALOG: A Conversational Programming System with a Graphical Orientation
.W
DIALOG is an algebraic language for online
use with a graphical input-output console device. 
 It is a computational aid for the casual user, which
provides basic facilities for graphical and numeric 
input and display, online and off line program preparation
and storage, and hard copy presentation of 
results.  Use of the system requires a minimum of experience
or instruction, since the growth of an overlaying 
system control language has been prevented, and there
are no processor-oriented statements, like variable 
type or dimension declarations.  Moreover, in the online
situation the processor interacts with the graphical 
keyboard on a character-by-character basis so as to
restrict the programmer's choice of input symbols 
to those which are syntactically correct. DIALOG has been
in daily operation at the IIT Research Institute 
since February, 1966.
.I 1590
.T
Pitch Period Determination of Speech Sounds
.W
A computer procedure which determines pitch
periods by the recognition of the peak structure 
of the speech waveform is described.  Speech sounds were
sampled by a microphone and an analog-to-digital 
converter attached to an interconnected IBM 7090-PDP-1
system.  These utterances were recorded at the 
normal noise level of the computer room but were not
band-compressed or phase-distorted in any manner. 
 A sequence of operations defined on the speech wave selects
a list of points along the waveform as candidates 
for pitch markers.  These markers are validated by
an error detection and correction procedure.About 
95 percent of the pitch periods were recognized correctly
within 1 to 2 times real-time on the IBM 7090.
.I 1591
.T
A Model for a Multifunctional Teaching System
.W
A teaching system model that was incorporated
into an operating system of a large computer 
is described.  The model transferred control to the
operating system to execute functions other than 
teaching, and then recovered control in order to resume
teaching.  The teaching system (ABAC-II) was 
written to run under the operating system (IBSYS) for
the IBM 7044 Graphic System.  Because the teaching 
system automatically terminated and rescheduled itself,
a student studying a course presented at a cathode-ray 
display terminal could switch readily between student
mode and programmer mode.  During the latter, the 
full resources of the operating system (language processors,
compilers, library and user's programs) 
were at his disposal.  He could for example, write, assemble,
debug, and execute at the terminal a program 
written in any language processed by the operating system.
 A course could therefore include text material 
interleaved with programming problems which the student
could solve without leaving the terminal.  Exercises 
in simulation and gaming could also be provided.  The
implications of a teaching system with this degree 
of flexibility for industrial and executive training
as well as academic education are discussed.  In 
addition, the advantages of this type of system for computer
programming and operation are also considered.
.I 1592
.T
String Similarity and Misspellings
.W
The problem of programming a computer to determine
whether or not a string of characters is 
a misspelling of a given word was considered.  A numberof
algorithms were evaluated-some proposed by 
other writers, some by the author.  These techniques
were tested on a collection of misspellings made 
by students at various grade levels.  While many of
the methods were clearly unsatisfactory, some gave 
as few as 2.1 percent incorrect determinations.
.I 1593
.T
A Simple Technique for Digital Division
.W
A simple and economical method for digital
division is described.  The method is suitable for 
divisors whose leading character is either radix less
one or is unity with the next character equal to 
zero; also the method is direct and needs only half the
number of arithmetic operations needed by a variant 
of the Harvard iterative method, described by Gilman,
which is suitable for similar divisors.
.I 1594
.T
An Algorithm for Generating Permutations
.W
An algorithm is described which under repeated
application generates all permutations of K 
elements.  Only the previously generated permutation,
the constant K, and a temporary index are needed. 
 Starting with a particular ordering of K elements (abcd),
repeated application of the algorithm will 
generate K-1 additional permutations by K-1 successive
rotations.  From the initial circular ordering 
of K objects, another circular ordering can be obtained
by rotating the K-1 lowest elements.  For each 
new K-1 circular ordering, another K-2 can be obtained
by rotating the K-2 lowest elements.  By continuing 
in this manner, applications of the algorithm will generate
all (K-1)! circular orderings, or since each 
circular ordering yields K permutations the
algorithm generates all K! permutations.
.I 1595
.T
On the Computer Enumeration of Finite Topologies
.W
The problem of enumerating the number of topologies
which can be formed from a finite point 
set is considered both theoretically and computationally.
 Certain fundamental results are established, 
leading to an algorithm for enumerating finite topologies,
and computed results are given for n <= 7. 
 An interesting side result of the computational work
was the unearthing of a theoretical error which 
had been induced into the literature; the use of the computer
in combinatorics represents, chronologically, 
an early application, and this side result underscores
its continuing usefulness in this area.
.I 1596
.T
Airy Function (Algorithm 301 [S20])
.I 1597
.T
Transpose Vector Stored Array (Algorithm 302 [K2])
.I 1598
.T
Least Squares Fit By Orthogonal Polynomials (Algorithm 28 [E2])
.I 1599
.T
Numerical Solution of the Polynomial Equation (Algorithm 300 [C2])
.I 1600
.T
Chebyshev Quadrature (Algorithm 279 [D1])
.I 1601
.T
Parallel Numerical Methods for the Solution of Equations
.W
Classical iterative procedures for the numerical
solution of equations provide at each stage 
a single new approximation to the root in question.  A
technique is given for the development of numerical 
procedures which provide, at each stage, several approximations
to a solution of an equation.  The s8everal 
approximations obtained in any iteration are computationally
independent, making the methods of interest 
in a parallel processing environment.  Convergence is
insured by extracting the "best information" at 
each iteration.  Several families of numerical procedures
which use the technique of the procedures in 
a parallel processing environment are developed and measurements
of these statistics are reported.  These 
measurements are interpreted in a parallel processing
environment.  In such an environment the procedures 
obtained are superior to standard algorithms.
.I 1602
.T
POSE: A Language for Posing Problems to a Computer
.W
A language, POSE, is described which is a drastic
departure from the FORTRAN/ALGOL type, though 
it does utilize FORTRAN formula and logic representations
(and actually contains FORTRAN VI as a subset). 
 With the new language, the user need only describe
his problem in "equation-like" form. The method 
of solution is automatically provided in conjunction
with the translation from equation form to computer 
instruction. In this way the POSE language user can
solve difficult computational problems (like the 
solution of differential equation) without requiring
a knowledge of numerical methods or the intricacies 
of computer subroutine logic. Essentially all clerical
operations now required for FORTRAN programming 
have been automated so that the POSE programmer
need not be concerned with these details.
.I 1603
.T
A Multiprogramming Monitor for Small Machines
.W
INT, a combination hardware/software monitor
designed to control a wide variety of real-time 
input/output devices, is described.  The simple hardware
additions provide a uniform device to machine 
interface for such elements as keyboards graphic input
devices, and interval timers.  The software relieves 
the user program from the details of input/output timing,
buffering, and task scheduling and provides 
parallel processing capability.  User programs communicate
with the monitor through a small set of meta-instruction 
which consists mostly of machine-language subroutine calls.
.I 1604
.T
Further Analysis of a Computing Center Environment
.W
Empirical distributions of program lengths,
execution times, processing times, and loading 
times of over 10,000 jobs serviced in a university computing
center environment are presented.  The data 
are subdivided according to certain characteristics of users
and jobs to obtain selected empirical conditional 
distributions of those time properties as well as statistical
measures of other interesting properties. 
 The results are interpreted in terms of the properties of the system studied.
.I 1605
.T
An Experimental Comparison of Time Sharing and Batch Processing
.W
The effectiveness for program development
of the MIT Compatible Time-Sharing System (CTSS) 
was compared with that of the IBM IBSYS batch-processing
system by means of a statistically designed 
experiment.  An identical set of four programming problems
was assigned to each of a group of four programming 
subjects.  Influences external to the systems, such as
the sequence of problem solution, and programmer 
and problem characteristics, were specified as design
factors in the experiment.  Data was obtained for 
six variables (e.g., programmer time, computer time,
elapsed time, etc.) which were considered to be 
definitive of "system effectiveness," and analysis of
variance techniques were employed to estimate system 
differences in these variables after differences due to
the design factors had been eliminated.  Statistical 
analysis of the experimental results provided strong
evidence of important system differences, as well 
as a critique of the experimental design itself
with implications for further experimentation.
.I 1606
.T
Chi-Squared Integral (Algorithm 299 [S15])
.I 1607
.T
Coulomb Wave Functions (Algorithm 300 [S22])
.I 1608
.T
Numerical Integration of Function That Has a Pole
.W
It is common to need to integrate numerically
functions that diverge somewhere outside the 
range of integration.  Even if the divergence occurs quite
far away, integration formulas like Simpson's, 
that depend on fitting a polynomial, usually will be
inaccurate: near a pole they will be very bad.  
A method is described that gives formulas that will integrate
functions of this kind accurately if the 
orders and positions of the poles are known.  Explicit
formulas are given that are easy to use on an 
automatic computer.  It is shown that they can be used
for some other singularities as well as poles. 
 If the integral converges, integration can be carried
to the singularity.  The accuracy of the integration 
with a pole of second order is discussed, and, as an example,
the new formula is compared with Simpson's. 
 The new formulas are useful even far from the pole,
while near the pole their advantage is overwhelming.
.I 1609
.T
Scheduling University Course Examinations by Computer
.W
A new approach to the problem of scheduling
course examinations is presented.  In principle, 
an examination schedule which requires a minimum number
of examination periods and satisfies the constraint 
that no student be required to take two examinations
simultaneously can be found in two steps.  First, 
course which may have their examinations scheduled at
the same period are grouped together in all possible 
ways.  Then a minimum number of these groups, such that
each course is included at least once, are selected. 
 By removing multiple occurrences of courses and then scheduling
each group at a different period a minimal 
schedule can be obtained.  Known algorithms for carrying
out these procedures are prohibitively expensive. 
 Approximations to the ideal procedure outlined above are
given which yield nonminimal but feasible schedules 
with a very small expenditure of time.  Results of experiments
using these techniques are given.  These 
are encouraging and indicate that further experimentation would be worthwhile.
.I 1610
.T
A Method for the Solution of Transportation Problems with Tall Matrices
.W
A method is presented for the solution of the
transportation problem having a cost matrix with 
few columns.  The computer implementation of this method
shows it to be very fast and efficient.  Application 
are indicted for the personnel classification problem
as well as the classical transportation problem. 
 An example is worked out in detail.
.I 1611
.T
Scheduling Project Networks
.W
Some of the basic concepts and terminology
of project networking are developed.  The Critical 
Path Algorithm incorporated in the C-E-I-R proprietary
scheduling system RAMPS (Resource Allocation and 
Multi-Project Scheduling) is described.  The error detection
and network analysis features of the algorithm 
are also described.
.I 1612
.T
Top-to-bottom Parsing Rehabilitated?
.W
This note is concerned with the efficiency
of the Top-to-Bottom parsing algorithm as used in 
connection with programming language grammars.  It is
shown, for instance, that retracing of unprofitable 
paths can often be eliminated by a suitable rearrangement
of the productions defining the grammar.  The 
essential weakness of the method is in dealing with complicated
syntactic structures which are in practice 
only sparsely occupied, e.g., arithmetic expressions.
.I 1613
.T
One-Pass Compilation of Arithmetic Expressions for a Parallel Processor
.W
Under the assumption that a processor may have
a multiplicity of arithmetic units, a compiler 
for such a processor should produce object code to take
advantage of possible parallelism of operation. 
 Most of the presently known compilation techniques
are inadequate for such a processor because they 
produce expression structures that must be evaluated serially.
 A technique is presented here for compiling 
arithmetic expressions into structures that can be
evaluated with a high degree of parallelism.  The 
algorithm is a variant of the so-called "top-down"
analysis technique, and requires only one pass of 
the input text.
.I 1614
.T
A Proposal for Definitions in ALGOL
.W
An extension to ALGOL is proposed for adding
new data types and operators to the language. 
 Definitions may occur in any block heading and terminate
with the block.  They are an integral part 
of the program and are not fixed in the language.  Even
the behavior of existing operators may be redefined. 
 The processing of text containing defined contexts features
a "replacement rule" that eliminates unnecessary 
iterations and temporary storage.  Examples of definition sets
are given for real and complex matrices, 
complex numbers, file processing, and list manipulation.
.I 1615
.T
An Algorithm for Generating Root Locus Diagrams
.W
A technique for using a digital computer to
draw both ordinary and time-lag root locus diagrams 
is described.  Ordinary diagrams are drawn much faster
and more accurately than ever before.  Time-lag 
diagrams, which had been impossible to obtain, are drawn
with the same speed and accuracy as ordinary 
diagrams.
.I 1616
.T
Tensor Calculations on Computer: Appendix
.W
In the main text of the paper [Comm. ACM 9,
12 (Dec. 196), 864], a FORMAC program was discussed 
which is capable of calculating various quantities
of interest in tensor calculus.  This Appendix is 
intended as an example of the program output.  Chrisoffel
symbols calculated for 12 basic orthogonal 
coordinate systems are listed.
.I 1617
.T
Eigenvalues and Eigenvectors of the
Symmetric System (Algorithm 297 [F2])
.I 1618
.T
Determination of the Square-Root of a Positive
Definite Matrix (Algorithm 298 [F1])
.I 1619
.T
Error-Free Methods for Statistical Computations
.W
Neely has discussed computational error generated
by some algorithms used to compute various 
statistics.  In the present paper methods are described
which are error-free, simple in concept, and 
usually less costly in machine time than those mentioned by Neely.
.I 1620
.T
Methods of Evaluating Polynomial Approximations
in Function Evaluation Routines
.W
The method of nested multiplication is commonly
used in function evaluation routines to evaluate 
approximation polynomials.  New polynomial evaluation
methods have been developed in recent years which 
require fewer multiplications than nested multiplication
and may therefore be preferable for use in function 
evaluation routines.  Although some of these methods
do not appear to be practically useful because of 
rounding-error difficulties, several methods of evaluating
low-degree polynomials have been found to 
be satisfactory.  Three such methods are described and illustrated.
.I 1621
.T
Computer Typesetting of ALGOL
.W
An application of computer-aided typesetting
is introduced.  A working method is described 
for publishing ALGOL by computerized translation from
Hardware into Reference representation, computerized 
planning of typographical lay-out and computerized control
of a typesetting machine.  The point is made 
that experts in science, technology, and programming are
guaranteed a correct ALGOL documentation without 
spending valuable time and power on typographic considerations and proofreading.
.I 1622
.T
An Efficient Procedure for the Generation of Closed Subsets
.W
An efficient algorithm is described for generating
subsets of a set S which satisfy constraints 
of the form: "If s(i) is a member of the subset, then
s(j) must also be a member of the subset."  The 
algorithm has been programmed in the WISP language and
successfully run on the IBM 7094 in connection 
with a routine to detect feedback in multidimensional iterative networks.
.I 1623
.T
An Application of FORMAC
.W
A nonlinear circuit analysis problem is stated
and the way in which it was solved using FORMAC 
is indicated.  The solution of the problem using FORMAC
was notable since several other methods that 
were tried failed.  The problem is straightforward (although
untenable by hand) but nevertheless involved 
an elaborate use of the FORMAC language.  The program
was fairly large and utilized practically every 
command.  In particular, it made extensive use of the
PART command.  Several tricks were necessary in 
order to circumvent some of the shortcomings of the
FORMAC system.  This paper is more concerned with 
the use of programming techniques in FORMAC than with
the actual engineering problem, although readers 
may be interested in the problem because it is stated
in a general (mathematical) sense and could be 
of interest in areas other than circuit analysis.
.I 1624
.T
Automatic Dimensioning
.W
Examples of algorithm that will accomplish
automatic storage reservation without the need for 
explicit array declarations are described.
.I 1625
.T
On the Automatic Simplification of Source-Language Programs
.W
Methods of simplification that can be applied
automatically to programs written in an ALGOL-like 
language are discussed.  The simplifications are based
on the form of the program and the knowledge obtained 
by a processor, without any understanding of what the
program is supposed to do.  These methods have 
been implemented in a processor called SURE that accepts
a program written in JOVIAL and outputs an equivalent 
JOVIAL program that may be shorter and may be executed
faster than the original.  SURE is described, 
some of the problems encountered in automatic improvement
at the source-language level are discussed, 
and further types of automatic program improvement are suggested.
.I 1626
.T
Structure of a LISP System Using Two-Level Storage
.W
In an ideal list-processing system there would
be enough core memory to contain all the data 
and programs.  Described in this paper are a number
of techniques that have been used to build a LISP 
system utilizing a drum for its principal storage medium,
 with a surprisingly low time penalty for use 
of this slow storage device.  The techniques include
careful segmentation of system programs, allocation 
of virtual memory to allow address arithmetic for type
determination, and a special algorithm for building 
reasonably linearized lists.  A scheme for binding variables
is described which is good in this environment 
and allows for complete compatibility between compiled
and interpreted programs with no special declarations.
.I 1627
.T
Application of Level Changing to a Multilevel Storage Organization
.W
A technique for organizing the devices of a computer
storage system is described.  This technique, 
called the multilevel store, provides a means for economically
satisfying the requirements for very large 
storage capacities of certain data management and information
retrieval systems.  The concept of level 
changing is introduced and its application to the multilevel
store is discussed.  A possible means for 
physically organizing the information for efficient
use of the multilevel store is presented.
.I 1628
.T
The Emergence of a Profession
.W
Computer programming deals with an enormous
variety of activities and is carried on by people 
with a great variety of backgrounds.  It seems clear
that part but not all of this activity is evolving 
toward a distinct professional field, but that the
scope of this emerging profession, and some of its 
economic, social, and educational characteristics are
as yet by no means well defined.  In this paper, 
these issues are examined and some opinions about them are expressed.
.I 1629
.T
Stat-Pack: A Biostatistical Programming Package
.W
A package of FORTRAN statistical programs for use
on almost any small to medium size (40k characters 
or 8k words) for which a FORTRAN II compiler exists
is described and its availability is announced.  
The major design criteria of ease of use, ease of modification,
flexibility of input and detail of output 
are described.
.I 1630
.T
Computer Representation of Planar Regions by Their Skeletons
.W
Any region can be regarded as a union of maximal
neighborhoods of its points, and can be specified 
by the centers and radii of these neighborhoods; this
set is a sort of"skeleton" of the region.  The 
storage required to represent a region in this way is
comparable to that required when it is represented 
by encoding its boundary.  Moreover, the skeleton representation
seems to have advantages when it is 
necessary to determine repeatedly whether points are inside
or outside the region, or to perform set-theoretic 
operations on regions.
.I 1631
.T
Testing a Random Number Generator
.W
The first 1,000,000 numbers produced by the
random number generator used in the General Purpose 
Systems Simulator (GPSS) were subjected to statistical
tests.  The tests are described and the results 
of the tests are presented.  These particular tests indicate
that the numbers are satisfactory.  It is 
recommended that suitable tests be applied to all
random numbers used in computer simulations.
.I 1632
.T
Programming the Tabular Method of Analysis
of Variance for Factorial Experiments 
.W
The ease of programming the tabular method of analysis
of variance for complete factorial experiments 
in a FORTRAN language is demonstrated.  In this method,
the total sum of squares is partitioned into 
orthogonal single degree of freedom sums of squares;
main effect and interaction sums of squares are 
then obtained by appropriate pooling of the single degree
of freedom sums of squares.  Program segments 
to accomplish the procedure are presented.  Modifications
to handle hierarchical designs and replicated 
experiments are mentioned. A FORTRAN II program
for an IBM 7094 is described briefly.
.I 1633
.T
A Modified Newton Method for Polynomials
.W
A modified Newton method for polynomials is
discussed.  It is assumed one has approximations 
for all the roots of the polynomial.  Three variations
are described.  If the roots are simple, it is 
shown that under appropriate conditions, two
of the variations are cubically convergent.
.I 1634
.T
27 bits Are Not Enough for 8-digit Accuracy
.W
From the inequality 10^8 < 2^27, we are likely
to conclude that we can represent 8-digit decimal 
floating-point numbers accurately by 27-bit floating-point
numbers.  However, we need 28 significant 
bits to represent some 8-digit numbers accurately. 
In general, we can show that if 10^p < 2^q-1, then 
q significant bits are always enough for p-digit decimal
accuracy.  Finally, we can define a compact 
27-bit floating-point representation that will give 28
significant bits, for numbers of practical importance.
.I 1635
.T
Parameters for Pseudo Runge-Kutta Methods
.W
The object of this note is to present a choice
of the free parameters in the third- and fourth-order 
pseudo Runge-Kutta methods involving two points. This
choice of parameters causes a bound on the principal 
part of the truncation error term to be near the minimum
for the fourth-order method and at the minimum 
for the third-order method.
.I 1636
.T
Invariant Imbeding and the Numerical Integration
of Boundary-Value Problems for Unstable Linear 
Systems of Ordinary Differential Equations
.W
In such diverse areas as radiative transfer
in planetary atmospheres and optimal guidance and 
control, two-point boundary-value problems for unstable
systems arise, greatly complicating the numerical 
solution.  An invariant imbeding technique is presented
which is useful in overcoming these frequently 
encountered instabilities, and the results
of some numerical experiments are given.
.I 1637
.T
Problems in the Statistical Analysis of Simulation
Experiments: The Comparison of Means and the 
Length of Sample Records
.W
Research is continued into statistical analysis
of simulation experiments containing autocorrelated 
time series.  It is shown how to estimate the lengths
of sample records needed to use certain large sample 
results in measuring stability.  Analogies between autocorrelated
data and independent observations are 
described.  A way to test the difference of the mean
of two experiments is suggested.  It is shown how 
the variance of the sample mean relates to the spectrum
of the generating process, and estimation of 
the quantities of interest is described. The results
expand the possibilities of statistical spectral 
analysis as applied to simulation experiments.
.I 1638
.T
Sorting by Replacement Selecting
.W
In sorting by replacement selecting, the expected
length of a sequence beginning with the i-th 
element (i>1) is proved to be 2F, in accordance with
a conjecture of E. H. Friend, where F is the number 
of memory cells used.  The expected length of the j-th
sequence is determined to be F times a j-th degree 
polynomial in e, such that the value of this polynomial
approaches 2 as j approaches infinity.  Recursive 
formulas are obtained for both the mean and the standard
deviation of the length of the j-th sequence. 
 The mathematical proofs of these results are based
upon the assumption that n, the number of items to 
be sorted, is infinite, but it is shown that the error
due to the finiteness of n approaches zero rapidly 
as n increases.
.I 1639
.T
Exponential Curve Fit (Algorithm 295 [E2])
.I 1640
.T
Generalized Least Squared Fit By Orthogonal
Polynomials (Algorithm 296 [E2])
.I 1641
.T
A Use of Fast and Slow Memories in List-Processing Languages
.W
A scheme is described which permitting a substantial
increase in memory space utilized to store 
list-structured data.  It consists in reducing to one
level a nonhomogeneous store composed of fast (core) 
and slow (disk or drum) memories.  The space available
in slow memory is divided into pages each containing 
a given number of machine words.  The reduction to a
one-level memory is performed by a program which 
leaves the most often called pages in the fast memory.
 When a new page from slow store is requested, 
the page in core having the longest period of inactivity
is transferred back to the slow store.  The 
complete scheme has been implemented in connection with
a LISP embedding into ALGOL, using an IBM 7044 
with 32k of core memory and disks.  Gains in memory space
were about 100-fold.  As often happens in programming 
applications the price of the additional space is computer
time.  Although the disks have an access time 
10^4 times slower than core, tests indicate that the
actual slow down varied from 3 to 10, depending 
on the number of pages available in the fast store.
.I 1642
.T
Time Sharing on a Computer with a Small Memory
.W
Techniques to make time sharing attractive on
a computer with a small central memory are presented. 
 "Small" is taken to mean that only one user program plus
a monitor will fit into the memory at any time. 
 The techniques depend on having two levels of secondary
storage: level 1, several times larger than 
the main memory and quite fast; and level 2,
many times larger and slower than level 1.
.I 1643
.T
An Improvement to Iterative Methods of Polynomial Factorization
.W
Methods of polynomial factorization which
find the zeros one at a time require the division 
of the polynomial by the accepted factor.  It is shown
how the accuracy of this division may be increased 
by dividing in order of both ascending and descending
powers of the variable and choosing a crossover 
point which minimizes a very simply calculated error criterion.
.I 1644
.T
On the Computation of Least Squares Polynomials
.W
Rounding error accumulated during digital computation
of a least squares polynomial makes the 
computed polynomial only an approximation to the true least
square polynomial.  A simple method for adjust ing 
the constant term of the computed polynomial to get
a better approximation to the true least squares 
polynomial is described.
.I 1645
.T
A Note on Computing Approximations to the Exponential Function
.W
Two methods are discussed which result in near
minimax rational approximations to the exponential 
function and at the same time retain the desirable property
that the approximation for negative values 
of the argument is the reciprocal of the approximation
for corresponding positive values.  These methods 
lead to approximations which are much superior to the
commonly used convergents of the Gaussian continued 
fraction for the exponential.  Coefficients and errors
are given for the intervals [-.5*ln 2, .5*ln 2] 
and [-ln 2, ln 2].
.I 1646
.T
DITRAN-A Compiler Emphasizing Diagnostics
.W
DITRAN (Diagnostic FORTRAN) is an implementation
of ASA Basic FORTRAN with rather extensive 
error checking capabilities both at compilation time
and during execution of a program.  The need for 
improved diagnostic capabilities and some objectives
to be met by any compiler are discussed.  Attention 
is given to the design and implementation of DITRAN
and the particular techniques employed to provide 
the diagnostic features.  The handling of error messages
by a general macro approach is described.  Special 
features which provide teaching aids for use by instructors are noted.
.I 1647
.T
WATFOR-The University of Waterloo FORTRAN IV Compiler
.W
WATFOR is an in-core, load-and-go compiler
which has been implemented within the IBM 7040/44 
operating system.  FORTRAN IV was selected as the source
language in order to achieve maximum language 
compatibility with other available compiling systems,
in particular the IBM 7040/44 FORTRAN IV system. 
 The principal advantage of the WATFOR compiler is that
it translates FORTRAN IV programs at speeds of 
up to 100 statements per second.  Since the compiler
resides core there is virtually no system overhead, 
and hence large batches of "student" programs may be processed very
efficiently.  The compiler also provides 
extensive error diagnostics, during both the compilation
and the execution phases of a program run.  
This feature makes the system attractive to
both learners and learned users alike.
.I 1648
.T
Uniform Random (Algorithm 294 [G5])
.I 1649
.T
Data Directed Input-Output in FORTRAN
.W
A statement which is similar to the NAMELIST
statement of FORTRAN IV has been incorporated 
in the FORTRAN 63 compiler.  The FORTRAN 63 implementation
allows a greater flexibility and simplicity 
than the FORTRAN IV feature.  The Hollerith names, the
location, the mode and the dimensions of a variable 
can be discovered by means of standard FORTRAN statements.
 Methods of using this information are illustrated 
in relation to general purpose data directed input and
output routines; some other uses such as matrix 
manipulation are discussed.
.I 1650
.T
A Unifying Computational Method for the
Analysis of Complete Factorial Experiments
.W
A computational method which may be used for
the calculation of sums of squares in the analysis 
of variance of complete factorial experiments and in
the computation of main effect or interaction means 
is described.  The method is elucidated as unifying since
one method can be used for a variety of purposes 
each previously requiring different methods.  The programming
advantages of such a method are obvious. 
 The following variants are discussed: (1) the standard
analysis of variance; (2) analyses omitting certain 
levels of one or more factors; (3) separate analyses
for some levels of a factor or for combinations 
of levels of more than one factor.  These are performed
simultaneously; (4) the calculation of main effect 
or interaction means.  The mean expects the data in standard
order and it leaves the data in that order 
so that many analyses of the same data can be performed
without rearrangement.  The total sum of squares, 
excluding a replication sum of squares, is partitioned
into all polynomial partitions and their interactions 
each with one degree of freedom.  This is so even
if factors have unequally spaced factor levels.
.I 1651
.T
An Interpretive Input Routine for Linear Programming
.W
In this descriptive article an input code
is presented which greatly simplifies data input 
to any linear programming solution routine, for subsequent
use either as a pedagogical device or for 
solving rather small LP problems.  This latter (limited)
use derives not at all from inherent limitations 
in the code itself, but from an efficiency evaluation:
large LP problems would doubtless benefit from 
an input system more suited for bulk data handling than
the input code described.  From a user's standpoint, 
input appears almost exactly as a textbook presentation
of the LP problem (limited only by a keypunch's 
inability to write subscripts, etc.).  The input interpreter
scans column wise, thus no fixed format 
data preparation is required.  The user may also, under
very general requirements only, liberally use 
editorial comments throughout the input deck as an
aid in identification, e.g., of row constraints.  
The article includes examples of input, output from a
solution routine presently in use, and a skeleton 
flowchart of the input interpreter.
.I 1652
.T
A Code for Non-numeric Information Processing
Applications in Online Systems
.W
A code has been specifically designed to simplify
the internal information processing operations 
within an online computer system with respect to non-numeric
applications, and to maximize the transfer 
rate of the information channel linking the system and
the system user.  The code has direct application 
to problems in area such as information retrieval, document
classification, computer-aided teaching and 
text editing.  This code, called IPC (Information Processing
Code), is an 8-bit code set constructed 
so that 7, 6, 5 and 4-bit subsets can be easily derived
from the basic set.  The code set is organized 
so that simple binary operations can distinguish between
the numeric alphabetic, special symbol and control 
character codes.  The number of usable characters within
the basic set size may be expanded either by 
use of escape codes included in the set, or by suitable
interpretation of otherwise unassigned codes 
on the basis of the requirements of local environments.
.I 1653
.T
System Performance Evaluation: Survey and Appraisal
.W
The state of the art of system performance
evaluation is reviewed and evaluation goals and 
problems are examined.  Throughput, turnaround, and
availability are defined as fundamental measures 
of performance; overhead and CPU speed are placed in
perspective.  The appropriateness of instruction 
mixes, kernels, simulators, and other tools is discussed,
as well as pitfalls which may be encountered 
when using them.  Analysis, simulation, and synthesis are
presented as three levels of approach to evaluation, 
requiring successively greater amounts of information.
 The central role of measurement in performance 
evaluation and in the development of evaluation methods is explored.
.I 1654
.T
A University's Educational Program in Computer Science
.W
After a review of the power of contemporary computers,
computer science is defined in several 
ways.  The objectives of computer science education are
stated, and it is asserted that in a North American 
university these will be achieved only through a computer
science department.  The program at Stanford 
University is reviewed as an example.  The appendices
include syllabic of Ph.D. qualifying examinations 
for Stanford's Computer Science Department.
.I 1655
.T
Code Extension Procedures for Information
Interchange* (Proposed USA Standard)
.K
standard code, code, information interchange, characters,
shift out, shift in, escape, data link 
escape, control functions, standard procedures,
code extension, code table, bit pattern
.C
1.0 2.0 2.43 3.20 3.24 3.50 3.51 3.52 3.53 3.54 3.55 3.56 3.57 3.70 3.71 3.72 
3.73, 3.74, 3.75, 3.80, 3.81, 3.82, 3.83, 5.0, 5.1, 6.2, 6.21, 6.22
.I 1656
.T
Procedures for the Standardization Process* (Proposed USA Standard)
.K
standardization, procedures, criteria
.C
2.3 4.2
.I 1657
.T
Implementation of the SHARER2 Time-Sharing System
.W
A simple mechanism is described for the execution
of part of a program with its own memory 
protection.  This allows such a program to act as a
suboperating system.  An improved version of the 
SHARER time-sharing system using this feature is described.
.K
operating system, memory protection, time-sharing,
multiprogramming, monitor, submonitor, suboperating 
system
.C
4.32 4.31 4.32
.I 1658
.T
Analysis of Algorithms for the Zero-One Programming Problem
.W
This paper is concerned with a review and examination
of several existing algorithms for the 
zero-one programming problem.  Computational experience
is summarized.  The machine time and storage 
requirements of several of the algorithms are compared
over several test problems of small and intermediate 
size.  Computer experiments still provide little hope
of solving problems with over 100 variables with 
a reasonable amount of machine time.
.K
operations research, optimization theory, integer
programming, zero-one variables, algorithms
.C
5.39 5.41
.I 1659
.T
Computational Linguistics in a Ph.D. Computer Science Program
.W
This report contains recommendations for a
course curriculum on computational linguistics in 
a Ph.D. computer science program.  A classification of the
subject areas contained in computational linguistics 
is presented, and ten courses in these areas are described.
 A basic bibliography in computational linguistics 
is appended.
.K
computational linguistics, mathematical linguistics,
language and computer, language data processing, 
computational linguistics course curriculum, computational
linguistics graduate program, computational 
linguistics bibliography, computer science curriculum
.C
1.52 3.42 3.43
.I 1660
.T
Index By Subject To algorithms, 1960-1968
.I 1661
.T
Multint (Algorithm 32 [D1])
.K
numerical integration, multidimensional integration, Gaussian integration
.C
5.16
.I 1662
.T
Eigenvalues and Eigenvectors of a Real General Matrix [F2])
.K
eigenvalues, eigenvectors, latent roots, latent
vectors, Householder's method, QR algorithm, inverse 
iteration
.C
5.14
.I 1663
.T
Generator of Random Numbers Satisfying the Poisson distribution [G5])
.K
Poisson distribution, random number generator, Monte Carlo
.C
5.12 5.5
.I 1664
.T
An Algorithm for Deriving the Equations of
Mathematical Physics by Symbolic Manipulation
.W
A method is described whereby a digital computer
can be used to derive the equations of mathematical 
physics in any curvilinear coordinate system requested
by the user.  The effectiveness of the technique 
is demonstrated by using it to derive the Navier-Stokes
equations of fluid motion and the continuity 
equation.  To derive these equations by this method, the
user need know only the coordinate transformation 
equations relating the curvilinear coordinates of interest
to an orthogonal Cartesian triad. When this 
program is used and the coordinate transformation equations
are supplied as input, the computer will 
derive the Navier-Stokes equations and the continuity
equation.  The equations obtained will be relative 
to the curvilinear coordinate system specified by the
transformation equations used as input.  In this 
paper the emphasis is on theoretical considerations and
methodology rather than on programming details. 
 Results are presented for cylindrical polar
and spherical polar coordinate systems.
.K
FORMAC, Navier-Strokes equations, continuity equation,
tensor, tensor equation, curvilinear coordinate 
systems, FORTRAN, symbolic manipulation
.C
3.21 3.25 3.29 4.12 4.29
.I 1665
.T
Automatic Generation of Efficient Lexical
Processors Using Finite State Techniques
.W
The practical application of the theory of
finite-state automata to automatically generate 
lexical processors is dealt with in this tutorial article
by the use of the AED RWORD system, developed 
at M.I.T. as part of the AED-1 system.  This system
accepts as input description of the multicharacter 
items or of words allowable in a language given in terms
of a subset of regular expressions. The output 
of the system is a lexical processor which reads a string
of characters and combines them into the items 
as defined by the regular expressions.  Each output
item is identified by a code number together with 
a pointer to a block of storage containing the characters
and character count in the item.  The processors 
produced by the system are based on finite-state machines.
 Each state of a "machine" corresponds to 
a unique condition in the lexical processing of a character
string.  At each state a character is read, 
and the machine changes to a new state.  At each transition
appropriate actions are taken based on the 
particular character read.  The system has been in operation
since 1966, and processors generated have 
compared favorably in speed to carefully hand-coded programs
to accomplish the same task.  Lexical processors 
for AED-O and MAD are among the many which have been
produced.  The techniques employed are independent 
of the nature of the items being evaluated.  If the
word "events" is substituted for character string, 
these processors may be described as generalized decision-making
mechanisms based upon an ordered sequence 
of events.  This allows the system to be used in a
range of applications outside the area of lexical 
processing.  However convenient these advantages may
be, speed is the most important consideration.  
In designing a system for automatic generation of a
lexical processor, the goal was a processor which 
completely eliminated backup or rereading, which was nearly
as fast as hand-coded processors, which would 
analyze the language and detect errors, and
which would be convenient and easy to use.
.K
character string, compiler, finite-state automata, finite-state
machine, lexical processor, nondeterministic 
machine, parsing, plex structure, regular expressions,sequential
machine, syntactic analysis
.C
3.63 3.75 4.12 5.22 5.24 5.31
.I 1666
.T
Solution of Linear Programs in 0-1 Variables
by Implicit Enumeration (Algorithm 341 [H])
.K
linear programming, zero-one variables, partial enumeration
.C
5.41
.I 1667
.T
Roots of Polynomials by a Root-Squaring
and Resultant Routine (Algorithm 340 [C2])
.K
root finders, roots of polynomial equations, polynomial
zeros, root-squaring operations, Graeffe 
method, resultant procedure, subresultant procedure,
testing of roots, acceptance criteria
.C
5.15
.I 1668
.T
An Algol Procedure for the Fast Fourier Transform
with Arbitrary Factors (Algorithm 339 [C6])
.K
fast Fourier transform, multivariate Fourier transform,
Fourier series, harmonic analysis, spectral 
analysis, orthogonal polynomials, orthogonal transformation,
virtual core memory, permutation
.C
3.15 3.83 5.12 5.14
.I 1669
.T
Algol Procedures for the Fast Fourier Transform (Algorithm 338 [C6])
.K
fast Fourier transform, complex Fourier transform,
multivariate Fourier transform, Fourier series, 
harmonic analysis, spectral analysis, orthogonal polynomials,
orthogonal transformation, virtual core 
memory, permutation
.C
3.15 3.83 5.12 5.14
.I 1670
.T
Correspondences of 8-Bit and Hollerith Codes for
Computer Environments (A USASI Tutorial Standard)
.K
USA standard, card code, punched card, punched card
code, hole-patterns, hole-patterns assignment, 
punched card systems
.C
1.1 1.4 2.0 2.12 2.43 2.44 3.10 3.20 3.30 3.31 3.42 3.50 3.56 3.70 3.72 3.73 
3.74, 3.80, 3.81, 4.0, 4.1, 4.2, 4.20, 4.40, 5.0
.I 1671
.T
A Phonological Rule Tester
.W
The design and implementation of a system to
alleviate the problem of rule evaluation for the 
linguist in the area of phonology are presented.  It
permits the user to define, on-line, sets of rules 
statable within the framework presented in The Sound
Patterns of English by Chomsky and Halle, 1968, 
to define phonemes as bundles of specified distinctive
features, to define data as strings of phonemes 
with associated grammatical structure, to test the effect
of applying rules to the data, and to store 
both the definitions and results.  The rule application
facility described in detail was implemented 
by translating linguistic rules to rules in FLIP, a
format-directed list processor embedded in LISP. 
 This made the system construction easy while providing
sophisticated capabilities for the linguist. 
 The system is written in BBN LISP on the Scientific
Data System 940 computer and is designed to be used 
on-line in interactive fashion, with control returned
to the user after each command is executed.
.K
phonology, rule tester, linguistics, transformational
grammar, LISP, format-directed list processing, 
on-line systems
.C
3.42 4.13 4.22
.I 1672
.T
Practical Error Coefficients in the Integration
of Periodic Analytic Functions by the Trapezoidal 
Rule
.W
Theoretical and practical values of error coefficients
useful in bounding the error in integrating 
periodic analytic functions with the trapezoidal rule
are tabulated for various ranges of the parameters.
.K
theoretical error coefficients, practical error coefficients,
numerical integration, periodic analytic 
functions, trapezoidal rule, roundoff error,
truncation error, integration algorithm
.C
5.11 5.16
.I 1673
.T
Approximate Solution of Initial Boundary Wave
Equation Problems by Boundary-Value Techniques
.W
A new boundary-value technique is proposed for
the treatment of initial-boundary-value problems 
for linear and mildly nonlinear wave equations.   Several
illustrative examples are offered to demonstrate 
the ease with which the method can be applied.
.K
initial-boundary-value problem, wave equation, boundary-value technique
.C
5.15 5.17
.I 1674
.T
One-Line Random Number Generators and Their Use in Combinations
.W
Some one-line random number generators, i.e.
generators requiring a single FORTRAN instruction 
are discussed, and some short FORTRAN programs which
mix several such generators are described.  The 
aim is to provide methods for incorporating random number
generators directly in FORTRAN programs, by 
means of a few in-line instructions.  The advantages are
speed (avoiding linkage to and from a subroutine), 
convenience, and versatility.  Anyone wishing to experiment
with generators, either using congruential 
generators by themselves or mixing several generators
to provide a composite with potentially better 
statistical properties than the library generators
currently available, may wish to consider some of 
the simple FORTRAN program discussed here. 
.K
random number generation, Monte Carlo, simulation
.C
5.5
.I 1675
.T
A Note on a Relevance Estimate and Its Improvement
.W
In this paper the effect of iterating the improvement
procedure is examined.  It is shown that 
applications of the improvement factor beyond the first
time are ineffectual, and that the factor is 
but a scale factor.
.K
information retrieval, relevance, indexing, classification
.C
3.70 3.71 3.74
.I 1676
.T
The LRLTRAN Compiler
.W
Extensive software problems confront an organization
which possesses a number of different 
computers and which frequently acquires new ones. 
To maintain cohesion, a system must be developed, 
written in a high level language, which minimizes machine
dependencies and isolates those which are necessary. 
 A language and a compiler for the language are discussed
here.  The language, called LRLTRAN, is a heavily 
augmented FORTRAN.  The tree-pass compiler makes use
internally of a postfix Polish notation (pass I 
to pass II) and a tree representation referred to as
a "composite blocking table" (pass I to pass III). 
 Machine-independent optimization occurs in pass II
and DO-loop and machine-dependent optimization in 
pass III.
.K
compiler, compiler-compiler, machine independence,
scatter storage technique, Polish processor, 
common subsegments, tree representation, optimization
.C
4.12 4.20
.I 1677
.T
Storage Organization in Programming Systems
.W
The system of program and data representation
that has been in use on the Rice University computer 
for five years is described.  Each logical entity in storage
occupies a block of consecutive memory locations. 
 Each block is labeled by a codeword and may contain
a program, a data vector, or codewords which in 
turn label blocks to form arrays.  This storage arrangement
is discussed with its realized advantages 
or programming systems: simplicity of programmed addressing,
flexibility of data structures, efficiency 
of memory utilization, variability of system composition
during execution, means of linkage between programs 
and from programs to data, and basis for storage protection.
 The application of labeled blocks may be 
extended to areas of time-sharing and multimedia storage
control.  On the basis of experience at rice, 
some ideas on such extensions are presented.
.K
storage allocation, storage organization, storage
control, codewords, data representation, program 
representation, data structures, storage protection,
addressing mechanisms, paging, segmentation, file 
handling
.C
4.30 4.40 6.20
.I 1678
.T
Automata, Formal Languages, Abstract Switching,
and Computability in a Ph.D. Computer Science 
Program
.W
A number of courses are listed in the area
describe as automata, formal languages, abstract 
switching, and computability, that might be available
to a Ph.D. student in computer science.  A brief 
catalog description of each course is applied and the
role of each of the courses in the graduate program 
is discussed.
.K
Ph.D. computer-science curriculum, Ph.D. computer
science program, automata, formal languages, 
switching theory, theory of computability
.C
1.5 5.2 6.1
.I 1679
.T
A Fast Fourier Transform Algorithm for Real-Valued Series
.W
A new procedure is presented for calculating the
complex, discrete Fourier transform of real-valued 
time series.  This procedure is described for an example
where the number of points in the series is 
an integral power of two.  This algorithm preserves
the order and symmetry of the Cooley-Turkey fast 
Fourier transform algorithm while effecting the two-to-one
reduction in computation and storage which 
can be achieved when the series is real.  Also discussed
are hardware and software implementations of 
the algorithm which perform only (N/4) log2 (N/2) complex
multiply and add operations, and which require 
only N real storage locations in analyzing each N-point record.
.K
fast Fourier transform, time series analysis, digital
filtering, spectral analysis, real-time spectrum 
analyzers, Fourier analysis, discrete Fourier transform,
digital spectrum analysis, Fourier analysis 
algorithm, Fourier synthesis algorithm
.C
3.80 3.81 4.9 5.49 6.22
.I 1680
.T
A General-Purpose Display Processing and Tutorial System
.W
ADEPT (A display-Expedited Processing and Tutorial)
system is described.  This system was designed 
to improve man-computer communications by employing
a display unit to interleave tutoring with other 
computer operations such as simulation, programming, and
information retrieval.  It is written in FORTRAN 
IV (G) for the IBM System/360, Model 40, and the IBM 2250
display Unit under Operating System/360.  Adept 
is a cataloged program that controls the standard operating
system by terminating and rescheduling itself 
automatically, relinquishing computer resources allocated
to it, and surrendering control to the operating 
system to perform other jobs.  It expands the power
and flexibility of computer-assisted instruction 
by making immediately available to students, teachers,
and other users, the full resources (system-cataloged 
programs) of the operating system.  Language processors
and compilers, simulation models, mathematical 
solution techniques, stored data, and all other library and
user programs can be incorporated into instructional 
material without reprogramming.  Illustrations of the various
applications are presented and their implications 
are discussed.
.K
computer-assisted instruction, tutorial systems,
programming, simulation, modeling, information 
retrieval operating systems, graphics, displays, man-machine
interface, on-line computing, graphic programming
.C
1.5 3.3 3.5 3.8 4.0 4.3
.I 1681
.T
Easy English,a Language for Information
Retrieval Through a Remote Typewriter Console
.W
Easy English is a natural command language
designed to simplify communication between man and 
machine through remote typewriter console.  It has been developed
for retrieval of documents from a computerized 
data base, the Moore School Information Systems Laboratory
files.  Requests are formulated in a standardized 
syntactical form (examples of which are presented), and
this form is then transformed into an equivalent 
query expressed in the retrieval system's original Symbolic
Command Language, which is briefly described. 
 Operation of easy English is detailed by illustration
of the transformations performed upon a sample 
request up to the point at which the request string
is sent to the system.  A macro flowchart of Easy 
English is included, and an Appendix provides
the printout of a retrieval demonstration.
.K
natural language communication, on-line searching,
remote console communication, information retrieval, 
man-machine communication, remote terminal communication,
translator, document retrieval, conversational 
mode, information retrieval language, symbolic command language
.C
3.74 3.81 4.19
.I 1682
.T
The Implementation of a BASIC System in a Multiprogramming Environment
.W
The implementation of a remote terminal BASIC system
within the context of an existing multiprogramming 
computer system, the Burroughs B5500, is described.
 This implementation combines a unique mixture of 
machine language and interpretive techniques with an incremental compiler.
.K
multiprogramming, incremental compilation, compilers, interpreters
.C
4.1 4.12 4.2 4.22 4.3 4.32
.I 1683
.T
Boolean matrix Methods for the Detection of Simple Precedence Grammars
.W
A mechanical procedure is derived for determining
whether a given context-free phrase structure 
grammar is a simple precedence grammar.  This procedure
consists of elementary operations on suitably 
defined Boolean matrices.  Application of the
procedure to operator grammars is also given.
.K
syntax analysis, precedence analysis, simple precedence
grammar, simple precedence language, operator 
grammar, operator precedence, compilers, bounded-context
syntactic analysis, Boolean matrices, relations
.C
4.12 5.23
.I 1684
.T
Ambiguity in Limited Entry Decision Tables
.W
The use of decision tables as a tool in systems
analysis and for program specification is now 
becoming accepted.  Rules on redundancy, contradiction,
and completeness for limited entry tables were 
published in 1963.  These are usually used for checking,
preceded if necessary by a conversion from extended 
to limited entry form.  Processors which automatically
translate tables to more conventional program 
usually base their diagnostic facilities on these rules.
 In this paper it is suggested that these rules 
are unsatisfactory and that the important aspect of
checking is to eliminate ambiguity from tables.  
Ambiguity is defined and discussed, and a procedure for
producing checked-out decision tables is proposed. 
 The theoretical basis of the algorithm used is established.
The importance of well-designed diagnostic 
facilities in decision table processors is emphasized.
.K
decision tables, DETAB-65, systems analysis 
.C
3.50 4.19 4.49
.I 1685
.T
GAN, a System for Generating and Analyzing Activity Networks
.W
GAN, a system for generating activity networks,
is designed to save time in the preparation 
of activity networks and to deal conveniently with network
programs.  A defining description of a programming 
language designed for generating activity network from
a set of standard networks is presented.  Also, 
a general idea of a language for performing calculations
on activity networks (scheduling activity networks) 
is given.
.K
activity network, management project, standard network,
network generator, network assembler, activity 
network analysis, network calculation, network program
.C
3.50 3.53 4.11 4.12 4.29
.I 1686
.T
Computer Synthesis of Holograms for 3-D Display
.W
Optical and digital holography are reviewed.
 The mathematical model and computational techniques 
of the authors' digital holographic process are discussed,
and applications of computer holography are 
suggested.  Computer holograms have been made of three-dimensional
objects which give faithful reconstructions, 
even in white light.  A new approach based on point
apertures for the image is discussed.  Photographs 
of the images reconstructed from digital holograms are presented.
.K
holography, optics, Fourier transforms, computer
applications, display device, photography, physics, 
mathematics, image processing
.C
3.17 3.19 5.19
.I 1687
.T
Netflow (Algorithm 248 [H])
.K
capacitated network, linear programming, minimum-cost
flow, network flow, out-of-kilter
.C
5.32 5.41
.I 1688
.T
Netflow (Algorithm 248 [H])
.K
capacitated network, linear programming, minimum-cost
flow, network flow, out-of-kilter
.C
5.32 5.41
.I 1689
.T
Calculation of a Polynomial and its Derivative
Values by Horner Scheme (Algorithm 337 [C1])
.K
function evaluation, polynomial evaluation,
Algol procedure, Horner's scheme
.C
5.12 4.22
.I 1690
.T
Netflow (Algorithm 336 [H])
.K
capacitated network, linear programming, minimum-cost
flow, network flow, out-of-kilter
.C
5.32 5.41
.I 1691
.T
A Comparison of the Correlational Behavior
of Random Number Generators for the IBM 360
.W
Hutchinson states that the "new" (prime modulo)
multiplicative congruential pseudorandom generator, 
attributed to D. H. Lehmer, has passed the usual statistical
tests for random number generators.  It 
is here empirically shown that generators of this type
can produce sequences whose autocorrelation functions 
up to lag 50 exhibit evidence of nonrandomness for many
multiplicative constants.  An alternative generator 
proposed by Tausworthe, which uses irreducible polynomials
over the field of characteristic two, is shown 
to be free from this defect.  The applicability of these
two generators to the IBM 360 is then discussed. 
 Since computer word size can affect a generator's statistical
behavior the older mixed and simple congruential 
generators, although extensively tested on computers
having 36 or more bits per word, may not be optimum 
generators for the IBM 360.
.K
random numbers, pseudorandom number generators, autocorrelation
function, serial correlation, digital 
shift-register generators, linear recurrence modulo
two, irreducible polynomials, primitive trinomials 
modulo two, congruential generators, prime numbers,
statistical tests for randomness, IBM 360, 32-bit 
versus 36-bit word size
.C
5.5
.I 1692
.T
Numerical Solution of a Thin Plate Heat Transfer Problem
.W
The numerical solution of a system of linear
equations resulting from a discrete approximation 
to a thin plate heat transfer problem is considered.
 The slow convergence of point iterative methods 
is analyzed and shown to be caused by one of the boundary
conditions. The difficulty may be removed by 
a standard line iterative technique.
.K
heat transfer problem, Poisson equation, boundary
value problem, thin domain, successive overrelaxation 
(SOR), block SOR
.C
3.20 5.17
.I 1693
.T
GPL, a Truly General Purpose Language
.W
A truly general purpose programming language,
GPL, is described which contains facilities for 
constructing (within the language) new data types as
well as facilities for operations performed upon 
them.  The basic language is minimal in the sense that
no basic element can be derived from the others 
with high efficiency in the object programs.  Constructs
like the ALGOL 60 for-statements,and if-statements 
are not basic; they are special types of procedures.
 New "symbols" (underlined words in ALGOL 60) are 
implicitly defined by usage in other declarations.  As
part words are definable, packed words are handled 
as easily as full words.  "Address" variables
(pointers) are included in full generality.
.K
programming language, general purpose, self-extending, macro, ALGOL
.C
4.20
.I 1694
.T
An Algorithm for the Probability of
the Union of a Large Number of Events
.W
An algorithm is presented which efficiently evaluates
the probability for the union of n independent 
and not mutually exclusive events. The problem is that
of evaluating the sums of the products of all 
possible combinations of n variables in minimum time and storage space.
.K
algorithm, probability, optimum, storage vs. time
compromise, set union, mutually exclusive events
.C
5.12 5.5 5.6
.I 1695
.T
PLEXUS-An On-Line System for Modeling Neural Networks
.W
A description is presented of PLEXUS, a system
which enables a user to construct and specify 
a neural network, to analyze the output data produced
by the network, and to store and retrieve networks 
and data from a library.  The system, operated entirely
from a digital display unit, interacts directly 
with the user and permits easy and rapid transitions
between the various phases of the modeling process. 
 PLEXUS is designed to complement neurophysiological research
so that the systematic development of neural 
models can be coordinated with experimental work.  PLEXUS
networks are built up from components representing 
individual neurons, external stimuli, and interconnecting
fibers, each component being of a relatively 
detailed nature.  Provision is also made for the use of
experimental data as input to a network.  Convenient 
means for specification and modification of a network and
extensive error-checking capabilities are provided. 
Data resulting from the simulation of a network may be
analyzed by a variety of techniques ranging from 
examinations of the gross characteristics of the data to
the determination of detailed statistical properties.
.K
biological modeling, data analysis, discrete system
simulation, library systems, modeling, network 
simulation, neural networks, neurophysiological
models, on-line simulation, simulation
.C
3.12 3.19 3.29 3.65
.I 1696
.T
An Algorithm for Identifying the Ergodic Subchains
and Transient States of a Stochastic Matrix
.W
An algorithm for identifying the ergodic subchains
and transient states of a stochastic matrix
is presented.  Applications in Markov renewal programming
and in the construction of variable length 
codes are reviewed, and an updating procedure for dealing
with certain sequences of stochastic matrices 
is discussed.  Computation times are investigated experimentally
and compared with those of another recently 
propose method.
.K
stochastic matrix, ergodic, chain identification
.C
5.39 5.5
.I 1697
.T
Graphical Input/Output of Nonstandard Characters
.W
A system developed at Harvard for graphically
inputting and outputting nonstandard characters 
on a computer is printed.  In principle, the system
can deal with any orthography, although at present 
it is limited to 4000 Chinese characters and some mathematical
symbols.  New characters can be added 
to the repertoire of the system by graphical input on
a display scope.  Text inputting is accomplished 
via a display scope or a Rand Tablet.  The organization
and operation of the current system are described, 
and a discussion of the relative merits of such a system
is given.  Illustrations of the computer input 
and output of Chinese characters are included.  
.K
Chinese characters, input/output, orthography, Rand
Tablet, PDP-1, automatic typesetting, man-machine 
communication, computer graphics, graphical input, on-line editing
.C
3.40 4.41
.I 1698
.T
A Statistical Model for Console Behavior in Multiuser Computers
.W
The ability of a computer system to communicate
with the outside world efficiently is as important 
as its ability to perform computations efficiently. 
It is quite difficult to characterize a particular 
user, but rather easy to characterize the entire user community.
 Based on the properties of this community 
we have postulated a hypothetical "virtual console."
 No claim is made that a virtual console behaves 
like any actual console, but the entire collection of
virtual consoles models the collection of actual 
consoles.  Using the model we answer questions like: 
How many processes are suspended waiting for console 
input?  What is the maximum rate at which a process can
execute?  What bounds can be set on overall buffer 
requirements?  Answers to these and similar questions
are needed in certain aspects of operating system 
design.
.K
statistical models for input-output, operating
system design, input-output design
.C
4.30 4.41 5.5
.I 1699
.T
Experimental Evaluation of Information
Retrieval Through a Teletypewriter
.W
Experiments designed to evaluate the capabilities
of mechanized information retrieval systems, 
with emphasis on interactive (man-machine) language and on
some of the mechanical and psychological limitations 
in their design, were conducted at the Moore School information
Systems Laboratory.  The basic assumption 
of the research is that an information retrieval system
that provides for man-machine dialogue at a remote 
inquiry terminal should provide a searcher with many
of the tools which would be available to him were 
he actually performing his search at a library or repository
of documents.  Factors involved in evaluation 
of such a system include ease of use, learning time, and
effectiveness of actual retrieval.  Three experiments 
and the conclusions resulting from them are detailed.
.K
information retrieval testing,  information system
evaluation, experimental document retrieval, 
document retrieval, document perusal, man-machine communication,
remote console communication, teletypewriter 
communication, remote terminal communication, retrieval
command language, symbolic command language, 
interactive systems, user learning factors, on-line searching
.C
3.72 3.74 3.79 3.81
.I 1700
.T
PEEKABIT, Computer Offspring of Punched
Card PEEKABOO, for Natural Language Searching
.W
The "peekaboo" idea from punched card information
retrieval methods has been mated with the 
idea of superimposed punching to produce a programming
technique which cuts computer run time in half 
on a test search of 33,000 subject index entries.  A search
program using the device has been operational 
since late 1963.  As an item is entered in the store,
an 18-byte mask is created from the item's meaningful 
words using the inclusive OR operation.  If, at search
time, the logical product (using the AND operation) 
of this mask and a similarly constructed question mask
is not equal to the question mask, then one or 
more question words are not present in the store item.
 An equality is in conclusive; the words of the 
store item must be unpacked and compared with question
words.  The present store is made up of over 600,000 
subject index entries estimated to average 60 characters
each.  Longer texts, such as abstracts, could 
be handled by multiple masks.
.K
peekaboo, superimposed coding, natural language
searching text searching, information compaction, 
computer search technique
.C
3.74
.I 1701
.T
Synchronous Signaling Rates for Data
Transmission* (Proposed USA STandard)
.I 1702
.T
Commentary on Mr. Mooers' Paper
.I 1703
.T
Accommodating Standards and Identification of Programming Languages
.W
The user public wants standardization and
reliable identification of programming languages 
and related services.  One way of achieving these goals
illustrated by the methods adopted for TRAC T-64 
interactive language, and its related family of languages.
 Oppressive rigidity usually associated with 
standardization is avoided by a new accommodation technique
accessible to the user to allow local variations 
with the language.  Explicit standardization of the language
is undertaken at the organizational source 
of the language.  Use of the organizational trademark
(TRAC) on the published standards, and services 
relying upon them, provides a reliable public identification.
 These methods can be usefully applied 
to other programming languages and computer services.
.K
standardization, programming languages, TRAC T-64
language, tranemark, public identification of 
programming languages, standards which accommodate
.C
2.12 4.2 2.9
.I 1704
.T
Minimum Excess Cost Curve (ALgorithm 217 [H])
.K
critical path scheduling, PERT, cost/time tradeoffs, network flows
.C
3.59 5.41
.I 1705
.T
A Set of Basic Input-Output Procedures (Algorithm 335 [15])
.W
By means of the primitives in symbol, outsymbol
and length, as requested by this journal's 
Algorithms Policy [Comm. ACM 10 (Nov. 67), 729] a basic
set of input-output procedures is defined aiming 
at quality and flexibility.  Outreal, for instance, is
written as a derived procedure; it outputs using 
the fixed point or the floating point representation,
and rounds properly.  Variants can easily be written 
because of the explicit call of the procedures decompose
integer and decompose real.  The highly recommended 
practice of echoing input is made easy with one subset
of derived procedures (ioi, ior, iob, ioa).  The 
documentation of output in the form of equivalent ALGOL
statements is also provided when use is made 
of the subset oti, otr, otb, ota.  The Berkeley style
of providing information on the form of output 
using prior calls of procedures such as real format is
defined.  A use of the parameter outchannel to 
provide information for simultaneous output to several
channels is suggested.  Interrelationship between 
the declared procedures is furnished in tabular form.
.K
input output, transput, input output procedures,
input echo, quality output, decompose integer, 
decompose real, style, Berkeley style, procedures relationship,
output documentation, equivalent ALGOL 
statements, ALGOL, ALGOL 60, integer format, real format,out
integer, read real, input output Boolean, 
input output array, fixed point representation, floating
point representation, output channel interpretation
.C
4.0 4.41
.I 1706
.T
CHAMP-Character Manipulation Procedures
.W
A new programming language facility for symbol
manipulation is described.  String procedures 
may be declared and called in a standard ALGOL context.
 ALGOL procedures can in turn be called by string 
procedures so that numeric and symbolic processes may
conveniently be programmed together.  Concatenation 
and a variant of SNOBOL's pattern matching make up
a set of primitive commands.  These are assembled 
together into conditional expressions which are to be
used to provide alternative computational patterns. 
 Arrays of strings are processed using quantifiers.
 The class of things which may be assigned to an 
identifier can be restricted by a procedure expressed
in the notation.  The language facilities have 
been implemented in the ALGOL compiler for the Burroughs B5500.
.K
symbol manipulation, string handling, character
manipulation, conditional expressions, procedures, 
structure matching, recursive programming, quantifiers
.C
4.22 4.13
.I 1707
.T
Generation of Positive Test Matrices with Known Positive Spectra
.W
Sufficient conditions are given for a real
matrix to be similar to a positive matrix.  This 
result is used to construct a similarity transformation
which, when applied to a particular upper triangular 
matrix, yields a positive matrix with a preassigned positive spectrum.
.K
test matrices, positive matrices, similarity
transformation, positive eigenvalues
.C
5.1 5.14
.I 1708
.T
A Note on the Efficiency of a LISP Computation in a Paged Machine
.W
The problem of the use of two levels of storage
for programs is explored in the context of 
a LISP system which uses core memory as a buffer for
a large virtual memory stored on a drum.  Details 
of timing are given for one particular problem.
.K
storage management, list processor implementation,
LISP, paging, secondary storage utilization, 
efficiency of paged computation
.C
3.7 4.1 4.2
.I 1709
.T
A Modification of Efroymson's Technique for Stepwise Regression Analysis
.W
The computational technique conventionally used
for stepwise multiple linear regression requires 
the storage of an n X n matrix of data.  When the number
of variables, n, is large, this requirement 
taxes the storage capacity of presently used machinery.
 The near symmetry of the matrices involved permits 
a modification requiring only half the storage and computations
of the conventional algorithm and this 
additional storage allows the analysis of problems containing
more variables.  Alternatively, it permits 
the analysis of problems containing the same number
of variables but with all computations performed 
in double precision.
.K
multiple linear regression, statistical recurrence
formulas, correlation, linear statistical models, 
statistical computer programs, curve fitting
.C
4.0 4.40 5.0 5.5 5.10 5.13
.I 1710
.T
ASP-A Ring Implemented Associative Structure Package
.W
ASP is a general purpose Associative Data
Structure Package in which an arbitrary number of 
data items and an arbitrary number of the relationships
between these data items may be represented. 
 A special picture language is described which has proved
very useful for drawing ASP structures on paper. 
 ASP structures are built and manipulated by means
of a series of macro calls, which are outlined in 
the Appendix.  Emphasis is on the philosophy of the system
rather than a particular implementation, though 
sufficient information is included to enable the
reader to produce his own implementation of ASP.
.K
associative, data structure, ring structure lists,
list structure, set languages, modeling, graphics
.C
4.20 4.22
.I 1711
.T
When Your Computer Needs a Lawyer
.W
Possible liability for negligence, for other
torts (such as slander of credit) and for liability 
under theories of express or implied warranty (guarantees)
are discussed, and legal complications are 
explained, so that users, operators, owners, and leasors
of computers may be alerted to potential legal 
problems. Focus is also on trouble spots in contracting
for data processing services, in automating record 
keeping operations, in deciding whether or not to automate
certain operations, and in complying with 
statutes and regulation relating to record keeping.
 Information is given on patents, copyrights and 
trade secret protection for programs, and the problem
of using copyrighted material in information storage 
and retrieval systems, including the pending
copyright and patent revision bills.
.K
law, legal, lawyer, liability, torts, negligence,
contracts, warrantees, guarantees, accounting, 
regulations, simulation, income tax, copyrights, patents,
trade secrets, standard of care, slander of 
credit, crime, criminals, record keeping records, evidence, copying
.C
1.3 2.11 2.12 2.2 3.33
.I 1712
.T
Recovery of Disk Contents After System Failure
.W
A method is discussed by which, after a system
malfunction, the contents of disk files can 
be restored to their status at the time of the failure.
.K
data acquisitition, disk file organization,
error recovery, file organization
.C
3.73
.I 1713
.T
On Overcoming High-Priority Paralysis
in Multiprogramming Systems: A Case His tory
.W
High-priority paralysis is the degradation
that can occur in multiprogramming systems when 
scheduling is based primarily on preassigned priorities.
 It can be alleviated by modifying the scheduling 
algorithm to maximize the number of programs active
at one time.  The case his tory given in this paper 
indicates two general methods by which simultaneity can
be increased.  Possible refinements in the scheduling 
algorithm for future improvements are considered briefly.
.K
multiprogram scheduling, dynamic priority assignment scheduling
.C
4.30 4.32 4.39
.I 1714
.T
Procedure for the Normal Distribution (Algorithm 272 [S15])
.K
normal distribution function, error function,
normal function, normal curve integral
.C
5.5 5.12
.I 1715
.T
Direct Search (Algorithm 178 [E4]) 
.K
function minimization, search, direct search
.C
5.19
.I 1716
.T
Normal Random Deviates (Algorithm 334 [G5])
.K
normal deviates, normal distribution, random number,
random number generator, simulation, probability 
distribution, frequency distribution, random
.C
5.5 5.13
.I 1717
.T
Generating Prime Implicants Via Ternary Encoding and Decimal Arithmetic
.W
Decimal arithmetic, ternary encoding of cubes,
and topological considerations are used in an 
algorithm to obtain the extremals and prime implicants
of Boolean functions. The algorithm, which has 
been programmed in the FORTRAN language, generally requires
less memory than other minimization procedures, 
and treats DON'T CARE terms in an efficient manner.
.K
prime implicants, extremal, switching function,
minimization, cubical complexes, ternary encoding
.C
3.24 6.1
.I 1718
.T
"Logical" Arithmetic on Computers
with Two's Complement Binary Arithmetic
.W
Algorithms are presented for multiplication
and division of unsigned integer operands in which 
the digits normally reserved for signs participate as
significant arithmetic digits with positive weight.
.K
binary arithmetic, unsigned operand arithmetic,
maximum significance arithmetic, full-precision 
arithmetic
.C
3.15 5.11
.I 1719
.T
A Methodology for Calculating and
Optimizing Real-Time System Performance
.W
The continually increasing size, complexity,
number of types, and cost of data processing systems 
are causing serious re-examination within government
and industry of the criteria for and methods of 
calculating and optimizing data processing system cost
and performance.  Real-time data processing systems 
as typified by the automated airline reservation system
are discussed in this paper.  Criteria for evaluating 
performance are described; a methodology for calculating
and optimizing is outlined; and the method is 
illustrated by carrying out a portion of the performance
calculation and the optimization of a drum-oriented 
message switching system.
.K
real-time system analysis, real-time system design,
real-time system performance criteria, real-time 
system cost performance ratio
.C
3.27 3.80 3.81 3.89 6.9
.I 1720
.T
Master's Level Computer Science Curricula
.W
The results of a survey of the course work done
by master's degree candidates at 25 US universities 
are presented, and some general comments concerning
the emphasis of these programs are given.  
.K
surveys, education, computer science curricula
.C
1.52
.I 1721
.T
Determination of the Intersection Points of Two
Plane Curves by Means of Differential Equations
.W
A new method is proposed to calculate the intersection
points of two plane curves.  The theory 
of singular points off a system of two differential equations
is used in developing the method. The intersection 
point to be determined is identified with such a singular
point and appropriate modifications are applied 
to the system to ensure that the singular point be stable,
i.e. all integrals which start in the neighborhood 
of the singular point will always approach this point
if the integral parameter tends to infinity.  In 
addition a method is described for systematically searching
for all intersection points in a prescribed 
rectangular area.
.K
plane curves, intersection points, intersections
plane curves, integration, differential equations, 
matrix iteration, singular points, nonlinear differential
equations, eigenvalues, complex roots, roots, 
stationary points, Runge Kutta, stable singularity, unstable singularity
.C
2.0 3.10 3.20 3.50 5.10
.I 1722
.T
Methods of Convergence Improvement for Some Improper Integrals
.W
In the numerical integration of an improper
integral of the first kind, it is customary to 
truncate the integral when the change yielded by the last
iteration is less than some predetermined constant. 
The efficiency of such integration schemes can often
be improved by use of recent advances in the theory 
of nonlinear transformations; however, for several important
integrals, e.g. integrals whose integrands 
are rational polynomials, these transformations fail
to yield much improvement.  In this paper, several 
methods of convergence improvement are developed which greatly
improve convergence of some improper integrals, 
including the integrals of rational polynomials.
.K
approximation, nonlinear, improper integral, convergence
improvement, numerical integration, rational 
polynomials, truncation
.C
3.15 5.13 5.16 5.19
.I 1723
.T
Computer Construction of Project Networks
.W
Project networks are used in PERT and CPM.
 An algorithm is given for constructing project 
networks directly from the project precedence relations.
 The algorithm creates "dummy" activities and 
topologically orders the arcs and nodes.  The number of
nodes created is minimal for the given precedence 
relations.  It has been experimentally programmed
in FORTRAN II for the IBM 7094.
.K
project networks, PERT, CPM, topological
ordering, network construction by computer
.C
5.32
.I 1724
.T
A Generalized Partial Pass Block Sort
.W
The design of a partial pass block sort with
arbitrary range of key and number of work files 
is described. The design is a generalization of the Partial
Pass Column Sort by Ashenhurst and the Amphisbaenic 
Sort by Nagler. The power of the sort is tabulated for
various sizes of input file and number of work 
files. consideration is given to the problem of combining
a block sort with internal sorts, and to the 
best use of direct access storage devices.
.K
block sort, partial pass sort, direct access devices,
column sort, chaining, reverse chaining, 
sort, amphisbaenic
.C
5.31
.I 1725
.T
A Simple Proof of Lewin's Ordered-Retrieval
Theorem for Associative Memories
.W
An efficient method of ordered retrieval of binary
words from an associative memory, as described
by Lewin, is based on the use of special readout circuits
which indicate the digit values present in 
the individual digit columns of the memory.  Thus the
circuits indicate whether the individual digit 
columns contain digits of both values, or of only one
value, or contain no digits at all (i.e. that the 
memory is empty).  The use of these circuits, which
in this paper are termed column value indicators, 
reduces considerably the number of memory accesses necessary
to retrieve in order a number of distinct 
words from the memory.  Lewin proves that, for the readout
by the described method of m distinct binary 
words, 2m - 1 memory accesses are necessary.  (Thus he
proves that the number of necessary memory accesses 
of his method, unlike those of other methods, is independent
of the word length.)  In this paper a very 
simple proof of this theorem derived from some elementary
aspects of the structure of sets of binary 
numbers is presented.
.K
associative memories, content-addressed memories,
ordered lists, ordered information retrieval, 
ordered retrieval theorem, column digit values, digit
value variety, column sensing arrangement, digit 
value readout, digit variety readout, memory access, memory
access frequency, ordered retrieval efficiency, 
access frequency proof, retrieval theorem proof
.C
3.74 3.79 5.29 5.31 6.31 6.36
.I 1726
.T
Preliminary Investigation of Techniques
for Automated Reading of Unformatted Text
.W
Methods for converting unstructured printed
material into computer code are experimentally 
investigated.  An operator-controlled mode, depending
on human demarcation of the various regions of 
the page for guiding the scanner, is implemented by
means of a joystick and a CRT display.  This mode, 
for which some performance figures are obtained, is thought
to be suitable for processing very complicated 
material, such as technical journals.  For simpler material,
for instance the "claims" sections of patents, 
and in applications where the utmost accuracy is not necessary,
an unsupervised mode is advocated.  Here, 
the textual portions of the page are located during
a rapid prescan by a rudimentary form of frequency 
analysis.  These areas are then rescanned at a higher
resolution suitable for character recognition. 
 Error rates of the order of 0.1 percent are obtained in
a simple problem involving photographs of telephone 
company meter boards.  Other matters related to the
design of a general purpose page reader, such as 
the segmentation of printed text, the possibility of
time-sharing the scanner, interactive man-machine 
operation, and the facsimile reproduction of illustrations, are discussed.
.K
pattern recognition, character recognition, text
reading, information retrieval, unformatted text 
operator-controlled reader, online reader,
text-image discrimination, reading machine
.C
3.63 3.79 3.89 6.29 6.35
.I 1727
.T
One Way of Estimating Frequencies of Jumps in a Program
.W
For the segmentation of a program it is useful
to have a reasonable estimation of the values 
of S(ij), where S(ij) is the mean value of the number
of jumps from the i-th instruction on to the j-th 
instruction in the run time.  In the cases where the
S(ij) are estimated directly, the structure of the 
whole program must be generally taken into account;
therefore it is very difficult for the programmer 
and/or the translator to obtain a good estimation of
the S(ij).  It is easier to estimate not S(ij) but 
the quantities P(ij)=S(ij)*C(i)/SUM[S(ij), j=1,N], where
C(i) is an arbitrary positive constant for each 
i.  Although the P(ij) are, for each i, proportional to
S(ij), the estimation of P(ij) is easier, because 
we must estimate only the "probabilities" of events
where instruction i is executed after instruction 
I(i).  This estimation can often be done without considering
the structure of the whole program.  In 
the first part of the paper, using the theory of the
Markov chains, an algorithm for the computation 
of the S(ij) from the P(ij) is found, and some ways
of obtaining estimates of the P(ij) are given.  In 
the second part a variant of this algorithm is derived,
avoiding the necessity of computation involving 
large matrices.
.K
object program reduction, supervisor calls decreasing,
jump frequencies estimation, control transfers 
estimation, optimal program segmentation, Markov chain
program correspondence, program graph, one-entry 
subgraph, locally estimated jump frequencies, supervisor
overhead decreasing, program segmentation algorithm, 
jump frequencies, program segmentation problem
.C
4.11 4.19 4.39 4.49
.I 1728
.T
Further Experimental Data on the Behavior
of Programs in a Paging Environment
.W
Results are summarized from an empirical study
directed at the measurement of program operating 
behavior in those multiprogramming systems in which
programs are organized into fixed length pages.  
The data collected from the interpretive execution of
a number of paged programs are used to describe 
the frequency of page faults, i.e. the frequency of those
instants at which an executing program requires 
a page of data or instructions not in main (core) memory.
 These data are used also for the evaluation 
of page replacement algorithms and for assessing the
effects on performance of changes in the amount 
of storage allocated to executing programs.
.K
paging systems, paging, dynamic program behavior, program
behavior, virtual memory systems, single-level 
storage, one-level storage, operating system simulation,
operating systems, supervisor simulation, machine 
language program interpretation
.C
4.13 4.32 4.39 4.9
.I 1729
.T
Minit Algorithm for Linear Programming (Algorithm 333 [H])
.K
linear programming, dual simplex method, primal problem, dual problem
.C
5.41
.I 1730
.T
Jacobi Polynomials (Algorithm 332 [S22])
.K
Jacobi polynomials, orthogonal polynomials,
three-term recurrences, special functions
.C
5.12
.I 1731
.T
Gaussian Quadrature Formulas (Algorithm 331 [D1])
.K
quadrature, Gaussian quadrature, numerical integration,
weight function, orthogonal polynomials
.C
5.16
.I 1732
.T
Factorial Analysis of Variance (Algorithm 330 [G1])
.K
factorial variance analysis, variance, statistical analysis
.C
5.5
.I 1733
.T
Distribution of Indistinguishable Objects
into Distinguishable slots (Algorithm [G6])
.K
object distributions, combinations, distribution numbers
.C
5.39
.I 1734
.T
Chebyshev Solution to an Overdetermined
Linear System (Algorithm 328 [F4])
.K
Chebyshev solutions, overdetermined linear
systems, linear equations, exchange algorithm
.C
5.13 5.14 5.41
.I 1735
.T
A Futures Market in Computer time
.W
An auction method is described for allocating
computer time that allows the price of computer 
time to fluctuate with the demand and the relative priority
of users to be controlled so that more important 
projects get better access.  This auction is free of the
periodic fluctuation in computer use often associated 
with monthly time allocation schemes.
.K
computer scheduling, auction, time allocation, operating efficiency
.C
2.40
.I 1736
.T
Heading Format for Data Transmission (A USAAI Tutorial -- Standards)
.K
data transmission heading format, heading format,
message format, data transmission, message headings
.C
3.57 3.81 6.39
.I 1737
.T
A Global Parser for Context-Free Phrase Structure Grammars
.I 1738
.T
Writing an Outline Debugging Program for the Experienced User
.W
Presently available online debugging routines
are often unsatisfactory for the experienced 
user because they require unnecessarily rigid and complicated
typing formats, make it difficult for the 
user to correct typing errors, and consume excessive
memory with intricate features.  In a debugging 
program it is of prime importance that the program
be simple, flexible, and highly efficient to use. 
 Communication between the user and the debugging program
can be improved by using certain techniques 
applicable to most online debugging programs.  These
techniques are presented and are illustrated by 
their use in OPAK (octal package), a debugging program coded
for the PDP-5/8 and the SDS-930.  The compromise 
between economy of utility program core storage and incorporation
of elegant debugging features is discussed.
.K
debugging, utility program, programming languages
.C
4.42
.I 1739
.T
Regular Expression Search Algorithm
.W
A method for locating specific character strings
embedded in character text is described and 
an implementation of this method in the form of a compiler
is discussed.  The compiler accepts a regular 
expression as source language and produces an IBM 7094
program as object language.  The object program 
then accepts the text to be searched as input and produces
a signal every time an embedded string in 
the text matches the given regular expression.  Examples,
problems, and solution are also presented.
.K
search, match, regular expression
.C
3.74 4.49 5.32
.I 1740
.T
An Inexpensive Braille Terminal Device
.W
The active use of time-shared facilities for
blind programmers requires a braille terminal 
system.  Details are given for the construction of a
brailler from a model 33 teletype by modifying the 
print head and increasing the resiliency of the platen.
 A description of the programming needed to drive 
the brailler is presented.
.K
blind communication, blind programming aid, braille,
braille computer communication, braille output, 
braille teletype, braille terminal, braille type head,
embosser, tactile computer communication, tactile 
teletype, tactile terminal
.C
4.41 6.35
.I 1741
.T
BRAD: The Brookhaven Raster Display
.W
A multiconsole computer display system has
been designed that provides very rich displays at 
low unit cost.  Each BRAD (Brookhaven Raster Display)
console can plot tens of thousands of points, or 
up to 4000 characters at 30 frames per second.  After
an initial display system investment of $50,000 
each display, with teletype, costs less than $3,000.
 The technique employed is that of programmatically 
generating a binary image of the desired display in a
computer.  The image is written on a rotating drum 
memory.  Independent read heads continuously display
the picture, which is generated by swept horizontal 
lines.  A standard TV monitor serves as the display device.
 The technique has two drawbacks.  A computer 
must compute any image to be displayed.  Also, the "pointing"
interaction is more difficult.  This is 
because the pointing function gives only the coordinates
of the point on the screen.  The inverse of 
the map generation process is required to calculate
the coordinates of the point on the screen.  The 
inverse of the map generation process is required to
calculate the coordinates at the selected point 
in the input space.
.K
computer display, computer graphics, computer raster
display, TV display console, digital TV display, 
swept raster computer display, swept raster TV computer
display, TV graphics terminal, multiconsole computer 
graphics, inexpensive graphic terminal
.C
2.0 4.49 6.35
.I 1742
.T
On the Design of Display Processors
.W
The flexibility and power needed in the data
channel for a computer display are considered. 
 To work efficiently, such a channel must have a sufficient number
of instructions that it is best understood 
as a small processor rather than a powerful channel.
 As it was found that successive improvements to 
the display processor design lie on a circular path, by
making improvements one can return to the original 
simple design plus one new general purpose computer for
each trip around.  The degree of physical separation 
between display and parent computer is a key factor in display processor design.
.K
display processor design, display system, computer
graphics, graphic terminal, displays, graphics, 
display generator, display channel, display programming,
graphical interaction, remote displays
.C
2.44 6.22 6.29 6.35
.I 1743
.T
Reliable Full-Duplex file Transmission over Half-Duplex Telephone Lines
.W
A field-proven scheme for achieving reliable
duplex transmission over a half-duplex communication 
line is presented, and to demonstrate the difficulty
of the problem, another similar scheme, which is 
only slightly unreliable, is also presented.  A flowchart
for the reliable scheme and some interesting 
examples are given.
.K
telephone communication, half duplex, transmission,
error correction, full duplex, telephone errors
.C
3.81 4.41 6.35
.I 1744
.T
Stable Numerical Methods for Obtaining the Chebyshev
Solution to an Overdetermined System of 
Equations
.W
An implementation of Stiefel's exchange algorithm
for determining a Chebyshev solution to an 
overdetermined system of linear equations is presented,
that uses Gaussian LU decomposition with row 
interchanges.  The implementation is computationally more
stable than those usually given in the literature. 
 A generalization of Stiefel's algorithm is developed which
permits the occasional exchange of two equations 
simultaneously.
.K
Chebyshev solutions, overdetermined linear
systems, linear equations,exchange algorithm
.C
5.13 5.14 5.41
.I 1745
.T
A Position Paper on Computing and Communications
.W
The effective operation of free enterprise in
creating the envisioned information service industry 
is dependent upon three accomplishments: (1) the restructuring
of our information processing industry 
so that a clear division of costs is made among computing,
communications, and the development of information 
services; (2) the wide use of multiaccess system concepts
so that information services may share in the 
use of computer installations and so that the cost of their
construction is reasonable; and (3) the development 
of public, message-switched communications services so
that adequate provisions are made for information 
security.
.K
information networks, information systems, computing
and free enterprise, computing economics, 
computer installation management, government regulation,
communications services, distributed data base, 
program leasing
.C
2.3 2.40 3.80 4.30
.I 1746
.T
Protection in an Information Processing Utility
.W
One of the critical problems in the design
of an information processing utility that permits 
flexible sharing of user information is privacy.
 One solution for this problem is discussed.
.K
protection, privacy, information processing utility,
time-sharing, multi-user, multiprogramming, 
multiprocessing, security, shared information, controlled
access, reliable operation, segmentation
.C
4.32 4.39
.I 1747
.T
Three Criteria for Designing Computing Systems to Facilitate Debugging
.W
The designer of a computing system should adopt
explicit criteria for accepting or rejecting 
proposed system features.  Three possible criteria of this
kind are input recordability, input specifiability, 
and asynchronous reproducibility of output.  These criteria
imply that a user can, if he desires, either 
know or control all the influences affecting the content
and extent of his computer's output.  To define 
the scope of the criteria, the notion of an abstract
machine of a programming language and the notion 
of a virtual computer are explained.  Examples of applications
of the criteria concern the reading of 
a time-of-day clock,  the synchronization of parallel
processes, protection in multiprogrammed systems, 
and the assignment of capability indexes.
.K
computer design, computer design criteria, computer
systems, computer systems design, input equipment, 
input equipment design, operating systems, operating
systems design, multiprogramming, multiprogrammed 
systems, multiprogrammed system design, virtual computers,
programming languages, programming language 
design, program semantics, programming language semantics,
determinism, reproducibility, repeatability, 
deterministic computers, protection, memory protection,
information security, information privacy, computing 
reliability, debugging, program debugging, program testing,
parallel processing, parallel programming, 
multiprocessing
.C
2.11 4.12 4.13 4.20 4.30 4.42 4.43 5.24 6.20 6.35
.I 1748
.T
A Scheduling Philosophy for Multiprocessing Systems
.W
A collection of basic ideas is presented, which
have been evolved by various workers over the 
past four years to provide a suitable framework for the
design and analysis of multiprocessing systems. 
 The notions of process and state vector are discussed,
and the nature of basic operations on processes 
is considered.  Some of the connections between processes
and protection are analyzed.  A very general 
approach to priority-oriented scheduling is described,
and its relationship to conventional interrupt 
systems is explained.  Some aspects of time-oriented
scheduling are considered. The implementation of 
the scheduling mechanism is analyzed in detail and the
feasibility of embodying it in hardware established. 
 Finally, several methods for interlocking the execution
of independent processes are presented and compared.
.K
time-sharing, multiprocessing, process, scheduling,
interlocks, protection, priority, interrupt 
systems
.C
4.31 4.32 6.21
.I 1749
.T
The Structure of the "THE"-Multiprogramming System
.W
A multiprogramming system is described in
which all activities are divided over a number of 
sequential processes.  These sequential processes are placed
at various hierarchical levels, in each 
of which one or more independent abstractions have been
implemented.  The hierarchical structure proved 
to be vital for the verification of the logical soundness
of the design and the correctness of its implementation.
.K
operating system, multiprogramming system, system
hierarchy, system structure, real-time debugging, 
program verification, synchronizing primitives, cooperating
sequential processes, system levels, input-output 
buffering, multiprogramming, processor sharing, multiprocessing
.C
4.30 4.32
.I 1750
.T
Considerations in the Design of a Multiple
Computer System with Extended Core Storage
.W
The use of large quantities of addressable
(but not executable) fast random access memory to 
heighten the multiprogramming performance of a multicomputer system
is discussed.  The general design 
of the hardware arrangement and the software components
and functions of such a system are based on a 
planned configuration of dual CDC 6600's that share one
million words of extended core storage.  In the 
generalization of such a design, special emphasis is
placed on estimating expected gains when compared 
with the traditional configuration of separate and independent
computers without extended core storage. 
 An observation is made on the use of conventional, slower
speed, random access storage devices in place 
of the faster memory.
.K
multiple computer systems, extended core storage,
multiprogrammed operating systems, multiprocessor 
operating systems, control data corporation 6600, operating system with ECS
.C
4.30 4.32
.I 1751
.T
The Working Set Model for Program Behavior
.W
Probably the most basic reason behind the absence
of a general treatment of resource allocation 
in modern computer systems is an adequate model for
program behavior.  In this paper a new model, the 
"working set model," is developed. The working set
of pages associated with a process, defined to be 
the collection of its most recently used pages, provides
knowledge vital to the dynamic management of 
paged memories.  "Process" and "working set" are shown to
be manifestations of the same ongoing computational 
activity; then "processor demand" and "memory demand"
are defined; and resource allocation is formulated 
as the problem of balancing demands against available equipment.
.K
general operating system concepts, multiprocessing,
multiprogramming, operating systems, program 
behavior, program models, resource allocation, scheduling, storage allocation
.C
4.30 4.32
.I 1752
.T
Resource Management for a Medium Scale Time-Sharing Operating system
.W
Task scheduling and resource balancing for
a medium size virtual memory paging machine are 
discussed in relation to a combined batch processing
and time-sharing environment.  A synopsis is given 
of the task scheduling and paging algorithms that were implemented,
and the results of comparative simulation 
are given by tracing the development of the algorithms
through six predecessor versions.  Throughout 
the discussion particular emphasis is placed on balancing
the system performance relative to the characteristics 
of all the system resources.  Simulation results relative
to alternate hardware characteristics and the 
effects of program mix and loading variations are also presented.
.K
time-sharing, operating systems, resource management,
task scheduling, paging, system simulation, 
memory management, virtual memories
.C
4.30 4.31 4.32
.I 1753
.T
Virtual Memory, Processes, and Sharing in MULTICS
.W
Some basic concepts involved in the design
of the MULTICS operating system are introduced. 
 MULTICS concepts of processes, address space, and virtual
memory are defined and the use of paging and 
segmentation is explained.  The means by which users
may share procedures and data is discussed and the 
mechanism by which symbolic references are dynamically
transformed into virtual machine addresses is 
described in detail.
.K
virtual memory, information sharing, shared procedures,
data sharing, dynamic linking, segmentation, 
paging, multiprogramming, storage management,
storage hierarchies, file maintenance
.C
3.73 4.32
.I 1754
.T
Dynamic Storage Allocation Systems
.W
In many recent computer system designs, hardware
facilities have been provided for easing the 
problems of storage allocation.  A method of characterizing
dynamic storage allocation systems-according 
to the functional capabilities provided and the underlying
techniques used-is presented.  The basic purpose 
of the paper is to provide a useful perspective from
which the utility of various hardware facilities 
may be assessed.  A brief survey of storage allocation
facilities in several representative computer 
systems is included as an appendix.
.K
segmentation, paging, multiprogramming, storage
allocation, storage management, virtual memories, 
storage fragmentation, storage hierarchies, addressing mechanisms
.C
4.30 6.20
.I 1755
.T
Proceedings of the ACM Symposium on Operating system Principles
.I 1756
.T
Hollerith Punched Card Code* (Proposed USA Standard)
.K
USA Standard, card code, punched card, punched card
code, hole-patterns, hole-patterns assignment, 
punched card systems
.C
1.4 2.0 2.2 2.43 2.9 3.15 3.24 3.50 3.57 3.7 3.80 3.81 3.82 4.11 4.12
.I 1757
.T
Data Code for Calendar Date for Machine-to-Machine
Data Interchange* (Proposed USA Standard)
.K
USA Standard, data code, calendar date, machine-to-machine
data interchange, recording calendar 
date, data group identifier
.C
2.0 2.11 2.19 2.3 2.40 2.43 2.49 3.50 3.52 3.53 3.55 3.56 3.59 3.70 3.71 3.73
3.74, 3.79, 3.81, 4.1, 4.9
.I 1758
.T
Symmetric Polynomials, (Algorithm 305 [C1])
.K
symmetric polynomials, symmetric sum, unitary
symmetric functions, Schur functions
.C
5.39
.I 1759
.T
Transportation Problem (Algorithm 293 [H])
.K
transportation problem, linear programming
.C
5.41
.I 1760
.T
Normal Curve Integral (Algorithm 304 [S15])
.K
normal curve integral, probability, special functions
.C
5.5 5.12
.I 1761
.T
Chi-Squared Integral (Algorithm 299 [S15])
.K
chi-squared integral, probability, special functions
.C
5.5 5.12
.I 1762
.T
Dilogarithm (Algorithm 327 [S22])
.K
dilogarithm function, special functions
.C
5.12
.I 1763
.T
Roots of Low-Order Polynomial Equations (Algorithm 326 [C2])
.K
root finders, polynomial equation roots, quadratic
equation roots, cubic equation roots, biquadratic 
equation roots, polynomial zeros
.C
5.15
.I 1764
.T
Panel Discussion on Computer Appreciation
.W
Session 19 of the ACM 20 th Anniversary Conference
on August 31, 1967, was entitled Education, 
Design Experiments, and Computer Appreciation.  Its second
half consisted of a panel discussion on computer 
appreciation, organized and chaired by Elliot I. Organick.
 The four panelists were Charles H. Davidson, 
Bernard A. Galler, Richard, W. Hamming, and Alan J. Perlis.
 After making prepared statements, the panelists 
were joined in discussion by Andries van Dam and Arthur
B.Kohn, who had presented papers in the first 
half.  This is a transcript of the panel discussion,
condensed by Dr. Organick and edited by him and 
the panelists.  Some remarks referred to papers by van
Dam and Kahn or to the discussion during the first 
half of the session.  Pertinent papers are included in the references.
.K
computer appreciation, students' liberal arts courses,
survey courses, beginning programming, course 
content, computer courses dropout rates, college versus
precollege, teaching and social responsibility
.C
1.1 1.51 1.52
.I 1765
.T
Expenditures, Sources of Funds, and Utilization
of Digital Computers for Research and Instruction 
in Higher Education: 1964-65 with Projections for 1968-69
.W
The Southern Regional Education Board published
a complete report on a survey it conducted 
to determine the funding and characterize the utilization
of computers used for research and instruction 
in institutions of higher education in the United States.
The sampling survey is described and the estimates 
for this total population are presented.
.K
computing centers, research, instruction, utilization,
expenditures, support, sources of funds, 
higher education, post secondary education, colleges, universities
.C
1.52 2.45
.I 1766
.T
Quasilinearization and the Estimation
of Differential Operators from Eigenvalues
.W
Given a linear ordinary differential operator
containing several unknown constants and a number 
of its eigenvalues, the values of the unknown constants
are estimated.  A precise formulation is provided, 
and an effective numerical procedure for solution is indicated.
  The results of some computational experiments 
are given.
.K
quasilinearization, eigenvalues, differential operators,
nonlinear boundary-value problems, inverse 
problems,differential equations, system identification
.C
3.15 3.17 5.17
.I 1767
.T
A General Purpose Graphic Language
.W
Interactive use of computers with graphic terminals
will permit many new problems to be solved 
using machines.  In order to handle a variety of applications,
it is expedient to develop a general purpose 
graphic language that is useful on a number of graphic
devices.  A system has been designed to produce 
such a language quickly and cheaply.  A model graphic
language which has been developed with the system 
is presented.
.K
graphic language, interactive, incremental compilation,
language design, metacompiler, syntax specified 
language
.C
4.12 4.22
.I 1768
.T
A Global Parser for Context-Free Phrase Structure Grammars
.W
An algorithm for analyzing any context-free phrase
structure grammar and for generating a program 
which can then parse any sentence in the language (or
indicate that the given sentence is invalid) is 
described. The parser is of the "top-to-bottom" type
and is recursive . A number of heuristic procedures 
whose purpose is to shorten the basic algorithm by quickly
ascertaining that certain substrings of the 
input sentence cannot correspond to the target nonterminal
symbols are included.  Both the generating 
algorithm and the parser have been implemented in RCA
SNOBOL and have been tested successfully on a number 
of artificial grammars and on a subset of ALGOL.  A
number of the routines for extracting data about 
a grammar, such as minimum lengths of N-derivable strings
and possible prefixes, are given and may be 
of interest apart from their application in this particular context.
.K
parser, syntax-directed compiler, context-free
grammars, syntactic analysis, translators
.C
3.42 4.12 5.24
.I 1769
.T
The Expanding World of Computers
.W
The onward sweep of automatic processing of
information is impeded by nine principal barriers: 
geography, cost, problem complexity, man-machine communication,
inadequate sensors, lack of understanding, 
distance, time, and size.  The main incentive for breaching
these barriers is the universal need for 
processing information, ever more urgent as the greater
part of human work activity changes from production 
to service.  Computer developments in hardware, programming,
time-sharing, education, data communication, 
and displays are judged by how effectively they remove these
barriers, and their barrier-smashing potentialities 
indicate continued rapid expansion.  Problem-oriented
languages are particularly effective over the entire 
front.  Online computers and time-sharing also rate high
by this measure.  Education and increased understanding 
are basic to all progress with the computer.  This complex
but powerful tool is the most important one 
available to governments and scientists to use in studying
the problems being created by the population 
explosion, and in analyzing possible solutions.
.K
barriers, philosophy, developments, computer-aided design,
problem-oriented languages, data communication, 
education, computer science, forecast, survey, introduction
.C
1.0 1.3 2.1 3.24 4.0 6.20 6.30
.I 1770
.T
Rules of Ethics in Information Processing
.W
The background and motivation for the adoption
by the ACM Council on November 11, 1966, of 
a set of Guidelines for Professional Conduct in Information
Processing are described.  A brief his tory 
is given of ethical codes in other professions.  Some
reasons for and against adoption of ethical rules 
are considered, and several sections of the ACM Guidelines
are analyzed.  The purpose is to inform about 
this important aspect of our profession, as
well as to stimulate thought and interest.
.K
ethics, professional conduct, code of ethics, ACM
guidelines, professionalism, professional societies, 
unethical conduct
.C
1.3 2.2
.I 1771
.T
CURRICULUM 68 -- Recommendations for Academic
Programs in Computer Science -- A Report of the 
ACM Curriculum Committee on Computer science
.W
This report contains recommendations on academic
programs in computer science which were developed 
by the ACM Curriculum Committee on Computer Science.
 A classification of the subject areas contained 
in computer science is presented and twenty-two courses
in these areas are described.  Prerequisites, 
catalog descriptions, detailed outlines, and annotated
bibliographies for these courses are included. 
 Specific recommendations which have evolved from the
Committee's 1965 Preliminary Recommendations are 
given for undergraduate programs.  Graduate programs in computer
science are discussed and some recommendations 
are presented for the development of master's degree programs.
 Ways of developing guidelines for doctoral 
programs are discussed, but no specific recommendations
are made. The importance of service courses, 
minors, and continuing education in computer science is
emphasized.  Attention is given to the organization, 
staff requirements, computer resources, and other facilities
needed to implement computer science educational 
programs.
.K
computer science courses, computer science curriculum,
computer science education, computer science 
academic programs, computer science graduate programs,
computer science undergraduate programs, computer 
science course bibliographies
.C
1.52
.I 1772
.T
USASCSOCR Dual Case Keyboard Arrangement* (Proposed USA Standard)
.I 1773
.T
General Purpose Alphanumeric Keyboard Arrangement
for Information Interchange* (Proposed USA 
Standard)
.I 1774
.T
Program Overlay Techniques
.W
The general features of program overlay systems
are described.  Three main types -- automatic, 
semiautomatic and nonautomatic -- are classified, and the
programming techniques are explained as a function 
of machine hardware and other system features.  The
implementation of semiautomatic overlay facility 
in a multiprogrammed system on the CDC 6600 is described
in detail, with special reference to real time 
applications.
.K
loaders, multiprogramming, overlay techniques,
storage allocation and segmentation
.C
4.39
.I 1775
.T
Adjustment of the Inverse of a Symmetric Matrix
when Two Symmetric Elements are Changed (Algorithm 
325 [F1])
.K
symmetric matrix, matrix inverse, matrix
perturbation, matrix modification
.C
5.14
.I 1776
.T
Maxflow (Algorithm 324 [H])
.K
network,liner programming, maximum flow
.C
5.41
.I 1777
.T
Generation of Permutations in Lexicographic Order (Algorithm 323 [G6])
.K
permutations, lexicographic order, lexicographic
generation, permutation generation
.C
5.39
.I 1778
.T
F-Distribution (Algorithm 322 [S14])
.K
Fisher's  F-distribution, Student's t-distribution
.C
5.5
.I 1779
.T
t-Test Probabilities (Algorithm [S14])
.K
T-test, Student's t-statistic, distribution function
.C
5.5
.I 1780
.T
Harmonic Analysis for Symmetrically
Distributed Data (Algorithm 320 [C6])
.K
harmonic analysis, cosine series, sine series, function
approximation, curve fitting, trigonometric 
series
.C
5.13
.I 1781
.T
Translator Writing systems
.W
A critical review of recent efforts to automate
the writing of translators of programming languages 
is presented.  The formal study of syntax and its application
to translator writing are discussed in 
Section II.  Various approaches to automating the post syntactic
(semantic) aspects of translator writing 
are discussed in Section III, and several related topics in Section IV.
.K
compiler, compiler-compiler, translator, translator
writing systems, metacompiler, syntax, semantics, 
syntax-directed, meta-assembler, macroprocessor,
parser, syntactic analysis, generator
.C
4.1 4.10 4.12 4.22 5.23
.I 1782
.T
A Numerical Integration Formula Useful in Fourier Analysis
.W
A numerical integration formula is presented which
uses unequal sampling intervals.  The intervals 
are equally spaced on a log scale.  Such a formulation
is useful in Fourier analysis to improve accuracy 
and ease of usage.  A complete set of formulas
for numerical Fourier analysis is given.
.K
numerical integration, Fourier analysis, integration
.C
5.16
.I 1783
.T
In-and-Out Conversions
.W
Byan in-and-out conversion we mean that a floating-point
number in one base is converted into 
a floating-point number in another base and then converted
back to a floating-point number in the original 
base.  For all combinations of rounding and truncation
conversions the question is considered of how 
many significant digits are needed in the intermediate
base to allow such in-and-out conversions to return 
the original number (when possible), or at least significant digit.
.K
floating-point numbers, significance,
base conversion, rounding, truncation
.C
3.15 5.11
.I 1784
.T
Practical Error Coefficients for Estimating
Quadrature Errors for Analytic Functions
.W
All published error coefficients for estimating
quadrature errors for analytic functions were 
computed on the assumption that the quadrature rule
was exact for polynomials up to a given degree.  
Since these rules use rounded values for the abscissas and
weights and since the true values of the integrals 
of some of the polynomials in question have an infinite
binary expression, the quadrature rule is not 
exact.  Hence these errors must be taken into consideration
in computing practical error coefficients.
.K
numerical integration, quadrature, truncation
error, theoretical error coefficients, practical 
error coefficients, integration analytical functions, roundoff error
.C
5.11 5.16
.I 1785
.T
Scatter Storage Techniques
.W
Scatter storage techniques as a method for
implementing the symbol tables of assemblers and 
compilers are reviewed and a number of ways of using
them more effectively are presented.  Many of the 
most useful variants of the techniques are documented.
.K
scatter storage, hash addressing, searching,
file searching, file addressing, storage layout
.C
3.73 3.74
.I 1786
.T
An Improved Hash Code for Scatter Storage
.W
Introduced is a hash coding method based on
fixed-point division rather than multiplication 
or logical operations.  This new method allows the
hash table to have almost any length.  Also a new 
method of handling collisions is discussed.  Known as
quadratic search, this method is faster than random 
search and free from the "clusters" that build up with a linear search.
.K
hash code, hash table, scatter storage, searching 
.C
3.74 4.11 4.12 4.9
.I 1787
.T
Use of Transition Matrices in Compiling
.W
An algorithms is described which constructs
from a suitable BNF grammar an efficient left-right 
recognizer for sentences of the corresponding language.
 The type of recognizer, used in a number of 
compilers, operates with a pushdown stack and with
a transition matrix.  Two examples illustrate how 
such recognizers may be used effectively for other
purposes besides the usual syntax checking.
.K
transition matrices, compilation, translation,
grammar, context-free language, formal language, 
parsing
.C
4.12 5.23
.I 1788
.T
Toward a General Processor for Programming Languages
.W
Many efforts have been made to develop a better
way of implementing a higher level programming 
language than by the construction of a whole new compiler,
but so far none has proved generally satisfactory. 
 In this paper, it is contended that a programming
language is best described functionally as a body 
of macro instructions, and that the macro call constitutes
a canonical form in terms of which a programming 
notation may be described.  A supporting discussion of the
logical and his torical role of the macro instruction 
is presented.  Also discussed are the conflict between
machine independence and object program efficiency, 
and the question of where the greatest difficulties
lie in compiler construction.
.K
programming language translator, programming language
processor, general translator, general processor, 
macro instruction processor; meta processor, meta language
translator, meta language processor, compiler-compiler, 
writing system, translator writing system
.C
4.10 4.11 4.12 4.20
.I 1789
.T
Logarithm of Gamma Function (Algorithm 291 [S14])
.I 1790
.T
Muller's Method for Finding roots of an
Arbitrary Function  (Algorithm 196 [C5])
.K
equation roots, function zeros 
.C
5.15
.I 1791
.T
Triangular Factors of Modified Matrices (Algorithm 319 [F1])
.K
matrix decomposition, matrix factors,
matrix modifier, matrix perturbation
.C
5.14
.I 1792
.T
Exploratory Experimental Studies Comparing
Online and Off line Programming Performance
.W
Two exploratory experiments were conducted at
System Development Corporation to compare debugging 
performance of programmers working under conditions
of on-line and off line access to a computer.  These 
are the first known studies that measure programmers'
performance under controlled conditions for standard 
tasks.  Statistically significant results of both experiments
indicated faster debugging under online 
conditions, but perhaps the most important practical finding
involves the striking individual differences 
in programmer performance.  Methodological problems encountered
in designing and conducting these experiments 
are described; limitations of the findings are pointed
out; hypotheses are presented to account for results; 
and suggestions are made for further research.
.K
online vs. off line performance, programmer/computer
communication, programming experimental-empirical 
studies, programming cost effectiveness, programming
performance, debugging effectiveness, time sharing 
vs. batch processing, factor analysis application,
programmer trainee performance, basic programming 
knowledge test, experienced programmer study, analysis
of variance, programmer individual differences
.C
2.40
.I 1793
.T
Presentation of Alphameric Characters for Information
Processing* (Proposed American National 
Standard)
.K
alphameric, handwritten input, encoding transcription,
numerals, upper case, hand printed
.C
2.43 4.41
.I 1794
.T
A Fast Random Number Generator for IBM 360
.K
pseudorandom number, modulus, period, float,
normalization, characteristic, chi-square test
.C
4.49 5.19 5.5
.I 1795
.T
Optimal Code for Serial and Parallel Computation
.K
code optimization, sequencing of operations,
detection of common subexpressions
.C
4.12
.I 1796
.T
Index by Subject to Algorithms, 1969
.K
This 1969 index is the first supplement to the
Index by Subject to Algorithms, 1960 1968 (Comm. 
ACM 11, 12 (Dec. 1968), 827 830).
.I 1797
.T
Solution of Linear programs in 0-1 (Algorithm 341 [H])
.K
linear programming, zero-one variables, partial enumeration
.C
5.41
.I 1798
.T
Coulomb Wave Functions (Algorithm 300 [S22])
.K
Coulomb wave functions, wave functions,
special functions, function evaluation
.C
5.12
.I 1799
.T
Elementary Functions by Continued Fractions (Algorithm 229 [B1])
.K
continued factions, Pade table
.C
5.19
.I 1800
.T
PSIF (Algorithm 147 [S14])
.K
gamma function, logarithmic derivative, factorial function, psi function
.C
5.12
.I 1801
.T
Analysis of Variance for Balanced Experiments (Algorithm 367 [G2])
.K
analysis of variance, analysis of covariance, regression
analysis, experimental design, balanced 
experiment, missing data, interblock estimate, intra block estimate
.C
5.14 5.5
.I 1802
.T
Regression Using Certain Direct Product Matrices (Algorithm 366 [G2])
.K
analysis of variance, analysis of covariance,
regression analysis, experimental design, matrix 
direct product, protection operator, orthogonal matrix
.C
5.14 5.5
.I 1803
.T
Complex Root Finding (Algorithm 365 [C5])
.K
downhill method, complex relaxation method, complex
iteration, complex equation, transcendental 
complex equation, algebraic complex equation
.C
5.15
.I 1804
.T
Coloring Polygonal Regions (Algorithm 364 [Z])
.K
coloring polygonal regions, coloring planar surfaces,
drawing pictures, shading enclosed regions
.C
4.9
.I 1805
.T
Productivity of Multiprogrammed Computers-Progress
in Developing an Analytic Prediction Method
.W
Multiprogramming as it is discussed here is
a mode of computer operation in which two or more
programs are concurrently in processor memory and proceeding,
each using the same central processor unit 
(CPU) and input-output (I/O) channels.  These programs
are actually proceeding intermittently and singly, 
according to eligibility (readiness to proceed) and priority.
 It is useful to be able to represent them 
as proceeding continuously and simultaneously, each
at an effective rate, which may be a fraction of 
that which it would enjoy in the absence of the other
programs.  The effective progress rate of each 
program is sensitive to many detailed characteristics
of itself and its co-residents and simulation has 
been the best available method of predicting it.  This
paper presents the results of progress in developing 
an alternative to simulation, a simulation-tested iterative
computation of these rates under certain 
situations.  The algorithm is sensitive to most of the
factors that control the phenomenon, including 
nonquantitative or topological features of the programs' structures.
.K
productivity, prediction, multiprogramming, simulation,
equipment  evaluation, hardware, evaluation, 
monitor, operating system, system software, supervisors,
performance, time sharing, time slicing 
.C
2.43 2.44 4.32
.I 1806
.T
On the Downhill Method
.W
The downhill method is a numerical method for
solving complex equations f(z) = 0 on which the 
only restriction is that the function w = f(z) must
be analytical.  An introduction to this method is 
given and a critical review of relating literature is
presented.  Although in theory the method always 
converges, it is shown that a fundamental dilemma exists
which may cause a breakdown in practical applications. 
 To avoid this difficulty and to improve the rate of
convergence toward a root, some modifications of 
the original method are proposed and a program (FORTRAN)
based on the modified method is given in Algorithm 
365.  Some numerical examples are included.
.K
downhill method, complex relaxation method, complex
iteration, complex equation, transcendental 
complex equation, algebraic complex equation
.C
5.15
.I 1807
.T
Optimization of Expressions in Fortran
.W
A method of optimizing the computation of
arithmetic and indexing expressions of a Fortran 
program is presented.  The method is based on a linear
analysis of the definition points of the variables 
and the branching and DO loop structure of the program.
 The objectives of the processing are (1) to 
eliminate redundant calculations when references are
made to common subexpression values, (2) to remove 
invariant calculations from DO loops, (3) to efficiently
compute subscripts containing DO iteration variables, 
and (4) to provide efficient index register usage.  The
method presented requires at least a three-pass 
compiler, the second of which is scanned backward.  It
has been used in the development of several FORTRAN 
compilers that have proved to produce excellent object
code without significantly reducing the compilation 
speed.
.K
FORTRAN, optimization, expressions, compilers,
compilation, subscripts, register allocation, DO 
loops, common subexpressions, invariant calculations
.C
4.12
.I 1808
.T
Advanced Cryptographic Techniques for Computers
.W
Cryptographic techniques which can be used to
maintain the confidentiality of information processed 
by computers are dealt with.  Special emphasis is paid
to the unique characteristics of computer files 
that make many cryptographic methods of little use.
 Relative security, costs, and preferred methods 
are included in this paper.
.K
cryptographic, cryptanalysis, ciphers secrecy systems,
security systems, confidential information 
processing
.C
1.3 2.12 2.19 3.73 3.81 4.41
.I 1809
.T
Numerical Analysis in a Ph.D. Computer Science Program
.W
Numerical Analysis is the study of methods and
procedures used to obtain "approximate solutions" 
to mathematical problems.  Much of the emphasis is on scientific
calculation.  The difficulties of education 
in such a broad area center around the question of background
and emphasis.  The Numerical Analysis program 
in the Computer Science Department should emphasize an
awareness of the problems of computer implementation 
and experimental procedures.  Nevertheless, there is a
need for a solid background in applied mathematics.
.K
Ph.D. program, numerical analysis, course separation, education
.C
1.52
.I 1810
.T
Is Automatic "Folding" of Programs Efficient Enough To Displace Manual?
.W
The operation of "folding" a program into
the available memory is discussed.  Measurements 
by Brown et al. and by Nelson on an automatic folding
mechanism of simple design, a demand paging unit 
built at the IBM Research Center by Belady, Nelson,
O'Neil, and others, permitting its quality to be 
compared with that of manual folding, are discussed,
and it is shown that given some care in use the 
unit performs satisfactorily under the conditions tested,
even though it is operating across a memory-to-storage 
interface with a very large speed difference.  The disadvantages
of prefolding, which is required when 
the folding is manual, are examined, and a number of
the important troubles which beset computing today 
are shown to arise from, or be aggravated by, this
source.  It is concluded that a folding mechanism 
will probably become a normal part of most computing systems.
.K
paging, automatic paging, demand paging, folding,
automatic folding, storage hierarchies, memory 
hierarchies, replacement algorithms, performance, measurement
.C
4.0 4.19 4.39 6.20 6.34
.I 1811
.T
A Case Study in Programming for Parallel-Processors
.W
An affirmative partial answer is provided to
the question of whether it is possible to program 
parallel-processor computing systems to efficiently decrease
execution time for useful problems.  Parallel-processor 
systems are multiprocessor systems in which several of
the processors can simultaneously execute separate 
tasks of a single job, thus cooperating to decrease
the solution time of a computational problem. The 
processors have independent instruction counters, meaning
that each processor executes its own task program 
relatively independently of the other processors.  Communication
between cooperating processors is by 
means of data in storage shared by all processors.  A
program for the determination of the distribution 
of current in an electrical network was written for a
parallel-processor computing system, and execution 
of this program was simulated.  The data gathered from
simulation runs demonstrate the efficient solution 
of this problem, typical of a large class of important
problems.  It is shown that, with proper programming, 
solution time when N processors are applied approaches
1/N times the solution time for a single processor, 
while improper programming can actually lead to an increase
of solution time with the number of processors. 
 Stability of the method of solution was also investigated.
.K
parallel-processor, parallelism, parallel programming,
multiprocessor, multiprogramming, tasking, 
storage interference, electrical network, simulation,
relaxation, Jacobi, Gauss-Seidel, convergence
.C
3.24 4.9 5.14 5.17 6.21
.I 1812
.T
More on Fortran Random Number Generators
.K
random number generation, Monte Carlo, simulation
.C
5.5
.I 1813
.T
Generation of Permutations in Pseudo-Lexicographic
Order (Algorithm 308 [G6])
.K
permutations, lexicographic order, lexicographic
generation, permutation generation
.C
5.39
.I 1814
.T
Direct Search (Algorithm 178 [E4])
.K
function minimization, search, direct search
.C
5.19
.I 1815
.T
Direct Search (Algorithm 178 [E4])
.K
function minimization, search direct search
.C
5.19
.I 1816
.T
Generalized Least Squares Fit By Orthogonal
Polynomials (Algorithm 296 [E2])
.K
least squares, curve fitting, orthogonal polynomials,
three-term recurrence, polynomial regression, 
approximation, Forsythe's method
.C
5.13 5.5
.I 1817
.T
Computation of Fourier Coefficients (Algorithm 255 [C6])
.K
numerical integration, Fourier coefficients, Filon's method
.C
5.16
.I 1818
.T
Associated Legendre Functions of the First Kind
for Real or Imaginary Arguments (Algorithm 47 
[S16])
.K
Legendre function, associated Legendre
function, real or imaginary arguments
.C
5.12
.I 1819
.T
Complex Error Function (Algorithm 363 [S15])
.K
error function for complex argument, Voigt function,
Laplace continued fraction, Gauss-Hermite 
quadrature, recursive computation
.C
5.12
.I 1820
.T
Generation of Random Permutations (Algorithm 362 [G6])
.K
permutation, random permutation, transposition
.C
5.5
.I 1821
.T
Permanent Function of a Square Matrix I and II (Algorithm 361 [G6])
.K
matrix, permanent, determinant
.C
5.30
.I 1822
.T
Shortest-Path Forest with Topological Ordering (Algorithm [H])
.K
shortest path, tree, network, directed graph
.C
5.32 5.42
.I 1823
.T
Factorial Analysis of Variance (Algorithm [G1])
.K
factorial variance analysis, variance, statistical analysis
.C
5.5
.I 1824
.T
APAREL-A Parse-Request Language
.W
APAREL is described: this language is an extension
to an algorithmic language (PL/I) that provides 
the pattern-matching capabilities normally found only
in special purpose languages such as SNOBOL4 and 
TMG.  This capability is provided through parse-requests
stated in a BNF-like format.  These parse-requests 
form their own programming language with special sequencing
rules.  Upon successfully completing a parse-request, 
an associated piece of PL/I code is executed.  This
code has available for use, as normal PL/I strings 
the various pieces (at all levels) of the parse.  It
also has available as normal PL/I variables, the
information concerning which of the various alternatives
were successful.  Convenient facilities for 
multiple input-output streams, the initiation of sequences
of parse-requests as a subroutine, and parse-time 
semantic checks are also included.  APAREL has proven convenient
 in building a powerful SYNTAX and FUNCTION 
macro system, an algebraic language preprocessor debugging
system, an on-line command parser, a translator 
for Dataless Programming, and as a general string manipulator.
.K
text processing, string processing, symbol manipulation,
PL/I, BNF, syntax, parser, translator, 
pattern matching
.C
4.12 4.13 4.20 4.22 4.29
.I 1825
.T
A Practical Method for Constructing LR(k) Processors
.W
A practical method for constructing LR(k) processors
is developed.  These processors are capable 
of recognizing and parsing an input during a single
no-backup scan in a number of steps equal to the 
length of the input plus the number of steps in its
derivation.  The technique presented here is based 
on the original method described by Knuth, but decreases
both the effort required to construct the processor 
and the size of the processor produced.  This procedure
involves partitioning the given grammar into 
a number of smaller parts.  If an LR(k) processor can be
constructed for each part (using Knuth's algorithm) 
and if certain conditions relating these individual
processors are satisfied, then an LR(k) processor 
for the entire grammar can be constructed for them.
 Using this procedure, an LR(1) parser for ALGOL 
has been obtained.
.K
LR(k) grammar, syntactic analysis, parser, deterministic
language, syntax-directed compiler, language
processor, context-free language ALGOL
.C
4.12 5.2 5.23
.I 1826
.T
A LISP Garbage-Collector for Virtual-Memory Computer Systems
.W
In this paper a garbage-collection algorithm
for list-processing systems which operate within 
very large virtual memories is described.  The object
of the algorithm is more the compaction of active 
storage than the discovery of free storage.  Because free
storage is never really exhausted, the decision 
to garbage collect is not easily made; therefore,
various criteria of this decision are discussed.
.K
garbage-collector, virtual memory, list-processing, storage-allocation
.C
4.19 4.49
.I 1827
.T
Performance Monitoring in a Time-Sharing System
.W
A software measurement facility which is part of
a general purpose time-sharing system is described. 
 The Date Collection Facility (DCF) has been implemented
in the Michigan Terminal System (MTS) for the 
System/360 model 67.  It exists for the purpose of monitoring
operating system and user program behavior 
and performance.  The overall structure of MTS is outlined
in order to explain the implementation of 
the DCF.  Events in the system are identified and recorded
from within the supervisor, and dumped to 
magnetic tape by an auxiliary program for off-line processing.
 Events in user programs which are unrelated 
to system actions are recorded with a supervisor call.
 The time of occurrence of each event is accurately 
recorded, and data items are further identified by job and
type.  The overhead associated with data collection 
and its interference with normal jobs is carefully analyzed,
and both are shown to be minimal.  Several 
examples are given of information obtained with the
facility and of applications in which it has been 
useful.  Some general guidelines are offered for
the construction of future monitoring programs.
.K
performance monitoring, performance measurement,
program behavior, performance data, multiprogramming 
performance, software measurement, time-sharing performance,
system evaluation, software monitor, software 
instrumentation
.C
4.31 4.32 4.39 4.42 4.43
.I 1828
.T
Synchronization in a Parallel-Accessed Data Base
.W
The following problem is considered:  Given
a data base which can be manipulated simultaneously 
by more than one process, what are the rules for synchronization
which will maximize the amount of parallel 
activity allowed.  It is assumed that the data base
can be represented as a graph.  An example of such 
a data base is a hierarchy of directories for an on-line
file system.  Methods for synchronization of 
processes are examined; their validity is
discussed and their performance compared.
.K
parallel accessing, parallel search, file search,
data base, synchronization, locking, deadlock
.C
3.73 3.74 4.32
.I 1829
.T
An Interactive Graphical Display Monitor in
a Batch-Processing Environment with Remote Entry
.W
A graphic monitor program is described.  It
was developed at Carnegie-Mellon University for 
the CDC G21 computer, which is a general purpose, batch-processing
system with remote entry.  The existing 
G21 system and the graphics hardware are described. 
The graphic monitor is a resident auxiliary monitor 
which provides comprehensive managerial capability
over the graphical system in response to commands 
from the human user.  It also will respond to commands
from a user program through a similar interface, 
where routine calls take the place of manual actions.  Thus
the human and program can interact on a symmetrical 
and equal basis through the medium of the graphic monitor.
 The choice made in designing the graphic 
monitor, given the constraints of the existing hardware
and computer system, are discussed.  The structure 
of the monitor program and the human and program interfaces
are described.  There is also a transient 
swapping version with a small resident part,
and provision for swapped used submonitors.
.K
graphic monitor, man/machine interaction, graphic
interface, graphic in batch environment, design 
of graphical system
.C
4.30 4.31 4.39 4.41
.I 1830
.T
Retrieval Times for a Packed Direct Access Inverted File
.K
information retrieval, direct access memory, data base, inverted list
.C
3.70 4.41
.I 1831
.T
A Comment on Optimal Tree Structures
.K
information retrieval, file searching, tree structures, double chaining
.C
3.70 3.73 3.74
.I 1832
.T
Minimax Logarithmic Error
.K
logarithmic error, transformed rational approximation, square root
.C
5.10
.I 1833
.T
An Ambiguity in the Description of ALGOL 60
.K
Ising problem, zero-one sequences
.C
5.39
.I 1834
.T
An Axiomatic Basis for Computer Programming
.W
In this paper an attempt is made to explore
the logical foundations of computer programming 
by use of techniques which were first applied in the
study of geometry and have later been extended to 
other branches of mathematics.  This involves the elucidation
of sets of axioms and rules of inference 
which can be used in proofs of the properties of computer
programs.  Examples are given of such axioms 
and rules, and a formal proof of a simple theorem is
displayed.  Finally, it is argued that important 
advantages, both theoretical and practical, may
follow from a pursuance of these topics.
.K
axiomatic method, theory of programming, proofs of
programs, formal language definition, programming 
language design, machine-independent programming, program documentation
.C
4.0 4.21 4.22 5.20 5.21 5.23 5.24
.I 1835
.T
The IITRAN Programming Language
.W
The IITRAN language, developed to be used
by students, and its important important features 
are described. IITRAN is a procedure-oriented language
with a one-level block structure and a variety 
of data types.  Several novel and powerful features
are included.  A discussion of design principles 
to be followed in a student language is given.
.K
languages programming languages, student programming
systems, language design, high school programs, 
college courses
.C
1.51 1.52 4.12 4.22
.I 1836
.T
A New Method for Determining Linear Precedence
Functions for Precedence Grammars
.W
The precedence relations of a precedence grammar can
be precisely described by a two-dimensional 
precedence matrix.  Often the information in the matrix
can be represented more concisely by a pair of 
vectors, called linear precedence functions.  A new algorithm
is presented for obtaining the linear precedence
functions when given the precedence matrix; this algorithm
is shown to possess several computational 
advantages.
.K
Boolean matrices, syntax, precedence grammar context-free
parsing, transition matrix, precedence 
functions 
.C
4.12
.I 1837
.T
An Algol Convolution Procedure Based on the
Fast Fourier Transform (Algorithm 345 [C6])
.K
fast Fourier transform, complex Fourier transform,
multivariate Fourier transform, Fourier series, 
harmonic analysis, spectral analysis, orthogonal polynomials,
orthogonal transformation, convolution, 
auto covariance, autocorrelation, cross-correlation,
digital filtering, permutation
.C
3.15 3.83 5.12 5.14
.I 1838
.T
Normal Curve Integral (Algorithm 304 [S15])
.K
normal curve integral, probability, special functions
.C
5.5 5.12
.I 1839
.T
Singular Value Decomposition of a Complex
Matrix (Algorithm 358 [F1, 4,5])
.K
singular values, matrix decomposition,
least squares solution, pseudoinverse
.C
5.14
.I 1840
.T
An Efficient Prime Number Generator (Algorithm 357 [A1])
.K
prime numbers, factoring, number theory
.C
3.15 5.30
.I 1841
.T
A Prime Number Generator Using The
Treesort Principle (Algorithm 356 [A1])
.K
prime numbers, number theory, sorting
.C
3.15 5.30 5.31
.I 1842
.T
An Algorithm for Generating Ising Configurations (Algorithm 355 [Z])
.K
Ising problem, zero-one sequences
.C
5.39
.I 1843
.T
The Choice of Base
.W
A digital computer is considered, whose memory
words are composed on N r-state devices plus 
two sign bits (two state devices).  The choice of base
B for the internal representation of floating-point 
numbers on such a computer is discussed.  It is
shown that in a certain sense B= r is best.
.K
floating-point, accuracy, base choice, number representations
.C
5.11 6.32
.I 1844
.T
A Modular Computer Sharing System
.W
An alternative approach to the design and organization
of a general purpose interactive multiterminal 
computing system is presented.  The system organization described
is a conceptually simple arrangement 
of a bank of interchangeable computers, each of which
is a memory/processor pair, that are assigned to 
process terminal jobs as they arrive.  One of the computers
serves as the master or control computer 
and supervises the collection and distribution of messages
from and to the remote terminals.  In the 
simplest form there is a disk drive for each connected
terminal.  A crosspoint switching network allows 
any such disk drive to be connected to any computer.
 Thus, while each active terminal user "occupies" 
a dedicated disk drive, he may share the computer with
many other terminal users in a simple manner. 
 The ratio of users to computers is dependent on both
the size and power of the machines used and the 
computation requirements of the particular mix of users.
 This system organization is inherently a simpler 
and therefore more reliable approach to time-sharing computers
and has the potential of a highly available 
system at relatively low cost.  Economic configurations
are possible for a range of systems sizes that 
span at least one order of magnitude.  Finally, problem
programs developed by remote terminal users can 
be run on a dedicated batch system if compatible computers are used.
.K
multiple terminal systems, terminal oriented systems,
multiple processor systems, high availability, 
conversational systems, general purpose time-sharing systems,
real-time response system, modular constructed 
systems, modular computer-sharing systems, graphics,
file switch, intercomputer communications, control 
computer, problem computer, roll-in, roll-out
.C
6.21
.I 1845
.T
Loader Standardization for Overlay Programs
.W
The overlay capability is described for four
of the third generation computer systems: CDC-6000, 
GE-635, IBM-360, and UNIVAC-1108.  A critique of the
first three systems is based on actual experience 
with a large overlaid trajectory simulation program;
a short history and description of this program 
is presented.  A standardization of minimum capabilities
for loaders is recommended so that programs 
which must operate under more than one computer system
may be easily converted and maintained.  A proposal 
that overlay software incorporates a memory occupation
specification concept instead of the conditional 
tree structure is delineated.  This concept provides
more efficient and cost-effective utilization of 
the memory as well as increased flexibility in program structure.
.K
loader, overlay, partition, region, segmentation,
linkage, linkage editor, standardization, memory 
utilization, memory occupation, tree structure,
CDC-6000, GE-635, IBM-360, UNIVAC-1108
.C
4.10 4.12 4.19 4.40
.I 1846
.T
On Simulating Networks of Parallel Processes
in Which Simultaneous Events May Occur
.W
Some of the problems of simulating discrete
event systems, particularly computer systems, on 
a conventional digital computer are dealt with.  The
systems are assumed to be described as a network 
of interconnected sequential processes.  Briefly reviewed
are the common techniques used to handle such 
simulations when simultaneous events do not occur, can
be ignored, or can be handled by simple priority 
rules.  Following this, the problem of dealing with simultaneous
events in separate processes is introduced. 
 An abstraction of this problem is developed which admits
solution for a majority of commonly encountered
problems.  The technique will either find a method of
simulating the parallel events or report that none 
can be found.  In some of the latter cases it is shown
to be possible to find a solution by extending 
the information available to the solution technique, but
in many cases the technique becomes computationally 
unfeasible when the additional information is provided.
.K
simulation, parallel processes, simultaneous events,
picture processing, computer system simulation
.C
3.19 3.24 4.24 5.9 6.9
.I 1847
.T
An Algorithm for Finding a Fundamental Set of Cycles of a Graph
.W
A fast method is presented for finding a fundamental
set of cycles for an undirected finite 
graph.  A spanning tree is grown and the vertices examined
in turn, unexamined vertices being stored 
in a pushdown list to await examination.  One stage
in the process is to take the top element v of the 
pushdown list and examine it, i.e. inspect all those
edges (v,z) of the graph for which z has not yet 
been examined.  If z is already in the tree, a fundamental
cycle is added; if not, the edge (v,z) is 
placed in the tree.  There is exactly one such stage
for each of the n vertices of the graph.  For large 
n, the store required in creases as n^2 and the time as
n^g where g depends on the type of graph involved. 
 g is bounded below by 2 and above by 3, and it is shown
that both bounds are attained.  In terms of 
storage our algorithm is similar to that of Gotlieb and
Corneil and superior to that of Welch; in terms 
of speed it is similar to that of Welch and superior
to that of Gotlieb and Corneil.  Testsshow our 
algorithm to be remarkably efficient (g=2) on random graphs.
.K
fundamental cycle set, graph, algorithm, cycle, spanning tree
.C
5.32
.I 1848
.T
The Damped Taylor's Series Method for Minimizing
a Sum of Squares and for Solving Systems of 
Nonlinear Equations (Algorithm 315 [E4, C5])
.K
solution of equations, least squares approximation, Newton's method
.C
5.13 5.14 5.15
.I 1849
.T
Function Minimization (Algorithm 251 [E4])
.K
function minimization
.C
5.19
.I 1850
.T
Generation of Permutations in Lexicographic Order (Algorithm 323 [G6])
.K
permutations, direct lexicographic order, reverse
lexicographic order, lexicographic generation
.C
5.39
.I 1851
.T
Generator of Spanning Trees (Algorithms 354 [H])
.K
spanning trees, trees, graphs
.C
5.32
.I 1852
.T
A Base for a Mobile Programming System
.W
An algorithm for a macro processor which has
been used as the base of an implementation, by 
bootstrapping, of processors for programming languages is
described.  This algorithm can be easily implemented 
on contemporary computing machines.  Experience with
programming languages whose implementation is based
on this algorithm indicates that such a language can
be transferred to a new machine in less than one 
man-week without using the old machine.
.K
bootstrapping, macro processing, machine independence,
programming languages, implementation techniques
.C
4.12 4.22
.I 1853
.T
Compact List Representation: Definition,
Garbage Collection, and System Implementation
.W
Compact lists are stored sequentially in memory,
rather than chained with pointers.  Since 
this is not always convenient, the Swym system permits
a list to be chained, compact, or any combination 
of the two.  A description is given of that list representation
and the operators implemented (most are 
similar to those of LISP 1.5).  The system garbage collector
attempts to make all lists compact; it relocates 
and rearranges all of list storage using temporary storage.
 This unique list-compacting garbage collection 
algorithm is presented in detail.  Several classes of the
macros used to implement the system are described. 
 Finally, consideration is given to those design factors
essential to the success of a plex processing 
system implementation.
.K
data structure, data representation, list structure,
list representation, list, compact list, garbage 
collection, relocation, storage reclamation, macro,
primitive list operations, plex processing, plex, 
pointer, list processing system, LISP, free storage
.C
3.49 4.20 4.22 4.49 4.9
.I 1854
.T
On Multiprogramming, Machine Coding, and Computer Organization
.W
The author feels that the interrupt feature
which is available in most modern computers is 
a potent source of programming pitfalls and errors, and
that it therefore may heavily contribute to the 
unreliability of programs making use of it.  A programming
scheme is presented which avoids the concept 
of the interrupt and permits the specification of concurrent
(or pseudoconcurrent) activities in a supposedly 
more perspicuous manner.  It is intended to serve as
a basis for the construction of operating systems, 
which are prime examples of programs with concurrent
activities.  The scheme includes a set of basic 
instructions for the generation, termination, and synchronization
of parallel processes.  A set of routines 
representing these instructions and thereby simulating a
hypothetical machine organization has been implemented 
and test on the IBM System/360.  Two programs using these
instructions, written in PL360, are presented. 
.K
multiprogramming, parallelism, interrupt, input-output,
computer organization, file handling, PL360
.C
4.21 4.22 4.32 4.41 6.21
.I 1855
.T
A Program for the Syntactic Analysis of English Sentences
.W
A program is described which produces syntactic
analyses of English sentences with respect 
to a transformational grammar.  The main features of the
analyzer are that it uses only a limited dictionary 
of English words and that it pursues all analysis paths
simultaneously while processing the sentence 
from left to right.  The form of representation used
for the dictionary and the grammar is indicated 
and an outline account is given of the analysis procedure.
 Techniques for keeping the size of the analysis 
record within reasonable limits and for avoiding the need
for dynamic application of certain transformational 
rules are described.   A number of examples of output
produced by the program are given.  The output 
includes timing information.
.K
syntactic analysis, language processing, language
analysis, parsing, analysis procedure, recognition 
procedure, English sentences, linguistics, psycholinguistics,
transformational grammar, limited dictionary, 
predictive analysis
.C
3.42 3.36
.I 1856
.T
The Teachable Language Comprehender: 
A Simulation Program and Theory of Language
.W
The Teachable Language Comprehender (TLC) is
a program designed to be capable of being taught 
to "comprehend" English text.  When text which the program
has not seen before is input to it, it comprehends 
that text by correctly relating each (explicit or implicit)
assertion of the new text to a large memory. 
 This memory is a "semantic network" representing factual
assertions about the world.  The program also 
creates copies of the parts of its memory which have
been found to relate to the new text, adapting and 
combining these copies to represent the meaning of the
new text.  By this means, the meaning of all text 
the program successfully comprehends is encoded into
the same format as that of the memory.  In this 
form it can be added into the memory.  Both factual
assertions for the memory and the capabilities for 
correctly relating text to the memory's prior content
are to be taught to the program as they are needed. 
 TLC presently contains a relatively small number of
examples of such assertions and capabilities, but 
within the system, notations for expressing either of these
are provided.  Thus the program now corresponds 
to a general process for comprehending language, and
it provides a methodology for adding the additional 
information this process requires to actually comprehend
text of any particular kind.  The memory structure 
and comprehension process of TLC allow new factual assertions
and capabilities for relating text to such 
stored assertions to generalize automatically.  That
is, once such an assertion or capability is put 
into the system, it becomes available to help comprehend
a great many other sentences in the future. 
 Thus the addition of a single factual assertion or
linguistic capability will often provide a large 
increment in TLC's effective knowledge of the world and
in its overall ability to comprehend text.  The 
program's strategy is presented as a general theory of language comprehension.
.K
natural language processing, natural language comprehension,
teachable computer program, psychological 
simulation, human memory simulation, computer
linguistics, linguistic performance theory
.C
3.36 3.42 3.62 3.65 3.74
.I 1857
.T
Filon Quadrature (Algorithm [D1])
.K
quadrature, Filon quadrature, integration, Filon
integration, Fourier coefficients, Fourier series
.C
5.16
.I 1858
.T
An Algorithm for Filon Quadrature
.W
An algorithm for Filon quadrature is described.
 Considerable attention has been devoted to 
an analysis of the round-off and truncation errors.
 The algorithm includes an automatic error control 
feature.
.K
quadrature, Filon quadrature, integration, Filon
integration, Fourier coefficients, Fourier series
.C
5.16
.I 1859
.T
Error Bounds for Periodic Quintic Splines
.W
Explicit error bounds for periodic quintic spline
interpolation are developed.  The first (third) 
derivative of the periodic spline is shown to be a sixth
(fourth) order approximation at the mesh points 
to the first (third) derivative of the function being interpolated.
.K
spline, interpolation, error bounds
.C
5.1 5.13
.I 1860
.T
An Algol-Based Associative Language
.W
A high level programming language for large,
complex associative structures has been designed 
and implemented.  The underlying data structure has
been implemented using a hash-coding technique.  
The discussion includes a comparison with other work
and examples of applications of the language.
.K
ALGOL, associative, programming language, data structure
.C
4.22
.I 1861
.T
The MAD Definition Facility
.W
One of the first definition facilities for
higher level languages is described.  Users of the 
language can define new operators and/or data types
into the MAD language, so that their use appears 
as if they were predefined.  Information is given on
how one writes definitions, as well as on much of 
the motivation behind the form in which definitions are
written. Some conclusions are drawn about future 
definitional facilities.
.K
MAD, definitions, operators, macros, higher level language
.C
4.12 4.22
.I 1862
.T
Computing Capabilities at Argentine and Chilean Universities
.W
The author reports on a trip to universities in
Argentina and Chile during November 1968, describing 
university conditions and computing activities.  As elsewhere,
these universities are experiencing student 
discontent with the status quo and the solutions they
are attempting contrast: Argentina is excluding 
students from participating in university government;
Chile is allowing such participation.  University 
computing service and academic activities are limited.
 The number of computers is small and so is the 
capacity, none larger than an IBM 360/40; with some
exception, computing science academic programs are 
rare. This situation is by no means attributable to
those responsible for computing developments, who 
strive for excellence; rather the "system" is hard to
over-come.  Universities, especially those with 
strong European traditions, adapt slowly to new academic
resources and disciplines; superimposed are 
the severe technological and economic constraints of the
developing nation.  Consequently, in the absence 
of conscious government emphasis on strengthening computing
capabilities, future progress may be retarded.
.K
university education, computing science academic
programs, university computing centers, surveys 
of computing centers, university computing capabilities, university-student
relationship, Argentine universities, 
Chilean universities, South American universities, developing nations
.C
1.52 2.0 2.45
.I 1863
.T
Minit Algorithm for Linear Programming (Algorithm 333 [H])
.K
linear programming, dual simplex method, primal problem, dual problem
.C
5.41
.I 1864
.T
Generation of Hilbert Derived Test Matrix (Algorithm 274 [F1])
.K
test matrix, Hilbert matrix
.C
5.14
.I 1865
.T
Algol 60 Reference Language Editor (Algorithm 268 [R2])
.K
symbol manipulation
.C
4.49
.I 1866
.T
Characteristic Values and Associated Solutions
of Mathieu's Differential Equation (Algorithm 
352 [S22])
.K
Mathieu's differential equation, Mathieu function,
characteristic value, periodic solution, radial 
solution
.C
5.12
.I 1867
.T
On the Expected Lengths of Sequences Generated
in Sorting by Replacement Selecting
.W
In the replacement-selecting technique of sorting,
one is interested in the ratio L(j) of the 
expected length of the j-th sequence generated by the
technique to the number of memory cells used.  
Using complex-variable theory, it is shown that L(j)
-> 2 and that, asymptotically, the average interval 
between sign changes of L(j)-2 is 2.6662.
.K
replacement selecting, sorting, sequence lengths,
asymptotic expected length, recursion relation, 
generating function, meromorphic function
.C
3.74 5.31
.I 1868
.T
On Obtaining Correct Input:A New Approach
.W
Most information put into machine readable
form, whether from scientific or business origins, 
is still keypunched.  This paper is addressed toward
the difficulty of obtaining correctly keypunched 
and key verified data and an alternative method is suggested
in which the computer itself is used to rule 
out the possibility of errors in input.  This technique
is explained and illustrated by reference to 
a working program which involves essentially two phases:
in the first phase errors are detected by the 
machine, and subsequently, in the second phase, they are corrected by it.
.K
correct data, correct input, data correction,
keypunch, key verifier, verifier
.C
2.40 2.42 2.43 3.10 3.20 3.50 4.41
.I 1869
.T
Block Structures, Indirect Addressing, and Garbage Collection
.W
Programming languages have included explicit
or implicit block structures to provide a naming 
convenience for the programmer.  However, when indirect
addressing is used, as in SNOBOL, naming constraints 
may be introduced.  Two modifications to SNOBOL are described,
resulting in two desirable consequences: 
(1) naming constraints disappear even when there is
indirect addressing within function definitions; 
and (2) there is a significant saving in the number of
calls to the garbage collector, because some garbage 
is collected, at little expense, each time a function
returns to its calling program.  These modifications 
have been implemented as an extension to a SNOBOL dialect.
.K
block structures, indirect addressing,
garbage collection, local names, SNOBOL
.C
4.22
.I 1870
.T
Some Techniques for Using Pseudorandom Numbers in Computer Simulation
.W
An algorithm is described by which uniform pseudorandom
integers may be used to construct binary 
"numbers" in which the probability that each bit in the
word is a 1-bit and can assume any desired parameter 
value.  Techniques for making use of such "numbers"
in simulation programming are described.
.K
random numbers,  simulation, Boolean algebra, bit manipulation
.C
5.19 5.39
.I 1871
.T
Automatic Contour Map
.W
Some methods for contour mapping by means of
a digital plotter are discussed, and a new method 
is presented that is simple enough to be implemented by
programs with a rather small number of instructions 
(about 120 FORTRAN IV instructions are required).  Comparisons
with some methods proposed by other authors 
are also performed,  A FORTRAN IV program implementing
the proposed method is available at the Istituto 
di Elettrotecnica ed Elettronica, Politencnico di Milano.
.K
contour map, level lines, digital plotting, function scanning
.C
3.10 3.13 3.14 3.16 3.20 3.24
.I 1872
.T
Chebyshev Interpolation and Quadrature
Formulas of Very High Degree (Errata)
.I 1873
.T
Accelerating LP Algorithms
.W
It is shown how a novel method for computing
(related) inner products can accelerate the pricing 
phase of LP algorithms.  Other LP applications are indicated.
.K
linear programming, revised simplex
method, multiple pricing, inner product
.C
5.19 5.41
.I 1874
.T
Generating Pseudorandom Numbers on a Two's
Complement Machine such as the IBM 360
.W
The familiar multiplicative congruential generator
is examined in the context of the type of 
two's complement arithmetic used in the IBM 360 series.
 Different sequences of residues are considered 
and relationships established among them.  It is shown
that a sequence of positive and negative residues 
may be produced more simply and economically than with
the conventional approach and yet have twice the 
period of the latter without loss of desirable statistical
properties.  Another easily generated sequence 
involving absolute values is also shown to have twice
the period but with less attractive statistical 
properties.  The statistical properties of these sequences
are given and related to previously established 
criteria.
.K
random number, uniform distribution, pseudo-random
number, random number generator, multiplicative 
congruential generator, power residue, two's
complement arithmetic, IBM 360 arithmetic
.C
3.15 5.5 6.32
.I 1875
.T
Polynomial and Spline Approximation by Quadratic Programming
.W
The problem of approximation to a given function,
or of fitting a given set of data, where 
the approximating function is required to have certain
of its derivations of specified sign over the 
whole range of approximation, is studied.  Two approaches
are presented, in each of which quadratic programming 
is used to provide both the constraints on the derivatives
and the selection of the function which yields 
the best fit.  The first is a modified Bernstein polynomial
scheme, and the second is a spline fit.
.K
constant sign derivatives, Bernstein polynomials,
linear concavity constraints, quadratic programming 
splines
.C
5.13 5.41
.I 1876
.T
Generation of Test Matrices Having Certain
Sign Patterns and Prescribed Positive Spectra
.W
A class of orthogonal transformations is presented
whose members transform a given positive 
diagonal matrix into a matrix having one of four special sign patterns.
.K
test matrices, positive matrices, sign patterns,
orthogonal transformations, positive eigenvalues
.C
5.1 5.14
.I 1877
.T
Prevention of System Deadlocks
.W
A well-known problem in the design of operating
systems is the selection of a resource allocation 
policy that will prevent deadlock.  Deadlock is the
situation in which resources have been allocated 
to various tasks in such a way that none of the tasks
can continue.  The various published solutions 
have been somewhat restrictive: either they do not handle
the problem in sufficient generality or they 
suggest policies which will on occasion refuse a request
which could have been safely granted.  Algorithms 
are presented which examine a request in the light of
the current allocation of resources and determine 
whether or not the granting of the request will introduce
the possibility of a deadlock.  Proofs given 
in the appendixes show that the conditions imposed by
the algorithms are both necessary and sufficient 
to prevent deadlock.  The algorithms have been successfully used in the THE system.	
.K
multiprogramming, time-sharing, scheduling, resource allocation
.C
3.72 4.32 6.20
.I 1878
.T
Recovery of Reentrant List Structures in SLIP
.W
One consequence of the reference-count-based
space-recovery system employed by SLIP is that 
reentrant list structures are not recovered even when
explicitly erased.  LISP-like garbage-collection 
schemes are free of this impediment.  They however,
depend on being able to find and mark nodes that 
are reachable from program variables.  By tracing all
descendants from program variables may then be 
identified and collected.  The list-creating function
LIST of SLIP may be amended to mark those lists 
for which the programmer wishes to assume responsibility.
 Given this modification, a LISP-like garbage 
collector that recovers abandoned reentrant list structures
may then be appended to the SLIP system.
.K
list processing, SLIP, garbage-collection
.C
4.22 4.40
.I 1879
.T
A Note on Storage Fragmentation and Program Segmentation
.W
The main purpose of this paper is the presentation
of some of the results of a series of simulation 
experiments investigating the phenomenon of storage fragmentation.
 Two different types of storage fragmentation 
are distinguished: (1) external fragmentation, namely the
loss in storage utilization caused by the inability 
to make use of all available storage after it has been
fragmented into a large number of separate blocks; 
and (2) internal fragmentation, the loss of utilization
caused by rounding up a request for storage, 
rather than allocating only the exact number of words required.
 The most striking result is the apparently 
general rule that rounding up requests for storage,
to reduce the number of different sizes of blocks 
coexisting in storage, causes more loss of storage
by increased internal fragmentation than is saved 
by decreased external fragmentation.  Described also are
a method of segment allocation and an accompanying 
technique for segment addressing which take advantage
of the above result.  Evidence is presented of 
possible advantages of the method over conventional paging techniques.
.K
storage allocation, storage fragmentation,
paging, segmentation, addressing
.C
6.2 6.20
.I 1880
.T
Chebyshev Solution to an Overdetermined
Linear System (Algorithm 328 [F4])
.K
Chebyshev solutions, over-determined linear
systems, linear equations, exchange algorithm 
.C
5.13 5.14 5.41
.I 1881
.T
Transpose Vector Stored Array (Algorithm 302 [K2])
.K
matrix transposition, array transposition, vector stored array
.C
5.39
.I 1882
.T
Determination of the Square Root of a Positive
Definite Matrix (Algorithm 298 [F1])
.K
matrix, symmetric matrix, positive definite matrix, matrix square root
.C
5.14
.I 1883
.T
Modified Romberg Quadrature(Algorithm [D1])
.K
numerical integration, Romberg quadrature,
trapezoid values, rectangle values, error bound
.C
5.16
.I 1884
.T
An Anomaly in Space-Time Characteristics of
Certain Programs Running in a Paging Machine
.W
The running time of programs in a paging machine
generally increases as the store in which 
programs are constrained to run decreases.  Experiments,
however, have revealed cases in which the reverse 
is true: a decrease in the size of the store is accompanied
by a decrease in running time.  An informal 
discussion of the anomalous behavior is given, and for
the case of the FIFO replacement algorithm a formal 
treatment is presented.
.K
paging machines, demand paging, replacement algorithm
.C
4.30
.I 1885
.T
A Computer System for Transformational Grammar
.W
A comprehensive system for transformational
grammar has been designed and implemented on the 
IBM 360/67 computer.  The system deals with the transformational
model of syntax, along the lines of 
Chomsky's Aspects of the Theory of Syntax. The major
innovations include a full,formal description of 
the syntax of a transformational grammar, a directed random
phrase structure generator, a lexical insertion 
algorithm, an extended definition of analysis, and
a simple problem-oriented programming language in 
which the algorithm for application of transformations
can be expressed.  In this paper we present the 
system as a whole, first discussing the general attitudes underlying
the development of the system, then 
outlining the system and discussing its more important
special features.  References are given to papers 
which consider some particular aspect of the system in detail.
.K
transformational grammar, natural language syntax,
language processing, language analysis, sentence 
generation, lexical insertion, computational linguistics, syntax
.C
3.42
.I 1886
.T
Generation of Optimal Code for Expressions via Factorization
.W
Given a set of expressions which are to be
compiled, methods are presented for increasing the 
efficiency of the object code produced by first factoring
the expressions, i.e. finding a set of subexpressions 
each of which occurs in two or more other expressions
or subexpressions.  Once all the factors have been 
ascertained, a sequencing procedure is applied which
orders the factors and expressions such that all 
information is computed in the correct sequence and factors
need be retained in memory a minimal amount 
of time.  An assignment algorithm is then executed in
order to minimize the total number of temporary 
storage cells required to hold the results of evaluating
the factors.  In order to make these techniques 
computationally feasible, heuristic procedures are
applied, and hence global optimal results are not 
necessarily generated.  The factorization algorithms
are also applicable to the problem of factoring 
Boolean switching expressions and of factoring polynomials
encountered in symbol manipulating systems.
.K
factorization algorithms, code optimization, sequencing
of operations, detection of common subexpressions, 
factorization of Boolean expressions
.C
4.12 6.1
.I 1887
.T
A Recursive Relation for the Determinant of a Pentadiagonal Matrix
.W
A recursive relation, relating leading principal
minors, is developed for the determinant of 
a pentadiagonal matrix.  A numerical example is included
to indicate its use in calculating eigenvalues.
.K
pentadiagonal matrix, quindiagonal matrix, quindiagonal
matrix, band matrix, determinant, characteristic 
polynomial, eigenvalues
.C
5.14
.I 1888
.T
Spline Function Methods for Nonlinear Boundary-Value Problems
.W
The solution of the nonlinear differential equation
Y"=F(x,Y,Y') with two-point boundary conditions 
is approximated by a quintic or cubic spline function
y(x).  The method is well suited to nonuniform 
mesh size and dynamic mesh size allocation.  For uniform
mesh size h, the error in the quintic spline 
y(x) is O(h^4), with typical error one-third that from
Numerov's method.  Requiring the differential 
equation to be satisfied at the mesh points results
in a set of difference equations, which are block 
tridiagonal and so are easily solved by relaxation or other standard methods.
.K
boundary value problems, differential equations,
finite differences, functional approximation, 
iterative methods, nonlinear equations, spline functions
.C
5.13 5.15 5.17
.I 1889
.T
Introducing Computing to Smaller Colleges
and Universities -- A Progress Report
.W
By technical means that are now routine, computer
service for smaller colleges and universities 
can be provided by remote terminals of a central facility.
 Access, however, is not enough-effective 
organizational and educational methodology for introducing
computing at such institutions must also be 
developed.  The experience of two years with a statewide
network involving-41 institutions is discussed. 
 Lessons include the importance of a separate organization
representing the small colleges, the necessity 
for on-campus training for the institutions, the need
for some special programming and documentation 
to support such users,and the development of curriculum by evolutionary means.
.K
regional network, introducing computing, under-graduate
education, instructional usage, academic 
applications, curriculum development, orientation project,
regional center, consortium, remote computing
.C
1.50 1.52 1.59 2.49
.I 1890
.T
Simulation of Traffic Flows in a Network
.W
A computer simulation program which deals
with traffic flows in the network of a large area 
is described.  Each road is segmented into blocks of
several ten-meter lengths and is represented by 
a bidirectional list in computer memory.  The movement
of cars, i.e. the transfer of cars from one block 
to the next, is expressed by a proper formula.  This
formula is based on the supposition that the speed 
of cars in a block is determined only by the density of
cars in the block, and this speed-versus-density 
curve is empirically given the numerical values.  This
simulation scheme has its excellent point in that 
it makes it possible to trace the dynamic behavior
of traffic flows in a variety of situations, some 
examples of which are given for an actual area of the city of Kyoto, Japan.
.K
traffic simulation, traffic flow, traffic network
traffic control, traffic density, intersection, 
signal setting, vehicle, road network, list structure, computer simulation
.C
3.57 3.23
.I 1891
.T
Three-Dimensional Computer Display
.W
A stereographic display terminal has been
produced using the raster display (BRAD) recently 
developed at Brookhaven.  The system uses a rotating refresh
memory to feed standard television monitors. 
 To produce a stereographic display the computer calculates
the projected video images of an object, 
viewed from two separate points.  The resulting video
maps are stored on separate refresh bands of the 
rotating memory.  The two output signals are connected
to separate color guns of a color television monitor, 
thus creating a superimposed image on the screen.  Optical
separation is achieved by viewing the image 
through color filters.  The display is interactive and
can be viewed by a large group of people at the 
same time.
.K
computer graphics, three-dimensional display, swept
raster display, interactive stereographic terminal, 
video map, color separation
.C
2.0 4.49 6.35
.I 1892
.T
Degree of Multiprogramming in Page-on-Demand Systems
.W
A simple stochastic model is described which
offers a base for understanding the relationship 
between the number of programs permitted to share memory
(the degree of multiprogramming), drum traffic 
rates, and central processing unit utilization in page-on-demand,
multiprogrammed, time-shared computer 
systems.  The model preserves, as a key feature, the
property of page-demand statistics which implies 
a "burst" of page demands at the beginning of any job
or quantum execution.  The model, a Markov chain, 
is analyzed numerically and the results are presented graphically
for a wide range of key environment-descriptive 
parameters.  Implications of the results to time-shared
system design and programming are discussed, 
and a calculation of the optimal degree of multiprogramming
for a wide range of parameters is presented 
graphically. 
.K
page-on-demand, demand paging, time-sharing multiprogramming,
Markovian computer models, scheduling 
strategies, operating systems, memory management
.C
2.44 4.32 4.39 6.20 6.21
.I 1893
.T
Roots of Polynomials by a Root-Squaring
and Resultant routine (Algorithm 340 [C2])
.K
root finders, roots of polynomial equations, polynomial
zeros, root-squaring operations, Graeffe 
method, resultant procedure, subresultant procedure,
testing of roots, acceptance criteria
.C
5.15
.I 1894
.T
Normal Random Deviates (Algorithm 334 [G5])
.K
normal deviates, normal distribution, random number,
random number generator, simulation, probability 
distribution, frequency distribution, random
.C
5.13 5.5
.I 1895
.T
Gaussian Quadrature Formulas (Algorithm 331 [D1])
.K
quadrature, Gaussian quadrature, numerical integration,
weight function, orthogonal polynomials
.C
5.16
.I 1896
.T
Regular Coulomb Wave Functions (Algorithm 292 S22])
.K
Coulomb wave functions, wave functions, regular Coulomb wave functions
.C
5.12
.I 1897
.T
Coulomb Wave Functions (Algorithm 300 [S22])
.K
Coulomb wave functions, wave functions
.C
5.12
.I 1898
.T
Regular Coulomb Wave Functions (Algorithm 292 [S22])
.K
Coulomb wave functions, wave functions, regular Coulomb wave functions
.C
5.12
.I 1899
.T
Simplex Method Procedure Employing Lu Decomposition (Algorithm 350 [H])
.K
simplex method, linear programming, LU decomposition,
round-off errors, computational stability
.C
5.41
.I 1900
.T
Clarification of Fortran Standards-Initial Progress
.W
In 1966 after four years of effort, FORTRAN
became the first programming language standardized 
in the United States.  Since that initial achievement,
study and application of the standard specifications 
have revealed the need for maintenance of the standards.
 As the result of work initiated in 1967, an 
initial set of clarifying interpretations has been prepared.
 The nature of the maintenance, corrections 
to the standard specifications, and completed interpretations are reported.
.K
USA Standard, FORTRAN, Basic FORTRAN, programming
language, standardization, language standard 
specification, language standard maintenance, language standard
clarification, language standard interpretation, 
standardization committee
.C
1.2 2.0 2.19 2.2 2.3 4.0 4.12 4.19 4.20 4.22 4.29 4.43 5.23 5.9 6.9
.I 1901
.T
Dynamic Space-Sharing in Computer Systems
.W
A formalization of relationships between space-shading
program behavior, and processor efficiency 
in computer systems is presented.  Concepts of value and
cost of space allocation per task are defined 
and then value and cost are combined to develop a single
parameter termed value per unit cost.  The intent 
is to illustrate a possible analytic approach to the
investigation of the problems of space-sharing and 
to demonstrate the method on sample problems.
.K
space-sharing, storage allocation, memory allocation,
storage management, memory management, program 
behavior, multiprogramming, computer system design, allocation
strategies, replacement strategies, demand-paging, 
time-sharing
.C
4.32 6.2 6.20
.I 1902
.T
An Automatic Grading Scheme for Simple Programming Exercises
.W
A discussion is given of alterations that were
made to a typical university operating system 
to record the results of programming exercises in three
different languages, including assembly language. 
 In this computer-controlled grading scheme provision
is made for testing with programmer-supplied data 
and for final runs with system-supplied data.  Exercises
run under the scheme may be mixed with other 
programs, and no special recognition of exercises by the operators is necessary.
.K
automatic grading program, programming exercises
.C
1.5 2.43 4.39
.I 1903
.T
Chebyshev Interpolation and Quadrature Formulas of Very High Degree
.K
Chebyshev polynomials, Chebyshev interpolation,
Chebyshev quadrature, Chebyshev points, Chebyshev 
zeros, interpolation, quadrature, definite integrals
.C
5.13 5.16
.I 1904
.T
Rough and Ready Error Estimates in Gaussian
Integration of Analytic Functions
.K
numerical integration, analytic functions, error
estimates, Gaussian integration, tabulated error 
coefficients, computable error coefficients, Cauchy
integral formula, Chebyshev polynomials
.C
5.11 5.16
.I 1905
.T
The Simplex Method of Linear Programming Using LU Decomposition
.W
Standard computer implementations of Dantzig's
simplex method for linear programming are based 
upon forming the inverse of the basic matrix and updating
the inverse after every step of the method. 
 These implementations have bad round-off error properties.
 This paper gives the theoretical background 
for an implementation which is based upon the LU decomposition,
computed with row interchanges, of the 
basic matrix.  The implementation is slow, but has good
round-off error behavior.  The implementation 
appears as CACM Algorithm 350.
.K
simplex method, linear programming, LU decomposition,
round-off errors, computational stability
.C
5.41
.I 1906
.T
Automated Printed Circuit Routing with a Stepping Aperture
.W
A computer program for routing interconnections
on a two-sided printed circuit board with a 
regular pattern of lines, pins (terminals), and vias
(feed-through holes) is described.  In this program, 
each interconnection is given a planned routing-typically,
down from the upper pin, through a via, and 
horizontally to the lower pin.  From the top, a virtual
aperture (i.e. a long horizontal slit) is stepped 
down the board.  The planned routing is the basis for
rerouting interconnections within the aperture 
to resolve conflicts for lines and vias below the aperture
and to maximize the effective line usage. 
 If a conflict has not been resolved before the aperture
arrives at the lower pin,interconnections are 
deleted to resolve the conflict.  Extensions of this technique
to the control of crosstalk between routed 
interconnections and to the problem of obtaining
100 percent interconnect are also discussed.
.K
routing, printed circuit, interconnections, aperture,
stepping aperture, computer program, circuit 
board, lines, vias, pins
.C
3.24 6.30
.I 1907
.T
A Note on Reliable Full-Duplex Transmission over Half-Duplex Links
.W
A simple procedure for achieving reliable full-duplex
transmission over half-duplex links is 
proposed. The scheme is compared with another of the
same type, which has recently been described in 
the literature.  Finally, some comments are made on
another group of related transmission procedures 
which have been shown to be unreliable under some circumstances.
.K
data transmission, error correction, full-duplex,
half-duplex, transmission control, communications
.C
3.81
.I 1908
.T
Time-Sharing and Batch-Processing:  An Experimental
Comparison of Their Values in a Problem - 
Solving Situation
.W
An experimental comparison of problem-solving
using time-sharing and batch-processing computer 
systems conducted at MIT is described in this paper.
 This study is the first known attempt to evaluate 
two such systems for what may well be the predominant user
population within the next decade-the professionals 
who, as nonprogrammers, are using the computer as an
aid in decision-making and problem-solving rather 
than as a programming end in itself.  Statistically
and logically significant results indicate equal 
cost for usage of the two computer systems; however,
a much higher level of performance is attained by 
time-sharing users.  There are indications that significantly
lower costs would have resulted if the 
time-sharing users had stopped work when they reached
a performance level equal to that of the batch 
users.  The users' speed of problem-solving and their
attitudes made time-sharing the more favorable 
system.
.K
time-sharing vs batch-processing, user performance,
man/machine communications, cost effectiveness, 
on-line vs off-line performance, decision-making performance,
user/programmer behavior, programming experimental 
empirical studies, problem-solving, research in man/machine
communications, man/machine symbiosis
.C
2.11 2.40 3.36 3.51 3.80
.I 1909
.T
Computation of Jn(x) by Numerical Integration
.W
It is shown to be practical to compute Jn(x) by
numerical integration of its integral representation 
using the trapezoidal rule. The error in this
approximation was studied empirically.
.K
Bessel Function, numerical integration, trapezoidal rule
.C
5.11 5.12 5.16
.I 1910
.T
An Algorithm for Solving a Special Class
of Tridiagonal Systems of Linear Equations
.W
An algorithm is presented for solving a system
of linear equation Bu=k where B is tridiagonal 
and of a special form.  It is shown that this algorithm
is almost twice as fast as the Gaussian elimination 
method usually suggested for solving such systems. 
In addition, explicit formulas for the inverse and 
determinant of the matrix B are given.
.K
tridiagonal, Gaussian elimination, central difference
.C
5.14 5.17
.I 1911
.T
On Coordination Reduction and Sentence Analysis
.W
A class of coordination phenomena in natural
languages is considered within the frame work 
of transformational theory.  To account for these phenomena
it is proposed that certain machinery be 
added to the syntactic component of a transformational
grammar. This machinery includes certain rule 
schemata, the conditions under which they are to be
applied, and conditions determining the sequence 
of subtrees on which they are to be performed.  A solution
to the syntactic analysis problem for this 
class of grammars is outlined.  Precise specification
of both the generative procedure of this paper 
and its inverse is given in the form of LISP function definitions.
.K
natural languages, generative grammar, transformational
theory, syntax, coordination, sentence 
coordination, sentence coordination, coordination reduction,
syntactic analysis, grammar testing program, 
rule testing
.C
3.42
.I 1912
.T
Simulation of Outpatient Appointment Systems
.W
An experimental computer program is described
which simulates appointment systems employed 
by outpatient departments of hospitals.  Both major kinds
of appointment systems-individual and block-can 
be simulated.  The purpose of the Simulator is to enable
the user to evaluate the effectiveness of alternative 
appointment systems in a given clinical environment.
.K
simulation, scheduling, appointment system, outpatient
department, medicine, health, management
science, operations research
.C
3.34 3.59
.I 1913
.T
Polygamma Functions with Arbitrary Precision (Algorithm 349 [S14])
.K
polygamma function, psi function, digamma function,
trigamma function, tetragamma function, pentagamma 
function, special functions
.C
5.12
.I 1914
.T
Matrix Scaling by Integer Programming (Algorithm 348 [F1])
.K
integer programming, linear algebra, mathematical
programming, matrix condition, matrix scaling
.C
5.14 5.41
.I 1915
.T
An Algorithm for Hidden Line Elimination
.W
The algorithm presented causes the elimination of
hidden lines in the representation of a perspective 
view of concave and convex plane-faced objects on the
picture plane.  All the edges of the objects are 
considered sequentially, and all planes which hide every
point of an edge are found.  The computing time 
increases roughly as the square of the number of edges.
 The algorithm takes advantage of a reduced number 
of concave points and automatically recognizes if only
one object with no concave points is considered. 
In this last case, the result is obtained in a much simpler way.
.K
hidden line elimination, back line recognition, three-dimensional
representation, plane-faced objects, 
perspective view, machine rendering of solids, automatic
drawing, displaying techniques, computer graphics, 
man/machine interaction, man/machine communication, computer-aided design
.C
4.40 4.41 4.49
.I 1916
.T
Analysis of Boolean Program Models for Time-Shared, Paged Environments
.W
Directed graphs or their associated matrices are
frequently used to represent the logical structure 
of sequences of computer instructions.  Such techniques
are used and, in addition, data references are 
represented in a nondirected model. The complete structural
specification of a program is represented 
by a combined model.  A transformation of the combined
model yields a new model in which additional timing 
information is also contained.  Analysis of these models
prior to execution yields information valuable 
in determining segmentation of instructions and data for
a time-shared environment, as well as for initial 
page loading; during execution, the analysis may be
used for "look ahead" control of page turning.
.K
time-sharing, paging, segmentation, executive,
compiler, monitor, program model
.C
4.39 6.21
.I 1917
.T
An Algol Procedure for the Fast Fourier Transform
with Arbitrary Factors (Algorithm 339 [C6])
.K
fast Fourier transform, complex Fourier transform,
multivariate Fourier transform, Fourier series, 
harmonic analysis, spectral analysis, orthogonal polynomials,
orthogonal transformation, virtual core 
memory, permutation
.C
3.15 3.83 5.12 5.14
.I 1918
.T
Distribution of Indistinguishable Objects
into Distinguishable Slots (Algorithm 329 [G6])
.I 1919
.T
An Efficient Algorithm for Sorting with
Minimal Storage (Algorithm 347 [M1])
.K
sorting, minimal storage sorting, digital computer sorting
.C
5.31
.I 1920
.T
F-Test Probabilities (Algorithm 346 [S14])
.K
F-test, Snedecor F-statistic, Fisher Test, distribution function
.C
5.5
.I 1921
.T
An Algol Convolution Procedure Based on the
Fast Fourier Transform (Algorithm 345 [C6])
.K
fast Fourier transform, complex Fourier transform,
multivariate Fourier transform, Fourier series, 
harmonic analysis, spectral analysis, orthogonal polynomials,
orthogonal transformation, convolution, 
auto covariance, autocorrelation, cross-correlation,
digital filtering, permutation
.C
3.5 3.83 5.12 5.14
.I 1922
.T
Proposed USA Standard (Data Communication Control
Procedures for the USA Standarad Code for Information 
Interchange)
.K
data communication, data communication control procedures,
data communication establishment/termination 
procedures, data communication message transfer procedures,
data communication error control procedures, 
data communication polling/selection procedures, communication,
communication control procedures, communication 
establishment/termination procedures, communication
message transfer procedures, communication error 
control procedures, communication polling/selection procedures,
link, link control procedures, link establishment/termination 
procedures, link message transfer procedures, link error
control procedures, link polling/selection procedures, 
data link, data link control procedures, data link  establishment/termination
procedures, data link message 
transfer procedures, data link error control procedures,
data link polling/selection procedures
.C
3.81 4.49 6.39
.I 1923
.T
Pseudofiles
.W
An approach to system interfaces for high
level languages using basic input/output support 
facilities is described.  It is shown that this technique
can provide potentially inexpensive methods 
for programs to communicate with deeply embedded
facilities such as command language processors.
.K
operating systems, interfaces input-output,
high level languages, command language
.C
4.22 4.30 4.31 4.41
.I 1924
.T
Organizing Matrices and Matrix Operations for Paged Memory Systems
.W
Matrix representations and operations are examined
for the purpose of minimizing the page faulting 
occurring in a paged memory system.  It is shown that
carefully designed matrix algorithms can lead to 
enormous savings in the number of page faults occurring
when only a small part of the total matrix can 
be in main memory at one time.  Examination of addition,
multiplication, and inversion algorithms shows 
that a partitioned matrix representation (i.e. one submatrix
or partition per page) in most cases induced 
fewer page faults than a row-by-row representation.
 The number of page-pulls required by these matrix 
manipulation algorithms is also studied as a function
of the number of pages of main memory available 
to the algorithm.
.K
matrix algorithms, array processing, paging algorithms,
paged memory systems, virtual memory systems, 
array storage allocation, storage allocation
.C
4.12 4.39 5.14
.I 1925
.T
Concepts of Use in Contour Map Processing
.W
Generalized techniques whose use can simplify
the solution of problems relating to contour 
maps.  One of these techniques makes use of the topological
properties of contour maps.  The topology 
is represented by a graphical structure in which adjacent
contour lines appear as connected nodes.  Another 
generalized technique consists of utilizing geometrical
properties to determine the characteristics of 
straight lines drawn on the contour map.  Both of these
techniques have been applied to the problem of 
locating the ground track of an aircraft from
elevation readings obtained during a flight.
.K
map, contour map, contour lines, topological properties,
geometrical properties, graph of contour 
map, navigation
.C
3.1
.I 1926
.T
Description of FORMAT, a Text-Processing Program
.W
FORMAT is a production program which facilitates
the editing and printing of "finished" documents 
directly on the printer of a relatively small (64k) computer
system.  It features good performance, totally 
free-form input, very flexible formatting capabilities
including up to eight columns per page, automatic 
capitalization, aids for index construction, and a
minimum of nontext items.  It is written entirely 
in FORTRAN IV.
.K
text processing, indexing, printing, documentation,
text editing, formatting, frequency dictionary, 
right justification, vocabulary
.C
3.74 3.75 3.9
.I 1927
.T
Information Science in a Ph.D. Computer Science Program
.W
This report contains recommendations on a sample course
curriculum in the general area of information 
organization and information system design in a Ph.D.
Computer Science Program.  The subject area is 
first briefly described, followed by a listing of some desirable
graduate-level courses.  Suitable bibliographies 
are appended.
.K
course curriculum, graduate courses, university
courses,computer science curriculum, information 
science, information organization, information retrieval,
data retrieval, language analysis, information 
processing
.C
1.52 3.42 3.70
.I 1928
.T
Exclusive Simulation of Activity in Digital Networks
.W
A technique for simulating the detailed logic
networks of large and active digital systems 
is described.  Essential objectives sought are improved
ease and economy in model generation, economy 
in execution time and space, and a facility for handling
simultaneous activities.  The main results obtained 
are a clear and useful separation of structural and behavioral
model description, a reduction of manual 
tasks in converting Boolean logic into a structural model,
the elimination of manual processes in achieving 
exclusive simulation of activity, an event-scheduling
technique which does not deteriorate in economy
as the event queue grows in length, and a simulation
procedure which deals effectively with any mixture 
of serial and simultaneous activities.  The passage of
time is simulated in a precise, quantitative fashion 
and systems to be simulated may be combinations of synchronous
and asynchronous logic.  Certain aspects 
of the techniques described may be used for the simulation
of network structures other than digital networks.
.K
simulation, logical simulation, digital simulation,
large systems simulation, network structures, 
scheduling, queuing, simultaneous activities, parallel events
.C
4.22 4.29 6.9
.I 1929
.T
Images from Computers and Microfilm Plotters
.W
Digital computers are widely used for the
processing of information and data of all kinds, 
including the pictorial information contained in photographs
and other graphical representations.  Efficient 
conversion facilities for putting graphical information
into the computer and retrieving it in graphical 
form are therefore much needed.  One of the most commonly
employed devices for obtaining permanent graphical 
output from digital computers is the microfilm plotter.
 Regrettably, present models have no provision 
for producing images with a continuous gray scale or "half tones."
 In this note several programming techniques 
are described for obtaining half tone pictures from a
microfilm plotter under the control of a digital 
computer.  Illustrative examples of several methods are given.
.K
computer images, half tone pictures, microfilm plotters; processing
.C
3.10 3.15 3.24 4.49
.I 1930
.T
Extremely Portable Random Number Generator
.W
Extremely portable subroutines are sometimes
needed for which moderate quality and efficiency 
suffice.  Typically, this occurs for library functions
(like random number generation and in core sorting) 
which are not entirely universal or are not used in a
standardized way.  The literature on random number 
generators does not seem to contain an algorithm that
meets requirements of this sort.  An extremely 
portable 8-line FORTRAN program is provided which based
on an important paper by Coveyou and MacPherson 
(1967).Using their methods, Fourier analysis is applied
to the probability function for the consecutive 
n-tuples provided by our generator (with n less than
or equal to 4).  While the small modulus which must 
be used to maintain portability prevents the quality
of the generator from being high, the generator 
compares well with the bounds established in the above mentioned paper.
.K
random number generators, random numbers, random
number analysis, random generators, linear sequential 
generators, random number program, pseudo random numbers 
.C
4.49 5.19 5.5
.I 1931
.T
Interval Arithmetic Determinant Evaluation
and Its Use in Testing for a Chebyshev System
.W
Two recent papers, one by Hansen and one by
Hansen and R. R. Smith, have shown how Interval 
Arithmetic (I.A.) can be used effectively to bound errors
in matrix computations.  In the present paper 
a method proposed by Hasen and R. R. Smith is compared
with straightforward use of I.A. in determinant 
evaluation.  Computational results show the accuracy
and running times that can be expected when using 
I.A. for determinant evaluation.  An application using
I.A. determinants in a program to test a set of 
functions to see if they form a Chebyshev system is then presented.
.K
interval arithmetic, range arithmetic, error bounds,
determinant evaluation, Chebyshev system, 
mathematical proof by computer
.C
5.11 5.13 5.14
.I 1932
.T
The Logarithmic Error and Newton's Method for the Square Root
.W
The problem of obtaining optimal starting values
for the calculation of the square root using 
Newton's method is considered.  It has been pointed out
elsewhere that if relative error is used as the 
measure of goodness of fit, optimal results are not
obtained when the initial approximation is a best 
fit.  It is shown here that if, instead, the so-called
logarithmic error is used, then a best initial 
fit is optimal for both types of error.  Moreover, use
of the logarithmic error appears to simplify the 
problem of determining the optimal initial approximation.
.K
square root, Newton's method, relative error, logarithmic
error, best fit, optimal approximation, 
maximal error, recurrence relation, integer root, error curve
.C
5.12 5.13
.I 1933
.T
Coding the Lehmer Pseudo-random Number Generator
.W
An algorithm and coding technique is presented
for quick evaluation of the Lehmer pseudo-random 
number generator modulo 2**31 - 1, a prime Mersenne
number with produces 2**31 - 2 numbers, on a p-bit 
(greater than 31) computer.  The computation method is
extendible to limited problems in modular arithmetic. 
 Prime factorization for 2**61 - 2 and a primitive root
for 2**61 - 1, the next largest prime Mersenne 
number, are given for possible construction of a pseudo-random
number generator of increased cycle length.
.K
pseudo-random number, random number, modular arithmetic,
uniform probability density, uniform frequency 
function, simulation, prime factorization, primitive roots
.I 1934
.T
On Arithmetic Expressions and Trees
.W
A description is given of how a tree representing the
evaluation of an arithmetic expression 
can be drawn in such a way that the number of accumulators
needed for the computation can be represented 
in a straightforward manner.  This representation reduces
the choice of the best order of computation 
to a specific problem under the theory of graphs.
 An algorithm to solve this problem is presented.
.K
arithmetic expression, compiler design, graph theory,
programming, storage minimization, topological 
ordering,tree
.C
4.12 5.32
.I 1935
.T
Randomized Binary Search Technique
.W
A mathematical model is developed for the mean
and variance of the number of trials to recover 
a given document in a randomly received list of files.
 The search method described is binary in nature 
and offers new potential for information retrieval systems.
.K
binary pattern, file examination, graph theory, information
retrieval, mathematical model, partitioning, 
probabilistic method, random sequencing, search techniques, tree structures
.C
3.74 5.32
.I 1936
.T
Variable Length Tree Structures Having Minimum Average Search Time
.W
Sussenguth suggests in a paper (1963) that a
file should be organized as a doubly-chained tree 
structure if it is necessary both to search and to update
frequently.  Such a structure provides a compromise 
between the fast search/slow update characteristics of
binary searching and the slow search/fast update 
characteristics of serial searching.  His method, however,
contains the limiting restriction that all 
terminal nodes lie on the same level of the tree.  This paper
considers the effect of relaxing this restriction. 
 First, trees which have the property that a priori the
filial set of each node is well defined are studied. 
 It is proved that coding the nodes within each filial
set with respect to the number of terminal nodes 
reachable from each is necessary and sufficient to guarantee
minimum average search time.  Then the more 
general case (that is, where the entire structure of
the tree is changeable) is treated.  A procedure 
is developed for constructing a tree with a minimum
average search time.  A simple closed expression 
for this minimum average search time is obtained as
a function of the number of terminal nodes.  The 
storage capacity required to implement the doubly-chained
tree structure on a digital computer is also 
determined.  Finally, the total cost of the structure,
using Sussenguth's cost criterion, is computed. 
 It is shown that significant improvements in both
the average search time and the total cost can be 
obtained by relaxing Sussenguth's restriction that all
terminal nodes lie on the same level of the tree.
.K
information retrieval, file searching, tree structures, double chaining
.C
3.70 3.73 3.74
.I 1937
.T
CODAS: A Data Display System
.W
CODAS, a Customer Oriented Data System, is
a user-oriented data retrieval and display system. 
 The command language of the system provides the user
with an easy means for specifying data retrieval 
and display requests.  Data is displayed as tables and
graphs produced in a format ready for publication. 
 In this paper the statements of the request language
and the general system design are described.
.K
data display, information retrieval, graphic display,
command languages, report program generation, 
management data processing
.C
3.50 3.51 3.59 3.70 3.75 3.79 4.20 4.29
.I 1938
.T
Some Criteria for Time-Sharing System Performance
.W
Time-sharing systems, as defined in this article,
are those multiaccess systems which permit 
a terminal user to utilize essentially the full resources
of the system while sharing its time with other 
terminal users.  It is each terminal user's ability
to utilize the full resources of the system that 
makes quantitative evaluation of time-sharing systems
particularly difficult.  Six criteria are described 
which have been successfully used to perform first-level
quantitative time-sharing system performance 
evaluation.
.K
time-sharing performance criteria, time-sharing
system operation, time-sharing performance analysis
.C
2.40 4.30 4.32 6.20
.I 1939
.T
Directed Random Generation of Sentences
.W
The problem of producing sentences of a transformational
grammar by using a random generator 
to create phrase structure trees for input to the lexical
insertion and transformational phases is discussed. 
 A purely random generator will produce base trees
which will be blocked by the transformations, and 
which are frequently too long to be of practical interest.
 A solution is offered in the form of a computer 
program which allows the user to constrain and direct
the generation by the simple but powerful device 
of restricted subtrees.  The program is a directed
random generator which accepts as input a subtree 
with restrictions and produces around it a tree which
satisfies the restrictions and is ready for the 
next phase of the grammar.  The underlying linguistic
model is that at Noam Chomsky, as presented in 
Aspects of the Theory of Syntax.  The program is written
in FORTRAN IV for the IBM 360/67 and is part
of a unified computer system for transformational grammar.
 It is currently being used with several partial 
grammars of English.
.K
transformational grammar, natural language syntax, language
processing, sentence generation, computational 
linguistics, syntax
.C
3.42
.I 1940
.T
Calculation of a Polynomial and its Derivative
Values by Horner Scheme (Algorithm 337 [C1])
.K
function, evaluation, polynomial evaluation,
ALGOL procedure, Horner's scheme
.C
4.22 5.12
.I 1941
.T
F-Distribution (Algorithm 322 [S14])
.K
Fisher's F-distribution, Students's t-distribution
.C
5.5
.I 1942
.T
Finding a Solution of N Functional Equations
in N Unknowns (Algorithm 314 [C5])
.K
functional equations, interpolation, nonlinear equations, secant method
.C
5.13 5.15
.I 1943
.T
Complete Elliptic Integrals (Algorithm 165 [S21])
.K
special functions, complete elliptic integral
of the first kind, complete elliptic integral of 
the second kind
.C
5.12
.I 1944
.T
Student's t-Distribution (Algorithm 344 [S14])
.K
Student's t-Distribution, t-test, small-sample
statistics, distribution function
.C
5.12 5.5
.I 1945
.T
The Role of Programming in a Ph.D. Computer Science Program
.W
In this general paper the role of programming
in advanced graduate training is discussed.  
Subject matter related to programming as well as programming
per se is considered.  The  importance and 
application of formalism are considered and also the
need for good empirical experimentation.  A brief 
outline for a sequence of courses is included, and subject
headings that have been obtained from an extensive 
bibliography are given.  A bibliography of programming references is included.
.K
graduate-level programming, graduate programs, course
content, course sequence, graduate curriculum, 
programming research topics, programming bibliography
.C
1.3 1.52 4.0
.I 1946
.T
Computing Polynomial Resultants: Bezout's Determinant
vs. Collins' Reduced P.R.S. Algorithm
.W
Algorithms for computing the resultant of two
polynomials in several variables, a key repetitive 
step of computation in solving systems of polynomial
equations by elimination, are studied.  Determining 
the best algorithm for computer implementation depends
upon the extent to which extraneous factors are 
introduced, the extent of propagation of errors caused by
truncation of real coefficients, memory requirements, 
and computing speed.  Preliminary considerations narrow
the choice of the best algorithm to Bezout's 
determinant and Collins' reduced polynomial remainder sequence
(p.r.s.) algorithm.  Detailed tests performed 
on sample problems conclusively show that Bezout's determinant
is superior in all respects except for 
univariate polynomials, in which case Collins' reduced
p.r.s. algorithm is somewhat faster.  In particular 
Bezout's determinant proves to be strikingly superior in
numerical accuracy, displaying excellent stability 
with regard to round-off errors. Results of tests are reported in detail.
.K
resultant algorithm, g.c.d. algorithm, polynomial
resultant, elimination, Bezout's determinant, 
Sylvester's determinant, reduced p.r.s. algorithm, Euclidean
algorithm, multivariate polynomial equations
.C
4.40 5.10 5.15 5.41
.I 1947
.T
Object code Optimization
.W
Methods of analyzing the control flow and data
flow of programs during compilation are applied 
to transforming the program to improve object time efficiency.
 Dominance relationships, indicating which 
statements are necessarily executed before others, are
used to do global common expression elimination 
and loop identification.  Implementation of these and other
optimizations in OS/360 FORTRAN H are described.
.K
compilers, data flow analysis, dominance, efficiency,
FORTRAN,  graph theory, loop structure, machine 
instructions, object code, optimization, redundancy
elimination, register assignment, System/360
.C
4.12 5.24 5.32
.I 1948
.T
Computers in Group Theory: a Survey
.W
Computers are being applied to an increasingly
diverse range of problems in group theory.  
The most important areas of application at present are
coset enumeration, subgroup lattices, automorphism 
groups of finite groups, character tables, and commutator
calculus.  Group theory programs range from 
simple combinatorial or numerical programs to large
symbol manipulation systems.  In this survey the 
more important algorithms in use are described and contrasted,
and results which have been obtained using 
existing programs are indicated.  An extensive bibliography is included.
.K
group theory, coset enumeration, subgroup lattices,
automorphism groups, character tables, commutator 
calculus, topology, crystallography, permutation groups,
Abelian groups, discrete mathematics, non-numerical 
programming, symbol manipulation, survey
.C
1.3 3.15 5.39
.I 1949
.T
Finiteness Assumptions and Intellectual Isolation of Computer Scientists
.K
Algol vs. Fortran, finiteness assumptions, intellectual isolation,
integer variable range, memory finiteness, finite word size
.C
2.2 4.22 5.23
.I 1950
.T
Efficient Handling of Binary Data
.K
binary variables, dummy variables, bit strings, cross-tabulations
.C
4.9
.I 1951
.T
Estimates of Distributions of Random Variables
for Certain Computer Communications Traffic Models
.W
A study of multiaccess computer communications has
characterized the distributions underlying an elementary
 model of the user-computer interactive process.  The model used is
elementary in the sense that many of the random variables that
generally are of interest in computer communications studies can be
decomposed into the elements of this model.  Data were examined
from four operational multiaccess systems, and the model is shown to
be robust; that is each of the variables of the model has the
same distribution independent of which of the four systems is being examined. 
It is shown that the gamma distribution can be used to
describe the discrete variables.  Approximations to the gamma distribution
by the exponential distribution are discussed for the systems studied.
.K
computer communications, time-sharing,
operating systems, optimization models
.C
3.80 3.81 6.20
.I 1952
.T
Index by Subject to Algorithms, 1970
.I 1953
.T
Exponential Integral Ei(x) (Algorithms 385 $S13))
.K
ANSI Fortran standard
.C
4.0 4.22
.I 1954
.T
Eigenvalues and Eigenvectors of a Real
Symmetric Matrix (Algorithm 384 $F2))
.K
real symmetric matrix, eigenvalues, eigenvectors, QR algorithm
.C
5.14
.I 1955
.T
Characteristic Values and Associated Solutions of
Mathieu's Differential Equation (Algorithm 352 $S22))
.K
Mathieu's differential equation, Mathieu function, characteristic
value, periodic solution, radial solution
.C
5.12
.I 1956
.T
Optimum Merging from Mass Storage
.W
An algorithm is displayed which yields the merge orders such that the total
read time, defined to be the sum of seek time plus data-transfer
time, is minimized for a sort using mass storage. The analysis is
parameterized in terms of the ratio of seek time to the time it takes
to fill available core with records, and the file size in units
of core lengths; and thus it can be applied to any conventional
CPU/mass storage combination.  An explicit formula for total read
time is derived, in terms of the parameters, which correlates very
well with the total read time calculated using the optimum merge
orders yielded by the algorithm.  The formula involves the roots of a simple 
transcendental equation.  A short table of these roots
is included.  Numerical results are graphically displayed for a wide
range of the parameters.  It is found that the normalized read
time for optimum merging on a given hardware configuration is proportional
to the file length times the logarithm of the file length.
.K
sorting, merging, optimum merging, mass storage,
sort timing, drum-merging, access time
.C
3.37 4.49 5.31
.I 1957
.T
The List Set Generator: A Construct for Evaluating Set Expressions
.W
The list set generator is defined and algorithms
for its use are given.  The list set generator is
a construct which may be added to a list processing system or any
system that handles sets.  It efficiently generates the set which
results from any expression involving sets and set operators.  The
efficiency derives from evaluating the expression as a whole and
in parallel, rather than evaluating subexpressions and
then using those sets to arrive at the final result.
.K
set manipulating, list processing, set
generation, sets, lists, file processing
.C
3.73 3.74 4.22
.I 1958
.T
Improving Round-off in Runge-Kutta Computations with Gill's Method
.W
A Runge-Kutta-Gill scheme in common use is based on an incomplete
adaptation for floating point operations of Gill's method.  An
improved version reduces round-off error significantly.  In this note
the heart of the scheme is presented in Fortran language.  It is
then shown how an improved version of the method can be obtained with
the addition of two Fortran statements.  The two version is a
significant improvement.  A numerical example comparing the two is included.
.K
Runge-Kutta methods, ordinary differential
equations, round-off error, error analysis
.C
5.11 5.17
.I 1959
.T
An Interrupt Based Organization for Management Information Systems
.W
A programming structure, language constructs, and a supervisory system 
organization are proposed
for the design and coding of large shared data base systems.  The
bases for this organization are a generalized interrupt structure
and the newly introduced concept of "file tagging," which is the
process of associating program structures and interrupt generating
conditions with items in the data base.  An algorithm for resolving
conflicts which arise in scheduling the interrupt processing routines
is presented.  DPL, a programming language and supervisory
system in which these concepts are implemented, is used to illustrated
the new organization which is proposed for management information systems.
.K
management information systems, integrated data processing,
supervisors, interrupts monitoring systems, supervisory
systems, interrupt scheduling, parallel processing
.C
3.51 4.22 4.32
.I 1960
.T
Process Management and Resource Sharing in the Multiaccess System ESOPE
.W
The main design principles of the multiaccess system ESOPE are described.
Emphasis is placed on basic ideas underlying the design rather
than on implementation details.  The main features of the system
include the ability given to any user to schedule his own parallel
processes using system primitive operations, the file-memory relationship,
and the allocation-scheduling policy, which dynamically
takes into account recent information about user behavior.
.K
time-sharing, multiprogramming, process scheduling, resource allocation
.C
4.32
.I 1961
.T
An Efficient Search Algorithm to Find the Elementary Circuits of a Graph
.W
A theoretically most efficient search algorithm is presented
which uses an exhaustive search to find all of the elementary
circuits of a graph.  The algorithm can be easily modified to find all
of the elementary circuits with a particular attribute such as
length.  A rigorous proof of the algorithm is given as well as an example
of its application.  Empirical bounds are presented relating
the speed of the algorithm to the number of vertices and the number
of arcs.  The speed is also related to the number of circuits
in the graph to give a relation between speed and complexity.
Extensions to undirected and s-graphs are discussed.
.K
algorithm, graph theory, circuit search
algorithm, path search algorithm, searching
.C
3.74 5.32
.I 1962
.T
GROOVE-A Program to Compose, Store, and Edit Functions of Time
.W
A program which makes possible creating, storing, reproducing,
and editing functions of time is described.  The functions are typical
of those generated by human beings.  Multiple functions (up to 14)
are produced for long periods of time (up to several hours) at
sufficiently high sampling rates to describe fast human reactions
(up to 200 samples per second).  The functions can be used for a
variety of purposes such as the control of machine tools or sound
synthesizers or anything a person normally controls.  The program
operates on a small computer (DDP-224).  Functions are stored on a
disk file.  Functions may be created by real-time human inputs to
the computer which can interact with already stored functions and
computed functions.  Real-time feedback from the process being
controlled is an important link in the system.  The environment for
effective man-machine interaction has been carefully nurtured.
.K
computer music, music, real-time control, digital control, time
functions, interactive software, hybrid systems, conductor program
.C
3.44 3.8 7.3
.I 1963
.T
Condition Numbers of PEI Matrices
.K
matrices, condition numbers, Pei matrices, eigenvectors, eigenvalues
.C
5.14
.I 1964
.T
Comment on the Working Set Model for Program Behavior
.K
demand paging, working set, paging rate, multiprogramming
.C
4.30 4.32
.I 1965
.T
Correction to "Logical" Arithmetic on Computers
with Two's Complement Binary Arithmetic
.K
binary arithmetic, unsigned operand arithmetic, maximum
significance arithmetic, full-precision arithmetic
.C
3.15 5.11
.I 1966
.T
A Generalized Method for Generating Argument/Function Values
.K
mapping function, decision hierarchy, table look-up
.C
4.9 5.39
.I 1967
.T
An Improved Algorithm to Produce Complex Primes (Algorithm 401 $A1))
.K
number theory, prime numbers, complex numbers
.C
5.39
.I 1968
.T
Eigenvalues and Eigenvectors of a Real
General Matrix (Algorithm 343 $F1))
.K
eigenvalues, eigenvectors, latent roots, Householder's
method, QR algorithm, inverse iteration
.C
5.14
.I 1969
.T
Increasing the Efficiency of Quicksort (Algorithm 402 $M1))
.K
sorting, quicksort 
.C
5.31 3.73 5.6 4.49
.I 1970
.T
Unrecorded Magnetic Tape for Information Interchange (9 Track-200 and
800 CPI, NRZI and 1600 CPI, PE)* (Proposed American National Standard)
.K
input-output, magnetic tape, information interchange,
measurement, instrumentation, phase encoded recording 
.C
2.49 6.35
.I 1971
.T
Recorded Magnetic Tape for Information Interchange (1600
CPI, Phase Encoded)* (Proposed American National Standard)
.K
input-output, magnetic tape, information interchange,
measurement, instrumentation, phase encoded recording 
.C
2.49 6.35
.I 1972
.T
A  Nonrecursive List Compacting Algorithm 
.W
A simple nonrecursive list structure compacting scheme or garbage 
collector suitable for both compact and LISP-like list structures is presented.
The algorithm avoids the need for recursion by using the partial structure as 
it is built up to keep track of those lists that have been copied.
.K
list compacting, garbage collection, compact list, LISP
.C
4.19 4.49
.I 1973
.T
The Linear Quotient Hash Code
.W
A new method of hash coding is presented and
is shown to possess desirable attributes.  Specifically, the algorithm
is simple, efficient, and exhaustive, while needing little
time per probe and using few probes per lookup.  Performance
data and implementation hints are also given.
.K
hashing, hash code, scatter storage, calculated
address, search, table, lookup, symbol table, keys
.C
3.74 4.9
.I 1974
.T
NEATER2: A PL/I Source Statement Reformatter
.W
NEATER2 accepts a PL/I source program and operates on it to produce
a reformatted version.  When in the LOGICAL mode, NEATER2 indicates
the logical structure of the source program in the indentation
pattern of its output.  Logic errors discovered through NEATER2
logical analysis are discovered much more economically than is possible
through compilation and trial runs.  A number of options are
available to give the user full control over the output format and
to maximize the utility of NEATER2 as an aid during the early
stages of development of a PL/I source deck.  One option, USAGE, causes
NEATER2 to insert into each logical unit of coding a statement
which will case the number of times each one is executed to be recorded
during execution.  This feature is expected to provide a
major aid in optimization of PL/I programs.
.K
logical analysis of PL/I source, reformatting of PL/I
source, documentation aid, execution time usage data
.C
1.52 4.12 4.19 4.42
.I 1975
.T
A Multiple-Precision Division Algorithm
.W
A generalized division algorithm for use with positive integral operands is 
presented.  Depending upon the algebraic relationship of the first
two ciphers of the divisor, one or at most two adjustments to the original 
divisor and dividend must be performed before the division operation can be 
initiated. The uniqueness of this method will cause each trial cipher in the 
quotient to be either equal to or one greater than its final replacement.
.K
multiple-precision, division, adjustment, generalize
.C
3.15 4.0 5.1
.I 1976
.T
Multi-attribute Retrieval with Combined Indexes
.W
In this paper a file organization scheme designed to
replace the use of the popular secondary index filing scheme
(or inverted files on secondary key fields) is described.
Through the use of redundancy and storing 
keys (or access numbers of the records) that satisfy different combinations
of secondary index values in "buckets," it is possible to retrieve
all keys satisfying any input query derived from a subset of
fields by a single access to an index file, although each bucket may
be used for many combinations of values and a combination of
buckets may be required for a given query.  The method which, in its
degenerate case, becomes the conventional secondary index filing
scheme works similarly but has the following advantages: (1) the elimination
of multiple accesses in many cases; (2) the elimination
of false drops; (3) the elimination of computer time to perform intersection
of key sets each qualified for one secondary index field
only; and (4) the avoidance of long strings of keys when an index
field appearing in a query has very few possible values.  Redundancy, in some 
cases, is the same as the secondary indexing method. In the general case, 
trade-off between the number of accesses for query and redundancy exists.
.K
file organization, secondary index files, inverted files, information
retrieval, data management, access method, secondary 
keys, storage with buckets, rapid retrieval, balanced filing scheme, elimination
of false drops, combining indexes, query, multi-attribute retrieval
.C
3.73 3.74 3.79
.I 1977
.T
An Interactive Display for Approximation by Linear Programming
.W
An interactive program
with a graphical display has been developed for the approximation of
data by means of a linear combination of functions (including
splines) selected by the user.  The coefficients of the approximation
are determined by linear programming so as to minimize the error
in either the L1 or L-infinity norm.  Auxiliary conditions such as
monotonicity or convexity of the approximation can also be imposed. This
interactive system is described and several examples of its use are given.
.K
approximation, data fitting, functional approximation, linear
programming, interactive graphical display, spline functions
.C
5.13 5.41
.I 1978
.T
The Use of Interactive Graphics To Solve Numerical Problems
.W
With the advent of on-line (time-sharing) computer systems
and graphic terminals, we have available a new dimension
in numerical problem solving capabilities.  Rather than simply use
the new power to achieve fast turnaround, we can develop interactive
routines which are easy to use and also take advantage of the
insight and visual capabilities of the human problem solver.  Several
on-line systems for general purpose mathematical problem solving
have already been implemented as well as some special purpose
systems for solving problems in a particular area such as ordinary
differential equations.  The advantage of restricting the problem
area is that the interface with a user can be greatly simplified.
In this paper we discuss some of the advantages accrued by such
systems and design considerations for interactive routines.  Furthermore,
an implementation of an on-line least squares data-fitting
program, PEG, is presented with results obtained from empirical
data.  In conclusion, area for future work in this field are discussed.
.K
interactive graphics, computer graphics, graphics, least squares,
data-fitting, interactive computing, on-line mathematics
.C
1.3 3.1 5.13 5.5
.I 1979
.T
Numerical Inversion of Laplace Transforms (Algorithm 368 $D5))
.K
Laplace transform inversion, integral transformations, integral equations
.C
5.15 5.18
.I 1980
.T
An Efficient Algorithm for Sorting with
Minimal Storage (Algorithm 347 $M1))
.K
sorting, ranking, minimal storage sorting, digital computer sorting
.C
5.31
.I 1981
.T
Normal Curve Integral (Algorithm 304 $S15))
.K
normal curve integral, probability, special functions
.C
5.12 5.5
.I 1982
.T
Modified Havie Integration (Algorithm 400 $D1))
.K
numerical integration, Havie integration, Romberg quadrature,
modified Romberg-quadrature, trapezoid values, rectangle values
.C
5.16
.I 1983
.T
Spanning Tree $H) (Algorithm 399)
.K
graph, tree, spanning tree
.C
5.32
.I 1984
.T
Tableless Date Conversion $Z) (Algorithm 398)
.K
date, calendar
.C
5.9
.I 1985
.T
An Integer Programming Problem $H) (Algorithm 397)
.K
integer programming, change making problem
.C
5.41
.I 1986
.T
Student's t-Quantiles $S14) (Algorithm 396)
.K
Student's t-statistic, quantile, asymptotic approximation
.C
5.12 5.5
.I 1987
.T
Student's t-Distribution $S14) (Algorithm 395)
.K
Student's t-statistic, distribution function,
approximation, asymptotic expansion
.C
5.12 5.5
.I 1988
.T
A Formalism for Translator Interactions
.W
A formalism is presented for describing the actions
of processors for programming languages-compilers,
interpreters, assemblers-and their interactions in complex systems
such as compiler-compilers or extendible languages.
The formalism here might be used to define and answer such a
question as "Can one do bootstrapping using a meta-compiler 
whose metaphase is interpretive?"  In addition an algorithm
is presented for deciding whether or not a given system can
be produced from a given set of component processors.
.K
translator, compiler, interpreter, bootstrapping,
language processor, compiler-compiler
.C
4.1 5.29
.I 1989
.T
Transition Network Grammars for Natural Language Analysis
.W
The use of augmented transition network grammars for the analysis
of natural language sentences is described.  Structure-building
actions associated with the arcs of the grammar network allow for the reordering,
restructuring, and copying of constituents necessary to produce
deep-structure representations of the type normally obtained from a
transformational analysis, and conditions on the arcs allow for a
powerful selectivity which can rule out meaningless analyses and take
advantage of semantic information to guide the parsing.  The
advantage of this model for natural language analysis are discussed
in detail and illustrated by examples.  An implementation of an
experimental parsing system for transition network grammars is briefly 
described.
.K
computational linguistics, grammars, grammar models, linguistics,
natural language analysis, parsing, semantic interpretation,
transition network grammars, transformational grammars
.C
3.42 4.12
.I 1990
.T
Numerical Constants (Algorithm)
.K
numerical algorithm, numerical constants
.C
5.10
.I 1991
.T
On the Number of Automorphisms of a Singly Generated Automaton
.K
automata, finite automata, singly generated automata, automorphisms,
generators, length of state, minimal-length generators, orbit
.C
5.22
.I 1992
.T
Comment on Bell's Quadratic Quotient Method for Hash Code Searching
.K
hashing, hash code, scatter storage, calculated address,
clustering, search, symbol table, keys, table look-up
.C
3.74 4.9
.I 1993
.T
Regular Coulomb Wave Functions (Algorithm 292 $S22))
.K
Coulomb wave functions, wave functions, regular Coulomb wave functions
.C
5.12
.I 1994
.T
Decision Table Translation $H) (Algorithm 394)
.K
Decision table, decision table translation
.C
4.19
.I 1995
.T
Special Series Summation with Arbitrary Precision $C6) (Algorithm 393)
.K
function evaluation, series summation, approximation
.C
5.12 5.13
.I 1996
.T
Systems of Hyperbolic PDE $D3) (Algorithm 392)
.K
hyperbolic p.d.e., characteristic, extrapolation,
second order p.d.e., quasilinear p. d. e.
.C
5.17
.I 1997
.T
Increasing the Efficiency of Quicksort
.W
A method is presented for the analysis of various generalizations of
quicksort.  The average asymptotic number of comparisons needed is shown
 to be an log^2(n).  A formula is derived expressing a in terms of
the probability distribution of the "bound" of a partition.  This
 formula assumes a particularly simple form for a generalization already
considered by Hoare, namely, choice of the bound as median
of a random sample. The main contribution of this paper is another
generalization of quicksort, which uses a bounding interval instead
of a single element as bound.  This generalization turns out to
be easy to implement in a computer program.  A numerical approximation
shows that a = 1.140 for this version of quicksort compared with
1.386 for the original.  This implies a decrease in number of comparisons of 
18 percent; actual tests showed about 15 percent saving in computing time.
.K
sorting, quicksort, information content, entropy, distribution of median
.C
3.73 4.49 5.31 5.6
.I 1998
.T
Complex Matrix Inversion Versus Real
.W
A comparison of complex matrix with real matrix inversion
is made.  It is shown that the complex inversion can be up to 
twice as fast as the real inversion.  Further, the rounding error
bound for complex inversion is about one-eighth that of real,
for Gaussian elimination.  Using extended inner product
accumulation the bound is half of the real system.
.K
complex matrix inversion, matrix inversion, inversion, rounding errors,
rounding error bound, error bounds, complex rounding error bounds
.C
5.14 5.11 5.10
.I 1999
.T
Optimal Starting Approximations for Generating
Square Root for Slow or No Divide
.W
On machine with slow or no division, it is preferable to
use an iterative scheme for the square root different from
the classical Heron scheme.  The problem of optimal initial 
approximants is considered, and some optimal polynomial initial 
approximations are tabulated.
.K
square root, Newton-Raphson iteration, optimal approximants
.C
5.13
.I 2000
.T
A Variation of the Goodman-Lance Method for
the Solution of Two-Point Boundary Value Problems
.W
A recently published method for the interpolative
solution of nonlinear equations is improved,
and applied to give a significant variation of the Goodman-Lance
method for the solution of two-point boundary value problems. 
The resulting method applies in particular to the numerical solution
of optimal control problems in the Euler-Lagrange formulation.
Quantitative estimates are presented which indicate that the variation
is nearly twice as fast on some problems in the latter context.
.K
Goodman-Lance, boundary-value problems,
Newton's method, nonlinear equations,
optimal control, optimization, ordinary differential equations,
secant method, interpolative solution, orthogonal matrices
.C
3.21 5.15 5.17
.I 2001
.T
Integrating Square Roots
.W
Differential equation of the (y')^2 = f(y) are difficult to integrate 
numerically because of the singularity at points where f(y) vanishes.  A 
simple trick removes the singularity.
.K
quadrature, differential equations
.C
5.16 5.17
.I 2002
.T
AMESPLOT-A Higher Level Data Plotting Software System
.W
AMESPLOT is an extensible software system designed to make the display of 
data as simple, painless, and neat as possible.  The system described is 
hardware-independent and has been implemented on a variety of installations,
of different manufacturers, having diverse configurations.  The elements 
common to all types of data plots are outlined and the way in which these 
elements may be combined into a system based on simple modules is demonstrated.
These modules are specified independently and are independent of the axis
systems or other attributes of the plot.  This enables plots of any
complexity to be constructed by adding or replacing modules.  The
basic syntax of AMESPLOT is outlined, and a brief description is given
of its current utility software, consisting of "macros" to produce
self-scaled plots, formal tablets of text-interspersed with subplots,
map coastlines, and 3-D plots.  The system was formulate
d in a way such that the user could supply the minimum of information,
and it should be fully integrable with user's program written
in most conventional higher languages.  The functions of positioning,
locating, and scaling (in the layout of multiple subplots) of
axes, labels, and all other elements of the plot are handled automatically
by the software system unless the user specifies otherwise.  The structuring 
of plots from multiple, independent, self-contained subplots is described.
Transformation, projection, scaling, rotation, or shifting of entire plots or 
subplots by the action of one or more simple modules is possible.  The user 
may interact freely with AMESPLOT at three levels, enabling him to construct 
his own data markers, alphabetic characters, and transformations, and
to produce a variety of artistic and other effects.
.K
computer graphics, data potting, data display
syntax, hardware independent software,
display device independent software, plot elements, self-scaled plots,
user interaction, tablet organization, map display, projection
.C
4.13 4.29 4.49 4.9
.I 2003
.T
An Interactive Software System for Computers-Aided
Design:  An Application to Circuit Project
.W
The characteristics of an interactive software system, intended to constitute 
an interface between designer and computer during various steps of
the design process, are presented.  The main emphasis is given to the
description of the features of the two high level user oriented
languages, operating at different levels, on which the interaction
is based.  The first one is IMOL, an interactive monitor language,
which is designed to perform the overall and control functions
of the software system; its design criteria provide the user with
commands which are both simple and efficient in order to perform all
the functions needed in computer-aided circuit design.  The second one is 
COIF, a circuit oriented graphic language, which is designed
to describe, generate, and manipulate graphic problem specifications; 
it is an  extension of Fortran with graphic-type variables,
so that the designer who is familiar with Fortran need not learn a new 
language.  The application to computer-aided circuit design
is in particular examined; on the other hand, the adopted design
criteria provide sufficient generality to extend the use of the two languages 
to different computer-assisted applications.
.K
interaction, graphics, computer graphics, computer-aided design, circuit
design, software system, software organization, language,
monitor language, graphic language, extended Fortran
.C
3.24 3.25 4.